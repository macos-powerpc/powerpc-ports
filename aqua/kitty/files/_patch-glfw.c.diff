--- kitty/glfw.c.orig	2022-09-05 13:19:50.000000000 +0800
+++ kitty/glfw.c	2026-01-08 02:41:46.000000000 +0800
@@ -11,24 +11,7 @@
 #include "charsets.h"
 #include <structmember.h>
 #include "glfw-wrapper.h"
-#ifndef __APPLE__
 #include "freetype_render_ui_text.h"
-#endif
-extern bool cocoa_make_window_resizable(void *w, bool);
-extern void cocoa_focus_window(void *w);
-extern long cocoa_window_number(void *w);
-extern void cocoa_create_global_menu(void);
-extern void cocoa_hide_window_title(void *w);
-extern void cocoa_system_beep(const char*);
-extern void cocoa_set_activation_policy(bool);
-extern void cocoa_set_titlebar_appearance(void *w, unsigned int theme);
-extern void cocoa_set_titlebar_color(void *w, color_type color);
-extern bool cocoa_alt_option_key_pressed(unsigned long);
-extern void cocoa_toggle_secure_keyboard_entry(void);
-extern void cocoa_set_uncaught_exception_handler(void);
-extern void cocoa_update_menu_bar_title(PyObject*);
-extern size_t cocoa_get_workspace_ids(void *w, size_t *workspace_ids, size_t array_sz);
-extern monotonic_t cocoa_cursor_blink_interval(void);
 
 
 static GLFWcursor *standard_cursor = NULL, *click_cursor = NULL, *arrow_cursor = NULL;
@@ -41,10 +24,6 @@
     if (OPT(click_interval) < 0) OPT(click_interval) = glfwGetDoubleClickInterval(glfw_window);
     if (OPT(cursor_blink_interval) < 0) {
         OPT(cursor_blink_interval) = ms_to_monotonic_t(500ll);
-#ifdef __APPLE__
-        monotonic_t cbi = cocoa_cursor_blink_interval();
-        if (cbi >= 0) OPT(cursor_blink_interval) = cbi / 2;
-#endif
     }
 }
 
@@ -76,12 +55,6 @@
 
 void
 update_menu_bar_title(PyObject *title UNUSED) {
-#ifdef __APPLE__
-    static char buf[2048];
-    strip_csi_(PyUnicode_AsUTF8(title), buf, arraysz(buf));
-    DECREF_AFTER_FUNCTION PyObject *stitle = PyUnicode_FromString(buf);
-    cocoa_update_menu_bar_title(stitle);
-#endif
 }
 
 
@@ -231,15 +204,6 @@
 static void
 window_pos_callback(GLFWwindow* window, int x UNUSED, int y UNUSED) {
     if (!set_callback_window(window)) return;
-#ifdef __APPLE__
-    // Apple needs IME position to be accurate before the next key event
-    OSWindow *osw = global_state.callback_os_window;
-    if (osw->is_focused && is_window_ready_for_callbacks()) {
-        Tab *tab = osw->tabs + osw->active_tab;
-        Window *w = tab->windows + tab->active_window;
-        if (w->render_data.screen) update_ime_position(w, w->render_data.screen);
-    }
-#endif
     global_state.callback_os_window = NULL;
 }
 
@@ -496,33 +460,6 @@
 
 static void get_window_dpi(GLFWwindow *w, double *x, double *y);
 
-#ifdef __APPLE__
-static bool
-apple_url_open_callback(const char* url) {
-    set_cocoa_pending_action(LAUNCH_URLS, url);
-    return true;
-}
-
-extern bool cocoa_render_line_of_text(const char *text, const color_type fg, const color_type bg, uint8_t *rgba_output, const size_t width, const size_t height);
-
-bool
-draw_window_title(OSWindow *window UNUSED, const char *text, color_type fg, color_type bg, uint8_t *output_buf, size_t width, size_t height) {
-    static char buf[2048];
-    strip_csi_(text, buf, arraysz(buf));
-    return cocoa_render_line_of_text(buf, fg, bg, output_buf, width, height);
-}
-
-extern uint8_t* render_single_ascii_char_as_mask(const char ch, size_t *result_width, size_t *result_height);
-
-uint8_t*
-draw_single_ascii_char(const char ch, size_t *result_width, size_t *result_height) {
-    uint8_t *ans = render_single_ascii_char_as_mask(ch, result_width, result_height);
-    if (PyErr_Occurred()) PyErr_Print();
-    return ans;
-}
-
-#else
-
 static FreeTypeRenderCtx csd_title_render_ctx = NULL;
 
 static bool
@@ -573,7 +510,6 @@
     if (PyErr_Occurred()) PyErr_Print();
     return ans;
 }
-#endif
 // }}}
 
 void
@@ -691,9 +627,6 @@
 static bool
 toggle_fullscreen_for_os_window(OSWindow *w) {
     if (w && w->handle) {
-#ifdef __APPLE__
-        if (!OPT(macos_traditional_fullscreen)) return do_toggle_fullscreen(w, 1, false);
-#endif
         return do_toggle_fullscreen(w, 0, true);
     }
     return false;
@@ -702,9 +635,6 @@
 bool
 is_os_window_fullscreen(OSWindow *w) {
     unsigned int flags = 0;
-#ifdef __APPLE__
-    if (!OPT(macos_traditional_fullscreen)) flags = 1;
-#endif
     if (w && w->handle) return glfwIsFullscreen(w->handle, flags);
     return false;
 }
@@ -723,54 +653,16 @@
     return maximized;
 }
 
-
-#ifdef __APPLE__
-static GLFWwindow *apple_preserve_common_context = NULL;
-
-static int
-filter_option(int key UNUSED, int mods, unsigned int native_key UNUSED, unsigned long flags) {
-    if ((mods == GLFW_MOD_ALT) || (mods == (GLFW_MOD_ALT | GLFW_MOD_SHIFT))) {
-        if (OPT(macos_option_as_alt) == 3) return 1;
-        if (cocoa_alt_option_key_pressed(flags)) return 1;
-    }
-    return 0;
-}
-
-static bool
-on_application_reopen(int has_visible_windows) {
-    if (has_visible_windows) return true;
-    set_cocoa_pending_action(NEW_OS_WINDOW, NULL);
-    return false;
-}
-
-static bool
-intercept_cocoa_fullscreen(GLFWwindow *w) {
-    if (!OPT(macos_traditional_fullscreen) || !set_callback_window(w)) return false;
-    toggle_fullscreen_for_os_window(global_state.callback_os_window);
-    global_state.callback_os_window = NULL;
-    return true;
-}
-#endif
-
 void
 set_titlebar_color(OSWindow *w, color_type color, bool use_system_color, unsigned int system_color UNUSED) {
     if (w->handle && (!w->last_titlebar_color || (w->last_titlebar_color & 0xffffff) != (color & 0xffffff))) {
         w->last_titlebar_color = (1 << 24) | (color & 0xffffff);
-#ifdef __APPLE__
-        if (!use_system_color) cocoa_set_titlebar_color(glfwGetCocoaWindow(w->handle), color);
-        else cocoa_set_titlebar_appearance(glfwGetCocoaWindow(w->handle), system_color);
-#else
         if (global_state.is_wayland && glfwWaylandSetTitlebarColor) glfwWaylandSetTitlebarColor(w->handle, color, use_system_color);
-#endif
     }
 }
 
 static PyObject*
 native_window_handle(GLFWwindow *w) {
-#ifdef __APPLE__
-    void *ans = glfwGetCocoaWindow(w);
-    return PyLong_FromVoidPtr(ans);
-#endif
     if (glfwGetX11Window) return PyLong_FromLong((long)glfwGetX11Window(w));
     return Py_None;
 }
@@ -796,21 +688,11 @@
         if (OPT(hide_window_decorations) & 1) glfwWindowHint(GLFW_DECORATED, false);
         glfwSetApplicationCloseCallback(application_close_requested_callback);
         glfwSetCurrentSelectionCallback(get_current_selection);
-#ifdef __APPLE__
-        cocoa_set_activation_policy(OPT(macos_hide_from_tasks));
-        glfwWindowHint(GLFW_COCOA_GRAPHICS_SWITCHING, true);
-        glfwSetApplicationShouldHandleReopen(on_application_reopen);
-        glfwSetApplicationWillFinishLaunching(cocoa_create_global_menu);
-#endif
     }
 
-#ifdef __APPLE__
-    glfwWindowHint(GLFW_COCOA_COLOR_SPACE, OPT(macos_colorspace));
-#else
     glfwWindowHintString(GLFW_X11_INSTANCE_NAME, wm_class_name);
     glfwWindowHintString(GLFW_X11_CLASS_NAME, wm_class_class);
     glfwWindowHintString(GLFW_WAYLAND_APP_ID, wm_class_class);
-#endif
 
     if (global_state.num_os_windows >= MAX_CHILDREN) {
         PyErr_SetString(PyExc_ValueError, "Too many windows");
@@ -824,12 +706,6 @@
     glfwWindowHint(GLFW_VISIBLE, false);
     GLFWwindow *common_context = global_state.num_os_windows ? global_state.os_windows[0].handle : NULL;
     GLFWwindow *temp_window = NULL;
-#ifdef __APPLE__
-    if (!apple_preserve_common_context) {
-        apple_preserve_common_context = glfwCreateWindow(640, 480, "kitty", NULL, common_context);
-    }
-    if (!common_context) common_context = apple_preserve_common_context;
-#endif
     if (!global_state.is_wayland) {
         // On Wayland windows dont get a content scale until they receive an enterEvent anyway
         // which won't happen until the event loop ticks, so using a temp window is useless.
@@ -855,9 +731,6 @@
     // blank the window once so that there is no initial flash of color
     // changing, in case the background color is not black
     blank_canvas(is_semi_transparent ? OPT(background_opacity) : 1.0f, OPT(background));
-#ifndef __APPLE__
-    if (is_first_window) glfwSwapInterval(OPT(sync_to_monitor) && !global_state.is_wayland ? 1 : 0);
-#endif
     // On Wayland the initial swap is allowed only after the first XDG configure event
     if (glfwAreSwapsAllowed(glfw_window)) glfwSwapBuffers(glfw_window);
     glfwSetInputMode(glfw_window, GLFW_LOCK_KEY_MODS, true);
@@ -866,16 +739,6 @@
     Py_DECREF(pret);
     if (x != -1 && y != -1) glfwSetWindowPos(glfw_window, x, y);
     glfwShowWindow(glfw_window);
-#ifdef __APPLE__
-    float n_xscale, n_yscale;
-    double n_xdpi, n_ydpi;
-    get_window_content_scale(glfw_window, &n_xscale, &n_yscale, &n_xdpi, &n_ydpi);
-    if (n_xdpi != xdpi || n_ydpi != ydpi) {
-        // this can happen if the window is moved by the OS to a different monitor when shown
-        xdpi = n_xdpi; ydpi = n_ydpi;
-        fonts_data = load_fonts_data(OPT(font_size), xdpi, ydpi);
-    }
-#endif
     if (is_first_window) {
         PyObject *ret = PyObject_CallFunction(load_programs, "O", is_semi_transparent ? Py_True : Py_False);
         if (ret == NULL) return NULL;
@@ -904,10 +767,6 @@
     w->shown_once = true;
     w->last_focused_counter = ++focus_counter;
     os_window_update_size_increments(w);
-#ifdef __APPLE__
-    if (OPT(macos_option_as_alt)) glfwSetCocoaTextInputFilter(glfw_window, filter_option);
-    glfwSetCocoaToggleFullscreenIntercept(glfw_window, intercept_cocoa_fullscreen);
-#endif
     send_prerendered_sprites_for_window(w);
     if (logo.pixels && logo.width && logo.height) glfwSetWindowIcon(glfw_window, 1, &logo);
     glfwSetCursor(glfw_window, standard_cursor);
@@ -929,16 +788,7 @@
     glfwSetScrollCallback(glfw_window, scroll_callback);
     glfwSetKeyboardCallback(glfw_window, key_callback);
     glfwSetDropCallback(glfw_window, drop_callback);
-#ifdef __APPLE__
-    if (glfwGetCocoaWindow) {
-        if (OPT(hide_window_decorations) & 2) {
-            glfwHideCocoaTitlebar(glfw_window, true);
-        } else if (!(OPT(macos_show_window_title_in) & WINDOW)) {
-            cocoa_hide_window_title(glfwGetCocoaWindow(glfw_window));
-        }
-        cocoa_make_window_resizable(glfwGetCocoaWindow(glfw_window), OPT(macos_window_resizable));
-    } else log_error("Failed to load glfwGetCocoaWindow");
-#endif
+
     monotonic_t now = monotonic();
     w->is_focused = true;
     w->cursor_blink_zero_time = now;
@@ -966,73 +816,22 @@
     }
 }
 
-#ifdef __APPLE__
-static bool
-window_in_same_cocoa_workspace(void *w, size_t *source_workspaces, size_t source_workspace_count) {
-    static size_t workspaces[64];
-    size_t workspace_count = cocoa_get_workspace_ids(w, workspaces, arraysz(workspaces));
-    for (size_t i = 0; i < workspace_count; i++) {
-        for (size_t s = 0; s < source_workspace_count; s++) {
-            if (source_workspaces[s] == workspaces[i]) return true;
-        }
-    }
-    return false;
-}
-
-static void
-cocoa_focus_last_window(id_type source_window_id, size_t *source_workspaces, size_t source_workspace_count) {
-    id_type highest_focus_number = 0;
-    OSWindow *window_to_focus = NULL;
-    for (size_t i = 0; i < global_state.num_os_windows; i++) {
-        OSWindow *w = global_state.os_windows + i;
-        if (
-                w->id != source_window_id && w->handle && w->shown_once &&
-                w->last_focused_counter >= highest_focus_number &&
-                (!source_workspace_count || window_in_same_cocoa_workspace(glfwGetCocoaWindow(w->handle), source_workspaces, source_workspace_count))
-        ) {
-            highest_focus_number = w->last_focused_counter;
-            window_to_focus = w;
-        }
-    }
-    if (window_to_focus) {
-        glfwFocusWindow(window_to_focus->handle);
-    }
-}
-#endif
-
 void
 destroy_os_window(OSWindow *w) {
-#ifdef __APPLE__
-    static size_t source_workspaces[64];
-    size_t source_workspace_count = 0;
-#endif
     if (w->handle) {
-#ifdef __APPLE__
-        source_workspace_count = cocoa_get_workspace_ids(glfwGetCocoaWindow(w->handle), source_workspaces, arraysz(source_workspaces));
-#endif
         // Ensure mouse cursor is visible and reset to default shape, needed on macOS
         show_mouse_cursor(w->handle);
         glfwSetCursor(w->handle, NULL);
         glfwDestroyWindow(w->handle);
     }
     w->handle = NULL;
-#ifdef __APPLE__
-    // On macOS when closing a window, any other existing windows belonging to the same application do not
-    // automatically get focus, so we do it manually.
-    cocoa_focus_last_window(w->id, source_workspaces, source_workspace_count);
-#endif
 }
 
 void
 focus_os_window(OSWindow *w, bool also_raise) {
     if (w->handle) {
-#ifdef __APPLE__
-        if (!also_raise) cocoa_focus_window(glfwGetCocoaWindow(w->handle));
-        else glfwFocusWindow(w->handle);
-#else
         (void)also_raise;
         glfwFocusWindow(w->handle);
-#endif
     }
 }
 
@@ -1056,30 +855,20 @@
     const char* path;
     int debug_keyboard = 0, debug_rendering = 0;
     if (!PyArg_ParseTuple(args, "s|pp", &path, &debug_keyboard, &debug_rendering)) return NULL;
-#ifdef __APPLE__
-    cocoa_set_uncaught_exception_handler();
-#endif
     const char* err = load_glfw(path);
     if (err) { PyErr_SetString(PyExc_RuntimeError, err); return NULL; }
     glfwSetErrorCallback(error_callback);
     glfwInitHint(GLFW_DEBUG_KEYBOARD, debug_keyboard);
     glfwInitHint(GLFW_DEBUG_RENDERING, debug_rendering);
     OPT(debug_keyboard) = debug_keyboard != 0;
-#ifdef __APPLE__
-    glfwInitHint(GLFW_COCOA_CHDIR_RESOURCES, 0);
-    glfwInitHint(GLFW_COCOA_MENUBAR, 0);
-#else
+#ifndef __APPLE__
     if (glfwDBusSetUserNotificationHandler) {
         glfwDBusSetUserNotificationHandler(dbus_user_notification_activated);
     }
 #endif
     PyObject *ans = glfwInit(monotonic_start_time) ? Py_True: Py_False;
     if (ans == Py_True) {
-#ifdef __APPLE__
-        glfwSetCocoaURLOpenCallback(apple_url_open_callback);
-#else
         glfwSetDrawTextFunction(draw_text_callback);
-#endif
         OSWindow w = {0};
         set_os_window_dpi(&w);
         global_state.default_dpi.x = w.logical_dpi_x;
@@ -1257,9 +1046,6 @@
 
 static PyObject*
 toggle_secure_input(PYNOARG) {
-#ifdef __APPLE__
-    cocoa_toggle_secure_keyboard_entry();
-#endif
     Py_RETURN_NONE;
 }
 
@@ -1276,9 +1062,7 @@
     monotonic_t now = monotonic();
     if (last_bell_at >= 0 && now - last_bell_at <= ms_to_monotonic_t(100ll)) return;
     last_bell_at = now;
-#ifdef __APPLE__
-    cocoa_system_beep(OPT(bell_path));
-#else
+#ifndef __APPLE__
     if (OPT(bell_path)) play_canberra_sound(OPT(bell_path), "kitty bell", true, "event");
     else play_canberra_sound("bell", "kitty bell", false, "event");
 #endif
@@ -1433,12 +1217,8 @@
     OSWindow *w = find_os_window(PyLong_AsUnsignedLongLong(os_wid));
     if (!w) { PyErr_SetString(PyExc_ValueError, "No OSWindow with the specified id found"); return NULL; }
     if (!glfwGetCocoaWindow) { PyErr_SetString(PyExc_RuntimeError, "Failed to load glfwGetCocoaWindow"); return NULL; }
-#ifdef __APPLE__
-    return Py_BuildValue("l", (long)cocoa_window_number(glfwGetCocoaWindow(w->handle)));
-#else
-    PyErr_SetString(PyExc_RuntimeError, "cocoa_window_id() is only supported on Mac");
+    PyErr_SetString(PyExc_RuntimeError, "cocoa_window_id() is only supported with Cocoa back-end");
     return NULL;
-#endif
 }
 
 static PyObject*
@@ -1496,34 +1276,6 @@
     Py_RETURN_NONE;
 }
 
-#ifdef __APPLE__
-void
-get_cocoa_key_equivalent(uint32_t key, int mods, char *cocoa_key, size_t key_sz, int *cocoa_mods) {
-    memset(cocoa_key, 0, key_sz);
-    uint32_t ans = glfwGetCocoaKeyEquivalent(key, mods, cocoa_mods);
-    if (ans) encode_utf8(ans, cocoa_key);
-}
-
-static void
-cocoa_frame_request_callback(GLFWwindow *window) {
-    for (size_t i = 0; i < global_state.num_os_windows; i++) {
-        if (global_state.os_windows[i].handle == window) {
-            global_state.os_windows[i].render_state = RENDER_FRAME_READY;
-            global_state.os_windows[i].last_render_frame_received_at = monotonic();
-            request_tick_callback();
-            break;
-        }
-    }
-}
-
-void
-request_frame_render(OSWindow *w) {
-    glfwCocoaRequestRenderFrame(w->handle, cocoa_frame_request_callback);
-    w->render_state = RENDER_FRAME_REQUESTED;
-}
-
-#else
-
 static void
 wayland_frame_request_callback(id_type os_window_id) {
     for (size_t i = 0; i < global_state.num_os_windows; i++) {
@@ -1565,8 +1317,6 @@
     return PyLong_FromUnsignedLongLong(notification_id);
 }
 
-#endif
-
 static PyObject*
 get_click_interval(PyObject *self UNUSED, PyObject *args UNUSED) {
     return PyFloat_FromDouble(monotonic_t_to_s_double(OPT(click_interval)));
@@ -1594,10 +1344,6 @@
 
 void
 stop_main_loop(void) {
-#ifdef __APPLE__
-    if (apple_preserve_common_context) glfwDestroyWindow(apple_preserve_common_context);
-    apple_preserve_common_context = NULL;
-#endif
     glfwStopMainLoop();
 }
 
@@ -1655,9 +1401,7 @@
 void cleanup_glfw(void) {
     if (logo.pixels) free(logo.pixels);
     logo.pixels = NULL;
-#ifndef __APPLE__
     release_freetype_render_context(csd_title_render_ctx);
-#endif
 }
 
 bool
