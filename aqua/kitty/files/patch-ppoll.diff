--- glfw/backend_utils.c.orig	2022-09-05 13:19:50.000000000 +0800
+++ glfw/backend_utils.c	2026-01-08 00:35:25.000000000 +0800
@@ -23,6 +23,33 @@
 #define ppoll pollts
 #endif
 
+#ifdef __APPLE__
+static int
+pipe2(int pipefd[2], int flags) {
+    if (pipe(pipefd) != 0) return -1;
+
+    if (flags & O_CLOEXEC) {
+        if (fcntl(pipefd[0], F_SETFD, FD_CLOEXEC) == -1 ||
+            fcntl(pipefd[1], F_SETFD, FD_CLOEXEC) == -1) {
+            close(pipefd[0]);
+            close(pipefd[1]);
+            return -1;
+        }
+    }
+
+    if (flags & O_NONBLOCK) {
+        if (fcntl(pipefd[0], F_SETFL, O_NONBLOCK) == -1 ||
+            fcntl(pipefd[1], F_SETFL, O_NONBLOCK) == -1) {
+            close(pipefd[0]);
+            close(pipefd[1]);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+#endif
+
 void
 update_fds(EventLoopData *eld) {
     for (nfds_t i = 0; i < eld->watches_count; i++) {
@@ -174,8 +201,18 @@
 
 int
 pollWithTimeout(struct pollfd *fds, nfds_t nfds, monotonic_t timeout) {
+#ifdef __APPLE__
+    int timeout_ms;
+    if (timeout < 0) {
+        timeout_ms = -1;
+    } else {
+        timeout_ms = (int)((timeout + 999999) / 1000000);
+    }
+    return poll(fds, nfds, timeout_ms);
+#else
     struct timespec tv = calc_time(timeout);
     return ppoll(fds, nfds, &tv, NULL);
+#endif
 }
 
 static void
@@ -410,8 +447,13 @@
     if (fd < 0)
         return -1;
 #endif
+
+#ifdef __APPLE__
+    ret = ftruncate(fd, size);
+#else
     // posix_fallocate does not work on SHM descriptors
     ret = shm_anon ? ftruncate(fd, size) : posix_fallocate(fd, 0, size);
+#endif
     if (ret != 0)
     {
         close(fd);
