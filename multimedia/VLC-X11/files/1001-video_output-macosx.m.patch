From 8dcebd7b8052413dbbfe0f0cc0b59c0f4f1f274f Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Sat, 11 Oct 2025 11:05:31 +0800
Subject: [PATCH 1/4] video_output/macosx.m

---
 modules/video_output/macosx.m | 500 ++++++++++++++--------------------
 1 file changed, 207 insertions(+), 293 deletions(-)

diff --git modules/video_output/macosx.m modules/video_output/macosx.m
index 904c36a311..0ad3870264 100644
--- modules/video_output/macosx.m
+++ modules/video_output/macosx.m
@@ -70,7 +70,6 @@ static void OpenglSwap (vlc_gl_t *gl);
  * Module declaration
  */
 vlc_module_begin ()
-    /* Will be loaded even without interface module. see voutgl.m */
     set_shortname ("Mac OS X")
     set_description (N_("Mac OS X OpenGL video output"))
     set_category (CAT_VIDEO)
@@ -96,9 +95,9 @@ vlc_module_end ()
 }
 - (void)setVoutDisplay:(vout_display_t *)vd;
 - (void)setVoutFlushing:(BOOL)flushing;
+- (void)reshapeOnScreenChange:(NSNotification *)notification;
 @end
 
-
 struct vout_display_sys_t
 {
     VLCOpenGLVideoView *glView;
@@ -136,127 +135,128 @@ static int Open (vlc_object_t *this)
     if (!sys)
         return VLC_ENOMEM;
 
-    @autoreleasepool {
-        if (!CGDisplayUsesOpenGLAcceleration (kCGDirectMainDisplay))
-            msg_Err (this, "no OpenGL hardware acceleration found. this can lead to slow output and unexpected results");
-
-        vd->sys = sys;
-        sys->pool = NULL;
-        sys->embed = NULL;
-        sys->vgl = NULL;
-        sys->gl = NULL;
-
-        var_Create(vd->obj.parent, "macosx-glcontext", VLC_VAR_ADDRESS);
-
-        /* Get the drawable object */
-        id container = var_CreateGetAddress (vd, "drawable-nsobject");
-        if (container)
-            vout_display_DeleteWindow (vd, NULL);
-        else {
-            sys->embed = vout_display_NewWindow (vd, VOUT_WINDOW_TYPE_NSOBJECT);
-            if (sys->embed)
-                container = sys->embed->handle.nsobject;
-
-            if (!container) {
-                msg_Err(vd, "No drawable-nsobject nor vout_window_t found, passing over.");
-                goto error;
-            }
-        }
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+    if (!CGDisplayUsesOpenGLAcceleration (kCGDirectMainDisplay))
+        msg_Err (this, "no OpenGL hardware acceleration found. this can lead to slow output and unexpected results");
 
-        /* This will be released in Close(), on
-         * main thread, after we are done using it. */
-        sys->container = [container retain];
+    vd->sys = sys;
+    sys->pool = NULL;
+    sys->embed = NULL;
+    sys->vgl = NULL;
+    sys->gl = NULL;
 
-        /* Get our main view*/
-        [VLCOpenGLVideoView performSelectorOnMainThread:@selector(getNewView:)
-                                             withObject:[NSValue valueWithPointer:&sys->glView]
-                                          waitUntilDone:YES];
-        if (!sys->glView) {
-            msg_Err(vd, "Initialization of open gl view failed");
-            goto error;
-        }
+    var_Create(vd->obj.parent, "macosx-glcontext", VLC_VAR_ADDRESS);
 
-        [sys->glView setVoutDisplay:vd];
-
-        /* We don't wait, that means that we'll have to be careful about releasing
-         * container.
-         * That's why we'll release on main thread in Close(). */
-        if ([(id)container respondsToSelector:@selector(addVoutSubview:)])
-            [(id)container performSelectorOnMainThread:@selector(addVoutSubview:)
-                                            withObject:sys->glView
-                                         waitUntilDone:NO];
-        else if ([container isKindOfClass:[NSView class]]) {
-            NSView *parentView = container;
-            [parentView performSelectorOnMainThread:@selector(addSubview:)
-                                         withObject:sys->glView
-                                      waitUntilDone:NO];
-            [sys->glView performSelectorOnMainThread:@selector(setFrameToBoundsOfView:)
-                                          withObject:[NSValue valueWithPointer:parentView]
-                                       waitUntilDone:NO];
-        } else {
-            msg_Err(vd, "Invalid drawable-nsobject object. drawable-nsobject must either be an NSView or comply to the @protocol VLCOpenGLVideoViewEmbedding.");
+    /* Get the drawable object */
+    id container = var_CreateGetAddress (vd, "drawable-nsobject");
+    if (container)
+        vout_display_DeleteWindow (vd, NULL);
+    else {
+        sys->embed = vout_display_NewWindow (vd, VOUT_WINDOW_TYPE_NSOBJECT);
+        if (sys->embed)
+            container = sys->embed->handle.nsobject;
+
+        if (!container) {
+            msg_Err(vd, "No drawable-nsobject nor vout_window_t found, passing over.");
+            [pool release];
             goto error;
         }
+    }
 
-        /* Initialize common OpenGL video display */
-        sys->gl = vlc_object_create(this, sizeof(*sys->gl));
+    /* This will be released in Close(), on main thread, after we are done using it. */
+    sys->container = [container retain];
 
-        if( unlikely( !sys->gl ) )
-            goto error;
+    /* Get our main view*/
+    NSValue *ptrVal = [NSValue valueWithPointer:&sys->glView];
+    [VLCOpenGLVideoView performSelectorOnMainThread:@selector(getNewView:) withObject:ptrVal waitUntilDone:YES];
+    if (!sys->glView) {
+        msg_Err(vd, "Initialization of open gl view failed");
+        [pool release];
+        goto error;
+    }
 
-        struct gl_sys *glsys = sys->gl->sys = malloc(sizeof(struct gl_sys));
-        if( unlikely( !sys->gl->sys ) )
-        {
-            vlc_object_release(sys->gl);
-            goto error;
-        }
-        glsys->locked_ctx = NULL;
-        glsys->glView = sys->glView;
-        sys->gl->makeCurrent = OpenglLock;
-        sys->gl->releaseCurrent = OpenglUnlock;
-        sys->gl->swap = OpenglSwap;
-        sys->gl->getProcAddress = OurGetProcAddress;
+    [sys->glView setVoutDisplay:vd];
+
+    /* We don't wait, that means that we'll have to be careful about releasing container.
+     * That's why we'll release on main thread in Close(). */
+    if ([(id)container respondsToSelector:@selector(addVoutSubview:)])
+        [(id)container performSelectorOnMainThread:@selector(addVoutSubview:)
+                                        withObject:sys->glView
+                                     waitUntilDone:NO];
+    else if ([container isKindOfClass:[NSView class]]) {
+        NSView *parentView = container;
+        [parentView performSelectorOnMainThread:@selector(addSubview:)
+                                     withObject:sys->glView
+                                  waitUntilDone:NO];
+        [sys->glView performSelectorOnMainThread:@selector(setFrameToBoundsOfView:)
+                                      withObject:[NSValue valueWithPointer:parentView]
+                                   waitUntilDone:NO];
+    } else {
+        msg_Err(vd, "Invalid drawable-nsobject object. drawable-nsobject must either be an NSView or comply to the @protocol VLCOpenGLVideoViewEmbedding.");
+        [pool release];
+        goto error;
+    }
 
-        var_SetAddress(vd->obj.parent, "macosx-glcontext",
-                       [[sys->glView openGLContext] CGLContextObj]);
+    /* Initialize common OpenGL video display */
+    sys->gl = vlc_object_create(this, sizeof(*sys->gl));
 
-        const vlc_fourcc_t *subpicture_chromas;
+    if( unlikely( !sys->gl ) ) {
+        [pool release];
+        goto error;
+    }
 
-        if (vlc_gl_MakeCurrent(sys->gl) != VLC_SUCCESS)
-        {
-            msg_Err(vd, "Can't attach gl context");
-            goto error;
-        }
-        sys->vgl = vout_display_opengl_New (&vd->fmt, &subpicture_chromas, sys->gl,
-                                            &vd->cfg->viewpoint);
-        vlc_gl_ReleaseCurrent(sys->gl);
-        if (!sys->vgl) {
-            msg_Err(vd, "Error while initializing opengl display.");
-            goto error;
-        }
+    struct gl_sys *glsys = sys->gl->sys = malloc(sizeof(struct gl_sys));
+    if( unlikely( !sys->gl->sys ) )
+    {
+        vlc_object_release(sys->gl);
+        [pool release];
+        goto error;
+    }
+    glsys->locked_ctx = NULL;
+    glsys->glView = sys->glView;
+    sys->gl->makeCurrent = OpenglLock;
+    sys->gl->releaseCurrent = OpenglUnlock;
+    sys->gl->swap = OpenglSwap;
+    sys->gl->getProcAddress = OurGetProcAddress;
 
-        /* */
-        vout_display_info_t info = vd->info;
-        info.has_pictures_invalid = false;
-        info.subpicture_chromas = subpicture_chromas;
+    var_SetAddress(vd->obj.parent, "macosx-glcontext",
+                   [[sys->glView openGLContext] CGLContextObj]);
 
-        /* Setup vout_display_t once everything is fine */
-        vd->info = info;
+    const vlc_fourcc_t *subpicture_chromas;
 
-        vd->pool = Pool;
-        vd->prepare = PictureRender;
-        vd->display = PictureDisplay;
-        vd->control = Control;
+    if (vlc_gl_MakeCurrent(sys->gl) != VLC_SUCCESS)
+    {
+        msg_Err(vd, "Can't attach gl context");
+        [pool release];
+        goto error;
+    }
+    sys->vgl = vout_display_opengl_New (&vd->fmt, &subpicture_chromas, sys->gl,
+                                        &vd->cfg->viewpoint);
+    vlc_gl_ReleaseCurrent(sys->gl);
+    if (!sys->vgl) {
+        msg_Err(vd, "Error while initializing opengl display.");
+        [pool release];
+        goto error;
+    }
 
-        /* */
-        vout_display_SendEventDisplaySize (vd, vd->fmt.i_visible_width, vd->fmt.i_visible_height);
+    vout_display_info_t info = vd->info;
+    info.has_pictures_invalid = false;
+    info.subpicture_chromas = subpicture_chromas;
+    vd->info = info;
 
-        return VLC_SUCCESS;
+    vd->pool = Pool;
+    vd->prepare = PictureRender;
+    vd->display = PictureDisplay;
+    vd->control = Control;
 
-    error:
-        Close(this);
-        return VLC_EGENERIC;
-    }
+    vout_display_SendEventDisplaySize (vd, vd->fmt.i_visible_width, vd->fmt.i_visible_height);
+
+    [pool release];
+    return VLC_SUCCESS;
+
+error:
+    Close(this);
+    return VLC_EGENERIC;
 }
 
 void Close (vlc_object_t *this)
@@ -264,45 +264,45 @@ void Close (vlc_object_t *this)
     vout_display_t *vd = (vout_display_t *)this;
     vout_display_sys_t *sys = vd->sys;
 
-    @autoreleasepool {
-        [sys->glView setVoutDisplay:nil];
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 
-        var_Destroy (vd, "drawable-nsobject");
-        if ([(id)sys->container respondsToSelector:@selector(removeVoutSubview:)])
-        /* This will retain sys->glView */
-            [(id)sys->container performSelectorOnMainThread:@selector(removeVoutSubview:)
-                                                 withObject:sys->glView
-                                              waitUntilDone:NO];
+    [sys->glView setVoutDisplay:nil];
 
-        /* release on main thread as explained in Open() */
-        [(id)sys->container performSelectorOnMainThread:@selector(release)
-                                             withObject:nil
+    var_Destroy (vd, "drawable-nsobject");
+    if ([(id)sys->container respondsToSelector:@selector(removeVoutSubview:)])
+        [(id)sys->container performSelectorOnMainThread:@selector(removeVoutSubview:)
+                                             withObject:sys->glView
                                           waitUntilDone:NO];
-        [sys->glView performSelectorOnMainThread:@selector(removeFromSuperview)
-                                      withObject:nil
-                                   waitUntilDone:NO];
-
-        var_Destroy(vd->obj.parent, "macosx-glcontext");
-        if (sys->vgl != NULL)
-        {
-            vlc_gl_MakeCurrent(sys->gl);
-            vout_display_opengl_Delete (sys->vgl);
-            vlc_gl_ReleaseCurrent(sys->gl);
-        }
 
-        if (sys->gl != NULL)
-        {
-            assert(((struct gl_sys *)sys->gl->sys)->locked_ctx == NULL);
-            free(sys->gl->sys);
-            vlc_object_release(sys->gl);
-        }
+    [(id)sys->container performSelectorOnMainThread:@selector(release)
+                                         withObject:nil
+                                      waitUntilDone:NO];
+    [sys->glView performSelectorOnMainThread:@selector(removeFromSuperview)
+                                  withObject:nil
+                               waitUntilDone:NO];
 
-        [sys->glView release];
+    var_Destroy(vd->obj.parent, "macosx-glcontext");
+    if (sys->vgl != NULL)
+    {
+        vlc_gl_MakeCurrent(sys->gl);
+        vout_display_opengl_Delete (sys->vgl);
+        vlc_gl_ReleaseCurrent(sys->gl);
+    }
 
-        if (sys->embed)
-            vout_display_DeleteWindow (vd, sys->embed);
-        free (sys);
+    if (sys->gl != NULL)
+    {
+        assert(((struct gl_sys *)sys->gl->sys)->locked_ctx == NULL);
+        free(sys->gl->sys);
+        vlc_object_release(sys->gl);
     }
+
+    [sys->glView release];
+
+    if (sys->embed)
+        vout_display_DeleteWindow (vd, sys->embed);
+    free (sys);
+
+    [pool release];
 }
 
 /*****************************************************************************
@@ -323,7 +323,6 @@ static picture_pool_t *Pool (vout_display_t *vd, unsigned requested_count)
 
 static void PictureRender (vout_display_t *vd, picture_t *pic, subpicture_t *subpicture)
 {
-
     vout_display_sys_t *sys = vd->sys;
 
     if (vlc_gl_MakeCurrent(sys->gl) == VLC_SUCCESS)
@@ -339,14 +338,6 @@ static void PictureDisplay (vout_display_t *vd, picture_t *pic, subpicture_t *su
     [sys->glView setVoutFlushing:YES];
     if (vlc_gl_MakeCurrent(sys->gl) == VLC_SUCCESS)
     {
-        if (@available(macOS 10.14, *)) {
-            vout_display_place_t place;
-            vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);
-            vout_display_opengl_Viewport(vd->sys->vgl, place.x,
-                                         vd->cfg->display.height - (place.y + place.height),
-                                         place.width, place.height);
-        }
-
         vout_display_opengl_Display (sys->vgl, &vd->source);
         vlc_gl_ReleaseCurrent(sys->gl);
     }
@@ -365,66 +356,67 @@ static int Control (vout_display_t *vd, int query, va_list ap)
     if (!vd->sys)
         return VLC_EGENERIC;
 
-    @autoreleasepool {
-        switch (query)
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+
+    switch (query)
+    {
+        case VOUT_DISPLAY_CHANGE_DISPLAY_FILLED:
+        case VOUT_DISPLAY_CHANGE_ZOOM:
+        case VOUT_DISPLAY_CHANGE_SOURCE_ASPECT:
+        case VOUT_DISPLAY_CHANGE_SOURCE_CROP:
+        case VOUT_DISPLAY_CHANGE_DISPLAY_SIZE:
         {
-            case VOUT_DISPLAY_CHANGE_DISPLAY_FILLED:
-            case VOUT_DISPLAY_CHANGE_ZOOM:
-            case VOUT_DISPLAY_CHANGE_SOURCE_ASPECT:
-            case VOUT_DISPLAY_CHANGE_SOURCE_CROP:
-            case VOUT_DISPLAY_CHANGE_DISPLAY_SIZE:
-            {
-                const vout_display_cfg_t *cfg;
-
-                if (query == VOUT_DISPLAY_CHANGE_SOURCE_ASPECT || query == VOUT_DISPLAY_CHANGE_SOURCE_CROP) {
-                    cfg = vd->cfg;
-                } else {
-                    cfg = (const vout_display_cfg_t*)va_arg (ap, const vout_display_cfg_t *);
-                }
-
-                /* we always use our current frame here, because we have some size constraints
-                 in the ui vout provider */
-                vout_display_cfg_t cfg_tmp = *cfg;
-
-                /* Reverse vertical alignment as the GL tex are Y inverted */
-                if (cfg_tmp.align.vertical == VOUT_DISPLAY_ALIGN_TOP)
-                    cfg_tmp.align.vertical = VOUT_DISPLAY_ALIGN_BOTTOM;
-                else if (cfg_tmp.align.vertical == VOUT_DISPLAY_ALIGN_BOTTOM)
-                    cfg_tmp.align.vertical = VOUT_DISPLAY_ALIGN_TOP;
-
-                vout_display_place_t place;
-                vout_display_PlacePicture (&place, &vd->source, &cfg_tmp, false);
-                @synchronized (sys->glView) {
-                    sys->place = place;
-                }
-
-                if (vlc_gl_MakeCurrent (sys->gl) != VLC_SUCCESS)
-                    return VLC_EGENERIC;
-                vout_display_opengl_SetWindowAspectRatio(sys->vgl, (float)place.width / place.height);
-
-                /* For resize, we call glViewport in reshape and not here.
-                 This has the positive side effect that we avoid erratic sizing as we animate every resize. */
-                if (query != VOUT_DISPLAY_CHANGE_DISPLAY_SIZE)
-                    // x / y are top left corner, but we need the lower left one
-                    vout_display_opengl_Viewport(sys->vgl, place.x,
-                                                 cfg_tmp.display.height - (place.y + place.height),
-                                                 place.width, place.height);
-                vlc_gl_ReleaseCurrent (sys->gl);
-
-                return VLC_SUCCESS;
+            const vout_display_cfg_t *cfg;
+
+            if (query == VOUT_DISPLAY_CHANGE_SOURCE_ASPECT || query == VOUT_DISPLAY_CHANGE_SOURCE_CROP) {
+                cfg = vd->cfg;
+            } else {
+                cfg = (const vout_display_cfg_t*)va_arg (ap, const vout_display_cfg_t *);
             }
 
-            case VOUT_DISPLAY_CHANGE_VIEWPOINT:
-                return vout_display_opengl_SetViewpoint (sys->vgl,
-                    &va_arg (ap, const vout_display_cfg_t* )->viewpoint);
+            vout_display_cfg_t cfg_tmp = *cfg;
 
-            case VOUT_DISPLAY_RESET_PICTURES:
-                vlc_assert_unreachable ();
-            default:
-                msg_Err (vd, "Unknown request in Mac OS X vout display");
+            /* Reverse vertical alignment as the GL tex are Y inverted */
+            if (cfg_tmp.align.vertical == VOUT_DISPLAY_ALIGN_TOP)
+                cfg_tmp.align.vertical = VOUT_DISPLAY_ALIGN_BOTTOM;
+            else if (cfg_tmp.align.vertical == VOUT_DISPLAY_ALIGN_BOTTOM)
+                cfg_tmp.align.vertical = VOUT_DISPLAY_ALIGN_TOP;
+
+            vout_display_place_t place;
+            vout_display_PlacePicture (&place, &vd->source, &cfg_tmp, false);
+            @synchronized (sys->glView) {
+                sys->place = place;
+            }
+
+            if (vlc_gl_MakeCurrent (sys->gl) != VLC_SUCCESS) {
+                [pool release];
                 return VLC_EGENERIC;
+            }
+            vout_display_opengl_SetWindowAspectRatio(sys->vgl, (float)place.width / place.height);
+
+            if (query != VOUT_DISPLAY_CHANGE_DISPLAY_SIZE)
+                vout_display_opengl_Viewport(sys->vgl, place.x,
+                                             cfg_tmp.display.height - (place.y + place.height),
+                                             place.width, place.height);
+            vlc_gl_ReleaseCurrent (sys->gl);
+
+            [pool release];
+            return VLC_SUCCESS;
         }
+
+        case VOUT_DISPLAY_CHANGE_VIEWPOINT:
+            [pool release];
+            return vout_display_opengl_SetViewpoint (sys->vgl,
+                &va_arg (ap, const vout_display_cfg_t* )->viewpoint);
+
+        case VOUT_DISPLAY_RESET_PICTURES:
+            vlc_assert_unreachable ();
+        default:
+            msg_Err (vd, "Unknown request in Mac OS X vout display");
+            [pool release];
+            return VLC_EGENERIC;
     }
+    [pool release];
 }
 
 /*****************************************************************************
@@ -470,6 +462,7 @@ static void OpenglSwap (vlc_gl_t *gl)
 
 #define VLCAssertMainThread() assert([[NSThread currentThread] isMainThread])
 
+static NSString *VLCGLScreenChangeNotification = @"NSApplicationDidChangeScreenParametersNotification";
 
 + (void)getNewView:(NSValue *)value
 {
@@ -477,15 +470,10 @@ static void OpenglSwap (vlc_gl_t *gl)
     *ret = [[self alloc] init];
 }
 
-/**
- * Gets called by the Open() method.
- */
 - (id)init
 {
     VLCAssertMainThread();
 
-    /* Warning - this may be called on non main thread */
-
     NSOpenGLPixelFormatAttribute attribs[] =
     {
         NSOpenGLPFADoubleBuffer,
@@ -495,7 +483,6 @@ static void OpenglSwap (vlc_gl_t *gl)
         NSOpenGLPFAAlphaSize, 8,
         NSOpenGLPFADepthSize, 24,
         NSOpenGLPFAWindow,
-        NSOpenGLPFAAllowOfflineRenderers,
         0
     };
 
@@ -510,33 +497,13 @@ static void OpenglSwap (vlc_gl_t *gl)
     if (!self)
         return nil;
 
-    /* enable HiDPI support */
-    [self setWantsBestResolutionOpenGLSurface:YES];
+    [self setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
 
-    /* request our screen's HDR mode (introduced in OS X 10.11) */
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wpartial-availability"
-    if ([self respondsToSelector:@selector(setWantsExtendedDynamicRangeOpenGLSurface:)]) {
-        [self setWantsExtendedDynamicRangeOpenGLSurface:YES];
-    }
-#pragma clang diagnostic pop
-
-    /* Swap buffers only during the vertical retrace of the monitor.
-     http://developer.apple.com/documentation/GraphicsImaging/
-     Conceptual/OpenGL/chap5/chapter_5_section_44.html */
-    GLint params[] = { 1 };
-    CGLSetParameter ([[self openGLContext] CGLContextObj], kCGLCPSwapInterval, params);
-
-    [[NSNotificationCenter defaultCenter] addObserverForName:NSApplicationDidChangeScreenParametersNotification
-                                                      object:[NSApplication sharedApplication]
-                                                       queue:nil
-                                                  usingBlock:^(NSNotification *notification) {
-                                                      [self performSelectorOnMainThread:@selector(reshape)
-                                                                             withObject:nil
-                                                                          waitUntilDone:NO];
-                                                  }];
+    [[NSNotificationCenter defaultCenter] addObserver:self
+                                             selector:@selector(reshapeOnScreenChange:)
+                                                 name:(NSString *)VLCGLScreenChangeNotification
+                                               object:[NSApplication sharedApplication]];
 
-    [self setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
     return self;
 }
 
@@ -546,19 +513,19 @@ static void OpenglSwap (vlc_gl_t *gl)
     [super dealloc];
 }
 
-/**
- * Gets called by the Open() method.
- */
+- (void)reshapeOnScreenChange:(NSNotification *)notification
+{
+    [self performSelectorOnMainThread:@selector(reshape)
+                           withObject:nil
+                        waitUntilDone:NO];
+}
+
 - (void)setFrameToBoundsOfView:(NSValue *)value
 {
     NSView *parentView = [value pointerValue];
     [self setFrame:[parentView bounds]];
 }
 
-/**
- * Gets called by the Close and Open methods.
- * (Non main thread).
- */
 - (void)setVoutDisplay:(vout_display_t *)aVd
 {
     @synchronized(self) {
@@ -566,10 +533,6 @@ static void OpenglSwap (vlc_gl_t *gl)
     }
 }
 
-/**
- * Gets called when the vout will acquire the lock and flush.
- * (Non main thread).
- */
 - (void)setVoutFlushing:(BOOL)flushing
 {
     if (!flushing)
@@ -579,9 +542,6 @@ static void OpenglSwap (vlc_gl_t *gl)
     }
 }
 
-/**
- * Can -drawRect skip rendering?.
- */
 - (BOOL)canSkipRendering
 {
     VLCAssertMainThread();
@@ -592,10 +552,6 @@ static void OpenglSwap (vlc_gl_t *gl)
     }
 }
 
-
-/**
- * Local method that locks the gl context.
- */
 - (BOOL)lockgl
 {
     VLCAssertMainThread();
@@ -606,49 +562,35 @@ static void OpenglSwap (vlc_gl_t *gl)
     return err == kCGLNoError;
 }
 
-/**
- * Local method that unlocks the gl context.
- */
 - (void)unlockgl
 {
     VLCAssertMainThread();
     CGLUnlockContext ([[self openGLContext] CGLContextObj]);
 }
 
-/**
- * Local method that force a rendering of a frame.
- * This will get called if Cocoa forces us to redraw (via -drawRect).
- */
 - (void)render
 {
     VLCAssertMainThread();
 
-    // We may have taken some times to take the opengl Lock.
-    // Check here to see if we can just skip the frame as well.
     if ([self canSkipRendering])
         return;
 
     BOOL hasFirstFrame;
-    @synchronized(self) { // vd can be accessed from multiple threads
+    @synchronized(self) {
         hasFirstFrame = vd && vd->sys->has_first_frame;
     }
 
     if (hasFirstFrame)
-        // This will lock gl.
         vout_display_opengl_Display (vd->sys->vgl, &vd->source);
     else
         glClear (GL_COLOR_BUFFER_BIT);
 }
 
-/**
- * Method called by Cocoa when the view is resized.
- */
 - (void)reshape
 {
     VLCAssertMainThread();
 
-    /* on HiDPI displays, the point bounds don't equal the actual pixel based bounds */
-    NSRect bounds = [self convertRectToBacking:[self bounds]];
+    NSRect bounds = [self bounds];
     vout_display_place_t place;
 
     @synchronized(self) {
@@ -664,14 +606,9 @@ static void OpenglSwap (vlc_gl_t *gl)
     }
 
     if ([self lockgl]) {
-        // x / y are top left corner, but we need the lower left one
         glViewport (place.x, bounds.size.height - (place.y + place.height), place.width, place.height);
 
         @synchronized(self) {
-            // This may be cleared before -drawRect is being called,
-            // in this case we'll skip the rendering.
-            // This will save us for rendering two frames (or more) for nothing
-            // (one by the vout, one (or more) by drawRect)
             _hasPendingReshape = YES;
         }
 
@@ -681,10 +618,6 @@ static void OpenglSwap (vlc_gl_t *gl)
     }
 }
 
-/**
- * Method called by Cocoa when the view is resized or the location has changed.
- * We just need to make sure we are locking here.
- */
 - (void)update
 {
     VLCAssertMainThread();
@@ -697,9 +630,6 @@ static void OpenglSwap (vlc_gl_t *gl)
     [self unlockgl];
 }
 
-/**
- * Method called by Cocoa to force redraw.
- */
 - (void)drawRect:(NSRect) rect
 {
     VLCAssertMainThread();
@@ -718,19 +648,7 @@ static void OpenglSwap (vlc_gl_t *gl)
 
 - (void)renewGState
 {
-    // Comment take from Apple GLEssentials sample code:
-    // https://developer.apple.com/library/content/samplecode/GLEssentials
-    //
-    // OpenGL rendering is not synchronous with other rendering on the OSX.
-    // Therefore, call disableScreenUpdatesUntilFlush so the window server
-    // doesn't render non-OpenGL content in the window asynchronously from
-    // OpenGL content, which could cause flickering.  (non-OpenGL content
-    // includes the title bar and drawing done by the app with other APIs)
-
-    // In macOS 10.13 and later, window updates are automatically batched
-    // together and this no longer needs to be called (effectively a no-op)
     [[self window] disableScreenUpdatesUntilFlush];
-
     [super renewGState];
 }
 
@@ -790,14 +708,10 @@ static void OpenglSwap (vlc_gl_t *gl)
 
 - (void)mouseMoved:(NSEvent *)o_event
 {
-    /* on HiDPI displays, the point bounds don't equal the actual pixel based bounds */
     NSPoint ml = [self convertPoint: [o_event locationInWindow] fromView: nil];
     NSRect videoRect = [self bounds];
     BOOL b_inside = [self mouse: ml inRect: videoRect];
 
-    ml = [self convertPointToBacking: ml];
-    videoRect = [self convertRectToBacking: videoRect];
-
     if (b_inside) {
         @synchronized (self) {
             if (vd) {
-- 
2.51.0

