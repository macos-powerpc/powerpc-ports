--- meson.build	2025-03-26 01:33:27.000000000 +0800
+++ meson.build	2025-05-12 04:15:46.000000000 +0800
@@ -1108,12 +1108,12 @@
 features += {'gl': false}
 
 GL = dependency('', required: false)
-if darwin
+if features['x11']
+    GL = dependency('GL', required: get_option('gl-x11'))
+elif darwin
     GL = dependency('appleframeworks', modules: 'OpenGL', required: get_option('gl-cocoa'))
 elif features['win32-desktop']
     GL = dependency('GL', required: get_option('gl-win32'))
-elif features['x11']
-    GL = dependency('GL', required: get_option('gl-x11'))
 endif
 
 gl_cocoa = get_option('gl-cocoa').require(


From bc6a99a1a486337bfcdc3aaaa63bbaea9a99652e Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Sun, 5 Oct 2025 16:26:33 +0800
Subject: [PATCH] context_glx.c: fix create_context_x11

Reverts breakage from https://github.com/mpv-player/mpv/commit/e869d519baf4b71b33e522f97b4638979fe0d4db
---
 video/out/opengl/context_glx.c | 82 +++++++++++++++++++++++-----------
 1 file changed, 57 insertions(+), 25 deletions(-)

diff --git a/video/out/opengl/context_glx.c b/video/out/opengl/context_glx.c
index 3022b478cfe11..1601152b09904 100644
--- video/out/opengl/context_glx.c
+++ video/out/opengl/context_glx.c
@@ -66,6 +66,41 @@ static void glx_uninit(struct ra_ctx *ctx)
     vo_x11_uninit(ctx->vo);
 }
 
+static bool create_context_x11_old(struct ra_ctx *ctx, GL *gl)
+{
+    struct priv *p = ctx->priv;
+    Display *display = ctx->vo->x11->display;
+    struct vo *vo = ctx->vo;
+
+    if (p->context)
+        return true;
+
+    if (!p->vinfo) {
+        MP_ERR(vo, "Can't create a legacy GLX context without X visual\n");
+        return false;
+    }
+
+    GLXContext new_context = glXCreateContext(display, p->vinfo, NULL, True);
+    if (!new_context) {
+        MP_ERR(vo, "Could not create GLX context!\n");
+        return false;
+    }
+
+    if (!glXMakeCurrent(display, ctx->vo->x11->window, new_context)) {
+        MP_ERR(vo, "Could not set GLX context!\n");
+        glXDestroyContext(display, new_context);
+        return false;
+    }
+
+    const char *glxstr = glXQueryExtensionsString(display, ctx->vo->x11->screen);
+
+    mpgl_load_functions(gl, (void *)glXGetProcAddressARB, glxstr, vo->log);
+
+    p->context = new_context;
+
+    return true;
+}
+
 typedef GLXContext (*glXCreateContextAttribsARBProc)
     (Display*, GLXFBConfig, GLXContext, Bool, const int*);
 
@@ -80,14 +115,9 @@ static bool create_context_x11(struct ra_ctx *ctx, GL *gl, bool es)
 
     const char *glxstr =
         glXQueryExtensionsString(vo->x11->display, vo->x11->screen);
-    if (!glxstr) {
-        MP_ERR(ctx, "GLX did not advertise any extensions\n");
-        return false;
-    }
+    bool have_ctx_ext = glxstr && !!strstr(glxstr, "GLX_ARB_create_context");
 
-    if (!gl_check_extension(glxstr, "GLX_ARB_create_context_profile") ||
-        !glXCreateContextAttribsARB) {
-        MP_ERR(ctx, "GLX does not support GLX_ARB_create_context_profile\n");
+    if (!(have_ctx_ext && glXCreateContextAttribsARB)) {
         return false;
     }
 
@@ -96,7 +126,7 @@ static bool create_context_x11(struct ra_ctx *ctx, GL *gl, bool es)
 
     if (es) {
         profile_mask = GLX_CONTEXT_ES2_PROFILE_BIT_EXT;
-        if (!gl_check_extension(glxstr, "GLX_EXT_create_context_es2_profile"))
+        if (!(glxstr && strstr(glxstr, "GLX_EXT_create_context_es2_profile")))
             return false;
     }
 
@@ -281,8 +310,20 @@ static bool glx_init(struct ra_ctx *ctx)
     bool success = false;
     enum gles_mode mode = ra_gl_ctx_get_glesmode(ctx);
 
-    if (mode == GLES_NO || mode == GLES_AUTO)
-        success = create_context_x11(ctx, gl, false);
+    if (mode == GLES_NO || mode == GLES_AUTO) {
+        for (int n = 0; mpgl_min_required_gl_versions[n]; n++) {
+            int version = mpgl_min_required_gl_versions[n];
+            MP_VERBOSE(ctx, "Creating OpenGL %d.%d context...\n",
+                       MPGL_VER_P(version));
+            if (version >= 300) {
+                success = create_context_x11(ctx, gl, false);
+            } else {
+                success = create_context_x11_old(ctx, gl);
+            }
+            if (success)
+                break;
+        }
+    }
     if (!success && (mode == GLES_YES || mode == GLES_AUTO))
         success = create_context_x11(ctx, gl, true);
     if (success && !glXIsDirect(vo->x11->display, p->context))
@@ -308,7 +349,6 @@ static bool glx_init(struct ra_ctx *ctx)
     return false;
 }
 
-
 static void resize(struct ra_ctx *ctx)
 {
     ra_gl_ctx_resize(ctx->swapchain, ctx->vo->dwidth, ctx->vo->dheight, 0);
