From 785e7217b62101fa06a5808eac8c796ec3ce1ebb Mon Sep 17 00:00:00 2001
From: Aggelos Tselios <aggelostselios777@gmail.com>
Date: Tue, 23 Dec 2025 11:05:20 +0200
Subject: [PATCH 1/7] hw: xquartz: remove apple block extension code

Apple blocks are an extension specific to some very old GCC versions and
clang. Replace them by writing proper functions and using function
pointers in their place.

Signed-off-by: Aggelos Tselios <aggelostselios777@gmail.com>
---
 hw/xquartz/mach-startup/bundle-main.c | 13 +++--
 hw/xquartz/quartzKeyboard.c           | 52 +++++++++--------
 hw/xquartz/xpr/xprEvent.c             | 13 ++++-
 hw/xquartz/xpr/xprFrame.c             | 84 +++++++++++++++++++++------
 4 files changed, 113 insertions(+), 49 deletions(-)

diff --git a/hw/xquartz/mach-startup/bundle-main.c b/hw/xquartz/mach-startup/bundle-main.c
index bac44c656..e52dceda8 100644
--- a/hw/xquartz/mach-startup/bundle-main.c
+++ b/hw/xquartz/mach-startup/bundle-main.c
@@ -318,6 +318,12 @@ create_socket(char *filename_out)
 
 static int launchd_socket_handed_off = 0;
 
+static void socketHandoff_fptr(void *arg) {
+    socket_handoff_t *handoff_data = (socket_handoff_t *)arg;
+    socket_handoff(handoff_data);
+    free(handoff_data);
+}
+
 kern_return_t
 do_request_fd_handoff_socket(mach_port_t port, string_t filename)
 {
@@ -337,10 +343,9 @@ do_request_fd_handoff_socket(mach_port_t port, string_t filename)
 
     strlcpy(filename, handoff_data->filename, STRING_T_SIZE);
 
-    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,
-                                             0), ^ {
-                       socket_handoff(handoff_data);
-                   });
+    dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
+                     handoff_data,
+                     socketHandoff_fptr);
 
 #ifdef DEBUG
     ErrorF(
diff --git a/hw/xquartz/quartzKeyboard.c b/hw/xquartz/quartzKeyboard.c
index a26ea19c5..715372f46 100644
--- a/hw/xquartz/quartzKeyboard.c
+++ b/hw/xquartz/quartzKeyboard.c
@@ -194,6 +194,11 @@ typedef struct darwinKeyboardInfo_struct {
     unsigned char modifierKeycodes[32][2];
 } darwinKeyboardInfo;
 
+typedef struct _KeyboardDataContext {
+    UInt32 kbd_type;
+    const void *chr_data;
+} KeyboardDataContext;
+
 darwinKeyboardInfo keyInfo;
 pthread_mutex_t keyInfo_mutex = PTHREAD_MUTEX_INITIALIZER;
 
@@ -742,39 +747,38 @@ make_dead_key(KeySym in)
     return in;
 }
 
+static void getKeyboardData(void *keyboard_ctx) {
+    KeyboardDataContext *ctx = keyboard_ctx;
+    ctx->kbd_type = LMGetKbdType();
+    TISInputSourceRef currentKeyLayoutRef = TISCopyCurrentKeyboardLayoutInputSource();
+
+    if (currentKeyLayoutRef) {
+        CFDataRef currentKeyLayoutDataRef = (CFDataRef)TISGetInputSourceProperty(currentKeyLayoutRef,
+                                                                                 kTISPropertyUnicodeKeyLayoutData);
+        if (currentKeyLayoutDataRef)
+            ctx->chr_data = CFDataGetBytePtr(currentKeyLayoutDataRef);
+
+        CFRelease(currentKeyLayoutRef);
+    }
+}
+
 static Bool
 QuartzReadSystemKeymap(darwinKeyboardInfo *info)
 {
-    __block const void *chr_data = NULL;
     int num_keycodes = NUM_KEYCODES;
-    __block UInt32 keyboard_type;
+    KeyboardDataContext ctx = { 0 };
     int i, j;
     OSStatus err;
     KeySym *k;
 
-    dispatch_block_t getKeyboardData = ^{
-        keyboard_type = LMGetKbdType();
-
-        TISInputSourceRef currentKeyLayoutRef = TISCopyCurrentKeyboardLayoutInputSource();
-
-        if (currentKeyLayoutRef) {
-            CFDataRef currentKeyLayoutDataRef = (CFDataRef)TISGetInputSourceProperty(currentKeyLayoutRef,
-                                                                                     kTISPropertyUnicodeKeyLayoutData);
-            if (currentKeyLayoutDataRef)
-                chr_data = CFDataGetBytePtr(currentKeyLayoutDataRef);
-
-            CFRelease(currentKeyLayoutRef);
-        }
-    };
-
     /* This is an ugly ant-pattern, but it is more expedient to address the problem right now. */
     if (pthread_main_np()) {
-        getKeyboardData();
+        getKeyboardData(&ctx);
     } else {
-        dispatch_sync(dispatch_get_main_queue(), getKeyboardData);
+        dispatch_sync_f(dispatch_get_main_queue(), &ctx, getKeyboardData);
     }
 
-    if (chr_data == NULL) {
+    if (ctx.chr_data == NULL) {
         ErrorF("Couldn't get uchr or kchr resource\n");
         return FALSE;
     }
@@ -800,16 +804,16 @@ QuartzReadSystemKeymap(darwinKeyboardInfo *info)
             UniCharCount len;
             UInt32 dead_key_state = 0, extra_dead = 0;
 
-            err = UCKeyTranslate(chr_data, i, kUCKeyActionDown,
-                                 mods[j] >> 8, keyboard_type, 0,
+            err = UCKeyTranslate(ctx.chr_data, i, kUCKeyActionDown,
+                                 mods[j] >> 8, ctx.kbd_type, 0,
                                  &dead_key_state, 8, &len, s);
             if (err != noErr) continue;
 
             if (len == 0 && dead_key_state != 0) {
                 /* Found a dead key. Work out which one it is, but
                    remembering that it's dead. */
-                err = UCKeyTranslate(chr_data, i, kUCKeyActionDown,
-                                     mods[j] >> 8, keyboard_type,
+                err = UCKeyTranslate(ctx.chr_data, i, kUCKeyActionDown,
+                                     mods[j] >> 8, ctx.kbd_type,
                                      kUCKeyTranslateNoDeadKeysMask,
                                      &extra_dead, 8, &len, s);
                 if (err != noErr) continue;
diff --git a/hw/xquartz/xpr/xprEvent.c b/hw/xquartz/xpr/xprEvent.c
index 7490da649..9fe33c6c5 100644
--- a/hw/xquartz/xpr/xprEvent.c
+++ b/hw/xquartz/xpr/xprEvent.c
@@ -55,6 +55,13 @@
 #include "rootlessWindow.h"
 #include "xprEvent.h"
 
+static void
+bringAllToFront(void *unused)
+{
+    (void) unused; /* to silence the compiler warning */
+    xp_window_bring_all_to_front();
+}
+
 Bool
 QuartzModeEventHandler(int screenNum, XQuartzEvent *e, DeviceIntPtr dev)
 {
@@ -72,9 +79,9 @@ QuartzModeEventHandler(int screenNum, XQuartzEvent *e, DeviceIntPtr dev)
 
     case kXquartzBringAllToFront:
         DEBUG_LOG("kXquartzBringAllToFront\n");
-        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-            xp_window_bring_all_to_front();
-        });
+        dispatch_async_f(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
+                 NULL,
+                 bringAllToFront);
 
         return TRUE;
 
diff --git a/hw/xquartz/xpr/xprFrame.c b/hw/xquartz/xpr/xprFrame.c
index c2f33a2ff..73fa7fa06 100644
--- a/hw/xquartz/xpr/xprFrame.c
+++ b/hw/xquartz/xpr/xprFrame.c
@@ -60,6 +60,11 @@
 
 DEFINE_ATOM_HELPER(xa_native_window_id, "_NATIVE_WINDOW_ID")
 
+typedef struct _WindowHashInsertCtx {
+    xp_window_id wid;
+    RootlessWindowPtr frame;
+} WindowHashInsertCtx;
+
 /* Maps xp_window_id -> RootlessWindowRec */
 static x_hash_table * window_hash;
 
@@ -142,6 +147,14 @@ xprColormapCallback(void *data, int first_color, int n_colors,
                                     colors) ? XP_Success : XP_BadMatch);
 }
 
+static void
+windowHashInsert(void *arg)
+{
+    WindowHashInsertCtx *ctx = arg;
+    x_hash_table_insert(window_hash, x_cvt_uint_to_vptr(ctx->wid), ctx->frame);
+    free(ctx);
+}
+
 /*
  * Create and display a new frame.
  */
@@ -199,28 +212,55 @@ xprCreateFrame(RootlessWindowPtr pFrame, ScreenPtr pScreen,
         return FALSE;
     }
 
-    dispatch_async(window_hash_serial_q, ^ {
-                       x_hash_table_insert(window_hash, pFrame->wid, pFrame);
-                   });
+    WindowHashInsertCtx *ctx = malloc(sizeof(WindowHashInsertCtx));
+    if (!ctx) return FALSE;
+
+    ctx->wid = x_cvt_vptr_to_uint(pFrame->wid);
+    ctx->frame = pFrame;
 
+    dispatch_async_f(window_hash_serial_q, ctx, windowHashInsert);
     xprSetNativeProperty(pFrame);
 
     return TRUE;
 }
 
+/* For heap allocation */
+typedef struct _WindowHashRemoveCtx {
+    RootlessFrameID wid;
+} WindowHashRemoveCtx;
+
+typedef struct _WindowLookupCtx {
+    RootlessFrameID wid;
+    RootlessWindowRec **winrec;
+} WindowLookupCtx;
+
+/* the members are gonna be the same, so no reason to duplicate code */
+typedef WindowLookupCtx WindowGetCtx;
+
+static void windowHashRemove(void *arg) {
+    WindowHashRemoveCtx *ctx = arg;
+    x_hash_table_remove(window_hash, ctx->wid);
+    free(ctx);
+}
+
+static void windowLookup(void *arg) {
+    WindowLookupCtx *ctx = (WindowLookupCtx *)arg;
+    *(ctx->winrec) = x_hash_table_lookup(window_hash, ctx->wid, NULL);
+}
+
 /*
  * Destroy a frame.
  */
 static void
 xprDestroyFrame(RootlessFrameID wid)
 {
-    xp_error err;
+    WindowHashRemoveCtx *ctx = malloc(sizeof(WindowHashRemoveCtx));
+    if (!ctx) FatalError("Could not allocate memory for the hash removal context.");
 
-    dispatch_async(window_hash_serial_q, ^ {
-                       x_hash_table_remove(window_hash, wid);
-                   });
+    ctx->wid = wid;
+    dispatch_async_f(window_hash_serial_q, ctx, windowHashRemove);
 
-    err = xp_destroy_window(x_cvt_vptr_to_uint(wid));
+    xp_error err = xp_destroy_window(x_cvt_vptr_to_uint(wid));
     if (err != Success)
         FatalError("Could not destroy window %d (%d).",
                    (int)x_cvt_vptr_to_uint(
@@ -271,9 +311,13 @@ xprRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid)
 {
     xp_window_changes wc;
     unsigned int mask = XP_STACKING;
-    __block
     RootlessWindowRec * winRec;
 
+    WindowLookupCtx ctx = {
+        .wid = wid,
+        .winrec = &winRec
+    };
+
     /* Stack frame below nextWid it if it exists, or raise
        frame above everything otherwise. */
 
@@ -286,9 +330,7 @@ xprRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid)
         wc.sibling = x_cvt_vptr_to_uint(nextWid);
     }
 
-    dispatch_sync(window_hash_serial_q, ^ {
-                      winRec = x_hash_table_lookup(window_hash, wid, NULL);
-                  });
+    dispatch_sync_f(window_hash_serial_q, &ctx, windowLookup);
 
     if (winRec) {
         if (XQuartzIsRootless)
@@ -486,6 +528,11 @@ xprInit(ScreenPtr pScreen)
     return TRUE;
 }
 
+static void windowGet(void *arg) {
+    WindowGetCtx *ctx = arg;
+    *(ctx->winrec) = x_hash_table_lookup(window_hash, ctx->wid, NULL);
+}
+
 /*
  * Given the id of a physical window, try to find the top-level (or root)
  * X window that it represents.
@@ -493,12 +540,13 @@ xprInit(ScreenPtr pScreen)
 WindowPtr
 xprGetXWindow(xp_window_id wid)
 {
-    RootlessWindowRec *winRec __block;
-    dispatch_sync(window_hash_serial_q, ^ {
-                      winRec =
-                          x_hash_table_lookup(window_hash,
-                                              x_cvt_uint_to_vptr(wid), NULL);
-                  });
+    RootlessWindowRec *winRec;
+    WindowGetCtx ctx = {
+        .wid = x_cvt_uint_to_vptr(wid),
+        .winrec = &winRec
+    };
+
+    dispatch_sync_f(window_hash_serial_q, &ctx, windowGet);
 
     return winRec != NULL ? winRec->win : NULL;
 }
-- 
2.52.0

