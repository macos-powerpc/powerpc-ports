--- gdk/gdkglcontext.c.orig	2025-09-30 18:19:25.000000000 +0800
+++ gdk/gdkglcontext.c	2025-10-26 00:25:19.000000000 +0800
@@ -104,6 +104,7 @@
 
 const GdkDebugKey gdk_gl_feature_keys[] = {
   { "debug", GDK_GL_FEATURE_DEBUG, "GL_KHR_debug" },
+  { "sync", GDK_GL_FEATURE_SYNC, "GL_ARB_sync" },
   { "base-instance", GDK_GL_FEATURE_BASE_INSTANCE, "GL_ARB_base_instance" },
   { "buffer-storage", GDK_GL_FEATURE_BUFFER_STORAGE, "GL_EXT_buffer_storage" },
   { "external-objects", GDK_GL_FEATURE_EXTERNAL_OBJECTS, "GL_EXT_memory_object and GL_EXT_semaphore"},
@@ -1795,6 +1796,11 @@
   if (epoxy_has_gl_extension ("GL_KHR_debug"))
     features |= GDK_GL_FEATURE_DEBUG;
 
+  if (gdk_gl_context_check_version (context, "3.2", "3.0") ||
+      epoxy_has_gl_extension ("GL_ARB_sync") ||
+      epoxy_has_gl_extension ("GL_APPLE_sync"))
+    features |= GDK_GL_FEATURE_SYNC;
+
   if (gdk_gl_context_check_version (context, "4.2", "9.9") ||
       epoxy_has_gl_extension ("GL_EXT_base_instance") ||
       epoxy_has_gl_extension ("GL_ARB_base_instance"))

--- gdk/gdkglcontextprivate.h.orig	2025-09-30 18:19:25.000000000 +0800
+++ gdk/gdkglcontextprivate.h	2025-10-26 00:26:27.000000000 +0800
@@ -30,10 +30,11 @@
 
 typedef enum {
   GDK_GL_FEATURE_DEBUG                      = 1 << 0,
-  GDK_GL_FEATURE_BASE_INSTANCE              = 1 << 1,
-  GDK_GL_FEATURE_BUFFER_STORAGE             = 1 << 2,
-  GDK_GL_FEATURE_EXTERNAL_OBJECTS           = 1 << 3,
-  GDK_GL_FEATURE_EXTERNAL_OBJECTS_WIN32     = 1 << 4,
+  GDK_GL_FEATURE_SYNC                       = 1 << 1,
+  GDK_GL_FEATURE_BASE_INSTANCE              = 1 << 2,
+  GDK_GL_FEATURE_BUFFER_STORAGE             = 1 << 3,
+  GDK_GL_FEATURE_EXTERNAL_OBJECTS           = 1 << 4,
+  GDK_GL_FEATURE_EXTERNAL_OBJECTS_WIN32     = 1 << 5,
 } GdkGLFeatures;
 
 #define GDK_GL_N_FEATURES 3

--- gdk/gdkgltexture.c.orig	2025-09-30 18:19:25.000000000 +0800
+++ gdk/gdkgltexture.c	2025-10-26 00:27:15.000000000 +0800
@@ -271,7 +271,8 @@
   self->id = gdk_gl_texture_builder_get_id (builder);
   GDK_TEXTURE (self)->format = gdk_gl_texture_builder_get_format (builder);
   self->has_mipmap = gdk_gl_texture_builder_get_has_mipmap (builder);
-  self->sync = gdk_gl_texture_builder_get_sync (builder);
+  if (gdk_gl_context_has_feature (self->context, GDK_GL_FEATURE_SYNC))
+    self->sync = gdk_gl_texture_builder_get_sync (builder);
   self->destroy = destroy;
   self->data = data;
 
--- gdk/x11/gdkglcontext-glx.c.orig	2025-10-26 00:39:57.000000000 +0800
+++ gdk/x11/gdkglcontext-glx.c	2025-10-26 00:40:14.000000000 +0800
@@ -191,7 +191,8 @@
     {
       g_assert (self->frame_fence == 0);
 
-      self->frame_fence = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+      /* How to use it conditionally here?
+        self->frame_fence = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0); */
 
       /* We consider the frame still getting painted until the GL operation is
        * finished, and the window gets damage reported from the X server.

--- testsuite/gdk/gltexture.c.orig	2025-09-30 18:19:25.000000000 +0800
+++ testsuite/gdk/gltexture.c	2025-10-26 00:32:20.000000000 +0800
@@ -183,7 +183,10 @@
 
   id = make_gl_texture (context, surface);
 
-  sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+  if (gdk_gl_context_has_feature (context, GDK_GL_FEATURE_SYNC))
+    sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+  else
+    sync = NULL;
 
   update_region = cairo_region_create_rectangle (&(cairo_rectangle_int_t) { 10, 10, 32, 32 });
 
--- gtk/gtkglarea.c.orig	2025-09-30 18:19:25.000000000 +0800
+++ gtk/gtkglarea.c	2025-10-26 00:32:54.000000000 +0800
@@ -815,7 +815,8 @@
       priv->texture = NULL;
       priv->textures = g_list_prepend (priv->textures, texture);
 
-      sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+      if (gdk_gl_context_has_feature (priv->context, GDK_GL_FEATURE_SYNC))
+        sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
       gdk_gl_texture_builder_set_sync (texture->builder, sync);
 
       texture->gl_texture = gdk_gl_texture_builder_build (texture->builder,

--- gsk/gpu/gskgpudownloadop.c.orig	2025-09-30 18:19:25.000000000 +0800
+++ gsk/gpu/gskgpudownloadop.c	2025-10-26 00:34:45.000000000 +0800
@@ -311,16 +311,16 @@
   GskGpuDownloadOp *self = (GskGpuDownloadOp *) op;
   GdkGLTextureBuilder *builder;
   GskGLTextureData *data;
+  GdkGLContext *context;
   guint texture_id;
 #ifdef HAVE_DMABUF
-  GdkGLContext *context;
   Texture *texture;
 #endif
 
+  context = GDK_GL_CONTEXT (gsk_gpu_frame_get_context (frame));
   texture_id = gsk_gl_image_get_texture_id (GSK_GL_IMAGE (self->image), 0);
 
 #ifdef HAVE_DMABUF
-  context = GDK_GL_CONTEXT (gsk_gpu_frame_get_context (frame));
   texture = g_new0 (Texture, 1);
 
   if (gdk_gl_context_export_dmabuf (context, texture_id, &texture->dmabuf))
@@ -353,7 +353,8 @@
    * the texture might survive the frame and its surface */
   data->context = g_object_ref (gdk_display_get_gl_context (gsk_gpu_device_get_display (gsk_gpu_frame_get_device (frame))));
   data->texture_id = texture_id;
-  data->sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+  if (gdk_gl_context_has_feature (context, GDK_GL_FEATURE_SYNC))
+    data->sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
 
   builder = gdk_gl_texture_builder_new ();
   gdk_gl_texture_builder_set_context (builder, data->context);

--- gsk/gpu/gskglframe.c.orig	2025-09-30 18:19:25.000000000 +0800
+++ gsk/gpu/gskglframe.c	2025-10-26 00:35:17.000000000 +0800
@@ -320,7 +320,9 @@
       op = gsk_gpu_op_gl_command (op, frame, &state);
     }
 
-  self->sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+  if (gdk_gl_context_has_feature (GDK_GL_CONTEXT (gsk_gpu_frame_get_context (frame)),
+                                  GDK_GL_FEATURE_SYNC))
+    self->sync = glFenceSync (GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
 }
 
 static void
