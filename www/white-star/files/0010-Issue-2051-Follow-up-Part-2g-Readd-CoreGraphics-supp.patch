From 9a5b090655b07e7228d377611f67919a601dfe4a Mon Sep 17 00:00:00 2001
From: Brian Smith <brian@dbsoft.org>
Date: Fri, 12 Sep 2025 17:50:54 -0500
Subject: [PATCH 10/14] Issue #2051 - Follow-up Part 2g: Readd CoreGraphics
 support to native rendering. This support was removed when SKIA was added, so
 it just bailed out. Also add scrollbar drawing code from TenFourFox to
 support the old style.

---
 gfx/2d/BorrowedContext.h              |  10 ---
 gfx/2d/DrawTargetCG.cpp               |  36 ++++++++
 gfx/thebes/gfxQuartzNativeDrawing.cpp |   6 +-
 widget/cocoa/nsNativeThemeCocoa.h     |   5 ++
 widget/cocoa/nsNativeThemeCocoa.mm    | 119 ++++++++++++++++++++++++++
 5 files changed, 163 insertions(+), 13 deletions(-)

diff --git a/gfx/2d/BorrowedContext.h b/gfx/2d/BorrowedContext.h
index edb923b1ea..ee50bf7c73 100644
--- a/gfx/2d/BorrowedContext.h
+++ b/gfx/2d/BorrowedContext.h
@@ -195,18 +195,8 @@ public:
 
   CGContextRef cg;
 private:
-#ifdef USE_SKIA
   static CGContextRef BorrowCGContextFromDrawTarget(DrawTarget *aDT);
   static void ReturnCGContextToDrawTarget(DrawTarget *aDT, CGContextRef cg);
-#else
-  static CGContextRef BorrowCGContextFromDrawTarget(DrawTarget *aDT) {
-    MOZ_CRASH("Not supported without Skia");
-  }
-
-  static void ReturnCGContextToDrawTarget(DrawTarget *aDT, CGContextRef cg) {
-    MOZ_CRASH("not supported without Skia");
-  }
-#endif
   DrawTarget *mDT;
 };
 #endif
diff --git a/gfx/2d/DrawTargetCG.cpp b/gfx/2d/DrawTargetCG.cpp
index 17f8f02da9..754fa35c2a 100644
--- a/gfx/2d/DrawTargetCG.cpp
+++ b/gfx/2d/DrawTargetCG.cpp
@@ -1974,5 +1974,41 @@ DrawTargetCG::MarkChanged()
   }
 }
 
+#ifndef USE_SKIA
+CGContextRef
+BorrowedCGContext::BorrowCGContextFromDrawTarget(DrawTarget *aDT)
+{
+  if (MOZ_LIKELY((aDT->GetBackendType() == BackendType::COREGRAPHICS /* ||
+       aDT->GetBackendType() == BackendType::COREGRAPHICS_ACCELERATED */ ) &&
+      !aDT->IsTiledDrawTarget() && !aDT->IsDualDrawTarget())) {
+    DrawTargetCG* cgDT = static_cast<DrawTargetCG*>(aDT);
+    cgDT->Flush();
+    cgDT->MarkChanged();
+
+    // swap out the context
+    CGContextRef cg = cgDT->mCg;
+    if (MOZ2D_ERROR_IF(!cg)) {
+      return nullptr;
+    }
+    cgDT->mCg = nullptr;
+
+    // save the state to make it easier for callers to avoid mucking with things
+    CGContextSaveGState(cg);
+
+    return cg;
+  }
+  return nullptr;
+}
+
+void
+BorrowedCGContext::ReturnCGContextToDrawTarget(DrawTarget *aDT, CGContextRef cg)
+{
+  DrawTargetCG* cgDT = static_cast<DrawTargetCG*>(aDT);
+
+  CGContextRestoreGState(cg);
+  cgDT->mCg = cg;
+}
+#endif
+
 } // namespace gfx
 } // namespace mozilla
diff --git a/gfx/thebes/gfxQuartzNativeDrawing.cpp b/gfx/thebes/gfxQuartzNativeDrawing.cpp
index f14b71d779..c6604cb031 100644
--- a/gfx/thebes/gfxQuartzNativeDrawing.cpp
+++ b/gfx/thebes/gfxQuartzNativeDrawing.cpp
@@ -25,7 +25,8 @@ gfxQuartzNativeDrawing::BeginNativeDrawing()
 
   DrawTarget *dt = mDrawTarget;
   if (dt->IsDualDrawTarget() || dt->IsTiledDrawTarget() ||
-      dt->GetBackendType() != BackendType::SKIA) {
+      (dt->GetBackendType() != BackendType::SKIA &&
+       dt->GetBackendType() != BackendType::COREGRAPHICS)) {
     // We need a DrawTarget that we can get a CGContextRef from:
     Matrix transform = dt->GetTransform();
 
@@ -39,7 +40,7 @@ gfxQuartzNativeDrawing::BeginNativeDrawing()
     }
 
     mTempDrawTarget =
-      Factory::CreateDrawTarget(BackendType::SKIA,
+      Factory::CreateDrawTarget(dt->GetBackendType(),
                                 IntSize::Truncate(mNativeRect.width, mNativeRect.height),
                                 SurfaceFormat::B8G8R8A8);
 
@@ -50,7 +51,6 @@ gfxQuartzNativeDrawing::BeginNativeDrawing()
     dt = mTempDrawTarget;
   }
   if (dt) {
-    MOZ_ASSERT(dt->GetBackendType() == BackendType::SKIA);
     mCGContext = mBorrowedContext.Init(dt);
     MOZ_ASSERT(mCGContext);
   }
diff --git a/widget/cocoa/nsNativeThemeCocoa.h b/widget/cocoa/nsNativeThemeCocoa.h
index 23f2bc4d32..4ba909f92c 100644
--- a/widget/cocoa/nsNativeThemeCocoa.h
+++ b/widget/cocoa/nsNativeThemeCocoa.h
@@ -156,6 +156,11 @@ protected:
   void DrawResizer(CGContextRef cgContext, const HIRect& aRect, nsIFrame *aFrame);
 
   // Scrollbars
+#if !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7)
+  void DrawScrollbar(CGContextRef aCGContext, const HIRect& aBoxRect, nsIFrame *aFrame);
+  void GetScrollbarDrawInfo (HIThemeTrackDrawInfo& aTdi, nsIFrame *aFrame, 
+                             const CGSize& aSize, bool aShouldGetButtonStates);
+#endif
   void GetScrollbarPressStates(nsIFrame *aFrame,
                                mozilla::EventStates aButtonStates[]);
   nsIFrame* GetParentScrollbarFrame(nsIFrame *aFrame);
diff --git a/widget/cocoa/nsNativeThemeCocoa.mm b/widget/cocoa/nsNativeThemeCocoa.mm
index 2dede403da..442d2be02d 100644
--- a/widget/cocoa/nsNativeThemeCocoa.mm
+++ b/widget/cocoa/nsNativeThemeCocoa.mm
@@ -2059,6 +2059,13 @@ nsNativeThemeCocoa::DrawSegment(CGContextRef cgContext, const HIRect& inBoxRect,
             nil]);
 }
 
+static inline UInt8
+ConvertToPressState(EventStates aButtonState, UInt8 aPressState)
+{
+  // If the button is pressed, return the press state passed in. Otherwise, return 0.
+  return aButtonState.HasAllStates(NS_EVENT_STATE_ACTIVE | NS_EVENT_STATE_HOVER) ? aPressState : 0;
+}
+
 void 
 nsNativeThemeCocoa::GetScrollbarPressStates(nsIFrame* aFrame,
                                             EventStates aButtonStates[])
@@ -2083,6 +2090,111 @@ nsNativeThemeCocoa::GetScrollbarPressStates(nsIFrame* aFrame,
   }
 }
 
+#if !defined(MAC_OS_X_VERSION_10_7) || (MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7)
+// Both of the following sets of numbers were derived by loading the testcase in
+// bmo bug 380185 in Safari and observing its behavior for various heights of scrollbar.
+// These magic numbers are the minimum sizes we can draw a scrollbar and still 
+// have room for everything to display, including the thumb
+#define MIN_SCROLLBAR_SIZE_WITH_THUMB 61
+#define MIN_SMALL_SCROLLBAR_SIZE_WITH_THUMB 49
+// And these are the minimum sizes if we don't draw the thumb
+#define MIN_SCROLLBAR_SIZE 56
+#define MIN_SMALL_SCROLLBAR_SIZE 46
+
+void
+nsNativeThemeCocoa::GetScrollbarDrawInfo(HIThemeTrackDrawInfo& aTdi, nsIFrame *aFrame, 
+                                         const CGSize& aSize, bool aShouldGetButtonStates)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  int32_t curpos = CheckIntAttr(aFrame, nsGkAtoms::curpos, 0);
+  int32_t minpos = CheckIntAttr(aFrame, nsGkAtoms::minpos, 0);
+  int32_t maxpos = CheckIntAttr(aFrame, nsGkAtoms::maxpos, 100);
+  int32_t thumbSize = CheckIntAttr(aFrame, nsGkAtoms::pageincrement, 10);
+
+  bool isHorizontal = aFrame->GetContent()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::orient, 
+                                                          nsGkAtoms::horizontal, eCaseMatters);
+  bool isSmall = aFrame->StyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL;
+
+  aTdi.version = 0;
+  aTdi.kind = isSmall ? kThemeSmallScrollBar : kThemeMediumScrollBar;
+  aTdi.bounds.origin = CGPointZero;
+  aTdi.bounds.size = aSize;
+  aTdi.min = minpos;
+  aTdi.max = maxpos;
+  aTdi.value = curpos;
+  aTdi.attributes = 0;
+  aTdi.enableState = kThemeTrackActive;
+  if (isHorizontal)
+    aTdi.attributes |= kThemeTrackHorizontal;
+
+  aTdi.trackInfo.scrollbar.viewsize = (SInt32)thumbSize;
+
+  // This should be done early on so things like "kThemeTrackNothingToScroll" can
+  // override the active enable state.
+  aTdi.enableState = FrameIsInActiveWindow(aFrame) ? kThemeTrackActive : kThemeTrackInactive;
+
+  /* Only display features if we have enough room for them.
+   * Gecko still maintains the scrollbar info; this is just a visual issue (bug 380185).
+   */
+  int32_t longSideLength = (int32_t)(isHorizontal ? (aSize.width) : (aSize.height));
+  if (longSideLength >= (isSmall ? MIN_SMALL_SCROLLBAR_SIZE_WITH_THUMB : MIN_SCROLLBAR_SIZE_WITH_THUMB)) {
+    aTdi.attributes |= kThemeTrackShowThumb;
+  }
+  else if (longSideLength < (isSmall ? MIN_SMALL_SCROLLBAR_SIZE : MIN_SCROLLBAR_SIZE)) {
+    aTdi.enableState = kThemeTrackNothingToScroll;
+    return;
+  }
+
+  aTdi.trackInfo.scrollbar.pressState = 0;
+
+  // Only go get these scrollbar button states if we need it. For example,
+  // there's no reason to look up scrollbar button states when we're only
+  // creating a TrackDrawInfo to determine the size of the thumb. There's
+  // also no reason to do this on Lion or later, whose scrollbars have no
+  // arrow buttons.
+  if (aShouldGetButtonStates) {
+    EventStates buttonStates[4];
+    GetScrollbarPressStates(aFrame, buttonStates);
+    NSString *buttonPlacement = [[NSUserDefaults standardUserDefaults] objectForKey:@"AppleScrollBarVariant"];
+    // It seems that unless all four buttons are showing, kThemeTopOutsideArrowPressed is the correct constant for
+    // the up scrollbar button.
+    if ([buttonPlacement isEqualToString:@"DoubleBoth"]) {
+      aTdi.trackInfo.scrollbar.pressState = ConvertToPressState(buttonStates[0], kThemeTopOutsideArrowPressed) |
+                                            ConvertToPressState(buttonStates[1], kThemeTopInsideArrowPressed) |
+                                            ConvertToPressState(buttonStates[2], kThemeBottomInsideArrowPressed) |
+                                            ConvertToPressState(buttonStates[3], kThemeBottomOutsideArrowPressed);
+    } else {
+      aTdi.trackInfo.scrollbar.pressState = ConvertToPressState(buttonStates[0], kThemeTopOutsideArrowPressed) |
+                                            ConvertToPressState(buttonStates[1], kThemeBottomOutsideArrowPressed) |
+                                            ConvertToPressState(buttonStates[2], kThemeTopOutsideArrowPressed) |
+                                            ConvertToPressState(buttonStates[3], kThemeBottomOutsideArrowPressed);
+    }
+  }
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+
+static void
+RenderScrollbar(CGContextRef cgContext, const HIRect& aRenderRect, void* aData)
+{
+  HIThemeTrackDrawInfo* tdi = (HIThemeTrackDrawInfo*)aData;
+  HIThemeDrawTrack(tdi, NULL, cgContext, HITHEME_ORIENTATION);
+}
+
+void
+nsNativeThemeCocoa::DrawScrollbar(CGContextRef aCGContext, const HIRect& aBoxRect, nsIFrame *aFrame)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  HIThemeTrackDrawInfo tdi;
+  GetScrollbarDrawInfo(tdi, aFrame, aBoxRect.size, true); // True means we want the press states
+  RenderTransformedHIThemeControl(aCGContext, aBoxRect, RenderScrollbar, &tdi);
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
+#endif
+
 nsIFrame*
 nsNativeThemeCocoa::GetParentScrollbarFrame(nsIFrame *aFrame)
 {
@@ -2777,9 +2889,13 @@ nsNativeThemeCocoa::DrawWidgetBackground(nsRenderingContext* aContext,
 
     case NS_THEME_SCROLLBAR_SMALL:
     case NS_THEME_SCROLLBAR:
+#if !defined(MAC_OS_X_VERSION_10_7) || MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_7
+      DrawScrollbar(cgContext, macRect, aFrame);
+#endif
       break;
     case NS_THEME_SCROLLBARTHUMB_VERTICAL:
     case NS_THEME_SCROLLBARTHUMB_HORIZONTAL: {
+#if defined(MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
       BOOL isOverlay = nsLookAndFeel::UseOverlayScrollbars();
       BOOL isHorizontal = (aWidgetType == NS_THEME_SCROLLBARTHUMB_HORIZONTAL);
       BOOL isRolledOver = IsParentScrollbarRolledOver(aFrame);
@@ -2811,6 +2927,7 @@ nsNativeThemeCocoa::DrawWidgetBackground(nsRenderingContext* aContext,
         [options setObject:@"rollover" forKey:@"state"];
       }
       RenderWithCoreUI(macRect, cgContext, options, true);
+#endif
     }
       break;
 
@@ -2830,6 +2947,7 @@ nsNativeThemeCocoa::DrawWidgetBackground(nsRenderingContext* aContext,
     break;
     case NS_THEME_SCROLLBARTRACK_HORIZONTAL:
     case NS_THEME_SCROLLBARTRACK_VERTICAL: {
+#if defined(MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
       BOOL isOverlay = nsLookAndFeel::UseOverlayScrollbars();
       if (!isOverlay || IsParentScrollbarRolledOver(aFrame)) {
         BOOL isHorizontal = (aWidgetType == NS_THEME_SCROLLBARTRACK_HORIZONTAL);
@@ -2848,6 +2966,7 @@ nsNativeThemeCocoa::DrawWidgetBackground(nsRenderingContext* aContext,
                   nil],
                 true);
       }
+#endif
     }
       break;
 
-- 
2.50.1

