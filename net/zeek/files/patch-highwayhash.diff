From 846fc621842037f13d5d74a5c770f7be9ae038e2 Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Thu, 28 Aug 2025 02:16:09 +0800
Subject: [PATCH] Fixes for powerpc

---
 highwayhash/arch_specific.cc   | 24 ++++++++++++++++++++++--
 highwayhash/arch_specific.h    |  4 ++--
 highwayhash/hh_vsx.cc          |  2 +-
 highwayhash/hh_vsx.h           |  2 +-
 highwayhash/instruction_sets.h |  8 ++++----
 highwayhash/tsc_timer.h        | 12 ++++++++++--
 6 files changed, 40 insertions(+), 12 deletions(-)

diff --git a/highwayhash/arch_specific.cc b/highwayhash/arch_specific.cc
index 2a05860..a0d365e 100644
--- auxil/highwayhash/highwayhash/arch_specific.cc
+++ auxil/highwayhash/highwayhash/arch_specific.cc
@@ -23,7 +23,7 @@
 #if HH_ARCH_PPC
 #if __GLIBC__
 #include <sys/platform/ppc.h>  // __ppc_get_timebase_freq
-#elif __FreeBSD__
+#elif defined(__FreeBSD__) || defined(__APPLE__)
 // clang-format off
 #include <sys/types.h>
 #include <sys/sysctl.h>                 /* must come after sys/types.h */
@@ -155,6 +155,14 @@ double DetectNominalClockRate() {
   sysctlbyname("dev.cpu.0.freq", &freq, &length, NULL, 0);
   freq *= 1E6;
   return freq;
+#elif defined(__APPLE__)
+  uint64_t freq_hz = 0;
+  size_t length = sizeof(freq_hz);
+  int rc = sysctlbyname("hw.cpufrequency", &freq_hz, &length, NULL, 0);
+  if (rc == 0 && freq_hz > 0)
+    return (double)freq_hz;
+  else
+    return 0.0;
 #endif
 #endif
 
@@ -173,18 +181,30 @@ double InvariantTicksPerSecond() {
 #if HH_ARCH_PPC
 #if __GLIBC__
   static const double cycles_per_second = __ppc_get_timebase_freq();
+  return cycles_per_second;
 #elif __FreeBSD__
   double cycles_per_second = 0;
   size_t length = sizeof(cycles_per_second);
   sysctlbyname("kern.timecounter.tc.timebase.frequency", &cycles_per_second,
                &length, NULL, 0);
+  return cycles_per_second;
 #elif __OpenBSD__
   /* There is currently no method of retrieving this via userland.
    * This value is correct for Power8 and Power9.
    */
   static const double cycles_per_second = 512000000;
-#endif
   return cycles_per_second;
+#elif defined(__APPLE__)
+  uint64_t freq_hz = 0;
+  size_t length = sizeof(freq_hz);
+  int rc = sysctlbyname("hw.cpufrequency", &freq_hz, &length, NULL, 0);
+  if (rc == 0 && freq_hz > 0)
+    return (double)freq_hz;
+  else
+    return 0.0;
+#endif
+  /* fallback */
+  return DetectNominalClockRate();
 #else
   return NominalClockRate();
 #endif
diff --git a/highwayhash/arch_specific.h b/highwayhash/arch_specific.h
index 0b8c384..f049d35 100644
--- auxil/highwayhash/highwayhash/arch_specific.h
+++ auxil/highwayhash/highwayhash/arch_specific.h
@@ -70,7 +70,7 @@ namespace highwayhash {
 #define HH_ARCH_NEON 0
 #endif
 
-#if defined(__powerpc64__) || defined(_M_PPC)
+#if defined(__powerpc__) || defined(__powerpc64__) || defined(__POWERPC__) || defined(_M_PPC)
 #define HH_ARCH_PPC 1
 #else
 #define HH_ARCH_PPC 0
@@ -95,7 +95,7 @@ namespace highwayhash {
 // https://stackoverflow.com/questions/18563978/detect-the-availability-of-sse-sse2-instruction-set-in-visual-studio
 #elif defined(__SSE4_1__) || (HH_MSC_VERSION != 0 && defined(__AVX__))
 #define HH_TARGET_NAME SSE41
-#elif defined(__VSX__)
+#elif defined(__VSX__) && !defined(__APPLE__)
 #define HH_TARGET_NAME VSX
 #elif HH_ARCH_NEON
 #define HH_TARGET_NAME NEON
diff --git a/highwayhash/hh_vsx.cc b/highwayhash/hh_vsx.cc
index 6479a7a..208c9a1 100644
--- auxil/highwayhash/highwayhash/hh_vsx.cc
+++ auxil/highwayhash/highwayhash/hh_vsx.cc
@@ -17,6 +17,6 @@
 
 #define HH_TARGET_NAME VSX
 
-#ifdef __VSX__
+#if defined(__VSX__) && !defined(__APPLE__)
 #include "highwayhash/highwayhash_target.cc"
 #endif
diff --git a/highwayhash/hh_vsx.h b/highwayhash/hh_vsx.h
index e503abe..b92344c 100644
--- auxil/highwayhash/highwayhash/hh_vsx.h
+++ auxil/highwayhash/highwayhash/hh_vsx.h
@@ -27,7 +27,7 @@
 
 // For auto-dependency generation, we need to include all headers but not their
 // contents
-#ifndef HH_DISABLE_TARGET_SPECIFIC
+#if !defined(HH_DISABLE_TARGET_SPECIFIC) && !defined(__APPLE__)
 
 #include <altivec.h>
 #undef vector
diff --git a/highwayhash/instruction_sets.h b/highwayhash/instruction_sets.h
index aa7bd6b..f13cda0 100644
--- auxil/highwayhash/highwayhash/instruction_sets.h
+++ auxil/highwayhash/highwayhash/instruction_sets.h
@@ -36,7 +36,8 @@ class InstructionSets {
 // The HH_TARGET_Portable bit is guaranteed to be set.
 #if HH_ARCH_X64
   static TargetBits Supported();
-#elif HH_ARCH_PPC
+// No VSX support on Darwin, incompatible ISA. Notice, !defined(__VSX__) does not work.
+#elif HH_ARCH_PPC && !defined(__APPLE__)
   static HH_INLINE TargetBits Supported() {
     return HH_TARGET_VSX | HH_TARGET_Portable;
   }
@@ -64,7 +65,7 @@ class InstructionSets {
       Func<HH_TARGET_SSE41>()(std::forward<Args>(args)...);
       return HH_TARGET_SSE41;
     }
-#elif HH_ARCH_PPC
+#elif HH_ARCH_PPC && !defined(__APPLE__)
     const TargetBits supported = Supported();
     if (supported & HH_TARGET_VSX) {
       Func<HH_TARGET_VSX>()(std::forward<Args>(args)...);
@@ -96,11 +97,10 @@ class InstructionSets {
     if (supported & HH_TARGET_SSE41) {
       Func<HH_TARGET_SSE41>()(std::forward<Args>(args)...);
     }
-#elif HH_ARCH_PPC
+#elif HH_ARCH_PPC && !defined(__APPLE__)
     if (supported & HH_TARGET_VSX) {
       Func<HH_TARGET_VSX>()(std::forward<Args>(args)...);
     }
-
 #elif HH_ARCH_NEON
     if (supported & HH_TARGET_NEON) {
       Func<HH_TARGET_NEON>()(std::forward<Args>(args)...);
diff --git a/highwayhash/tsc_timer.h b/highwayhash/tsc_timer.h
index e8119b5..827daf9 100644
--- auxil/highwayhash/highwayhash/tsc_timer.h
+++ auxil/highwayhash/highwayhash/tsc_timer.h
@@ -94,7 +94,11 @@ template <>
 inline uint64_t Start<uint64_t>() {
   uint64_t t;
 #if HH_ARCH_PPC
-  asm volatile("mfspr %0, %1" : "=r"(t) : "i"(268));
+  #if defined(__APPLE__)
+    asm volatile("mftb %0" : "=r"(t));
+  #else
+    asm volatile("mfspr %0, %1" : "=r"(t) : "i"(268));
+  #endif
 #elif HH_ARCH_AARCH64
   asm volatile("mrs %0, cntvct_el0" : "=r"(t));
 #elif HH_ARCH_X64 && HH_MSC_VERSION
@@ -125,7 +129,11 @@ template <>
 inline uint64_t Stop<uint64_t>() {
   uint64_t t;
 #if HH_ARCH_PPC
-  asm volatile("mfspr %0, %1" : "=r"(t) : "i"(268));
+  #if defined(__APPLE__)
+    asm volatile("mftb %0" : "=r"(t));
+  #else
+    asm volatile("mfspr %0, %1" : "=r"(t) : "i"(268));
+  #endif
 #elif HH_ARCH_AARCH64
   asm volatile("mrs %0, cntvct_el0" : "=r"(t));
 #elif HH_ARCH_X64 && HH_MSC_VERSION
