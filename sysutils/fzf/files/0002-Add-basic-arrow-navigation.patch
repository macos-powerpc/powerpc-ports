From 6f92ff50f17bf3218427bf87f548621e9d229118 Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Wed, 11 Feb 2026 06:39:10 +0800
Subject: [PATCH] Add basic arrow navigation

diff --git fzf.ml fzf.ml
index e590518..3bd548e 100644
--- fzf.ml
+++ fzf.ml
@@ -4,7 +4,8 @@ open Async
 type t = {
   mutable items: string list
 ; mutable filtered_items : string list
-; mutable selected : string option
+; mutable selected_index : int
+; mutable selection_list : string list
 ; spinner : Spinner.t
 ; mutable entered_text : string option
 }
@@ -13,13 +14,14 @@ let create () =
   {
     items = []
   ; filtered_items = []
-  ; selected = None
+  ; selected_index = 0
+  ; selection_list = []
   ; spinner = Spinner.create ~spin_every:(sec 0.2)
   ; entered_text = None
   }
 
 let filter_items_and_selection t entered_text =
-  let { items; filtered_items = _; selected =_; spinner = _; entered_text = _} = t in
+  let { items; filtered_items = _; selected_index = _; selection_list = _; spinner = _; entered_text = _} = t in
   t.entered_text <- entered_text;
   let filtered_items =
     match entered_text with
@@ -30,18 +32,24 @@ let filter_items_and_selection t entered_text =
       |> List.filter ~f:(fun item ->
           Option.is_some @@ String.Search_pattern.index ~in_:item pattern)
   in
-  let filtered_items, selected =
+  let selection_list, filtered_items =
     match filtered_items with
-    | selection :: filtered_items -> (filtered_items, Some selection)
-    | [] -> ([], None)
+    | first :: rest -> ([first], rest)
+    | [] -> ([], [])
   in
+  (* Reset selection index when filter changes *)
+  t.selected_index <- 0;
+  t.selection_list <- selection_list;
   t.filtered_items <- filtered_items;
-  t.selected <- selected;
+;;
+
+let get_selected t =
+  List.nth t.selection_list t.selected_index
 ;;
 
 let widget t screen =
   let open Tty_text in
-  let {items = _; filtered_items; selected; spinner; entered_text } = t in
+  let {items = _; filtered_items; selected_index = _; selection_list = _; spinner; entered_text } = t in
   let prompt_size = 1 in
   let item_count = screen.Screen_dimensions.height - prompt_size in
   let all_but_selection =
@@ -54,7 +62,9 @@ let widget t screen =
         Widget.text text)
   in
   let selected =
-    Option.map ~f:Widget.text selected
+    match List.nth t.selection_list t.selected_index with
+    | Some sel -> Some (Widget.text sel)
+    | None -> None
   in
   let spinner = Option.map
       (Spinner.to_char spinner)
@@ -74,6 +84,37 @@ let widget t screen =
 
 let handle_input t input =
   match input with
+  | Tty_text.User_input.Arrow_down -> begin
+      let all_items = t.selection_list @ t.filtered_items in
+      let max_index = (List.length all_items) - 1 in
+      if t.selected_index < max_index then begin
+        t.selected_index <- t.selected_index + 1;
+        (* If we move past current selection_list, rotate items *)
+        if t.selected_index >= List.length t.selection_list then begin
+          match t.filtered_items with
+          | next :: rest ->
+            t.selection_list <- t.selection_list @ [next];
+            t.filtered_items <- rest
+          | [] -> ()
+        end
+      end;
+      `Continue t
+    end
+  | Tty_text.User_input.Arrow_up -> begin
+      if t.selected_index > 0 then begin
+        t.selected_index <- t.selected_index - 1;
+        (* If we move back and selection_list is too long, rotate back *)
+        if List.length t.selection_list > 1 &&
+           t.selected_index < List.length t.selection_list - 1 then begin
+          match List.rev t.selection_list with
+          | last :: rest ->
+            t.selection_list <- List.rev rest;
+            t.filtered_items <- last :: t.filtered_items
+          | [] -> ()
+        end
+      end;
+      `Continue t
+    end
   | Tty_text.User_input.Backspace -> begin
       match t.entered_text with
       | None -> `Continue t
@@ -94,7 +135,7 @@ let handle_input t input =
       filter_items_and_selection t (Some text);
       `Continue t
     end
-  | Return -> (`Finished t.selected)
+  | Return -> (`Finished (get_selected t))
   | Escape -> (`Finished None)
 ;;
 
diff --git tty_text.ml tty_text.ml
index 243c871..b459ace 100644
--- tty_text.ml
+++ tty_text.ml
@@ -4,6 +4,8 @@ open Async
 module User_input = struct
   type t =
     | Ctrl_c
+    | Arrow_up
+    | Arrow_down
     | Escape
     | Backspace
     | Return (* Enter key *)
@@ -169,11 +171,11 @@ let with_rendering f =
     let%bind () = do_action tty_writer Clear_screen in
     let user_input =
       Pipe.create_reader ~close_on_exception:true (fun w ->
+        let b = Bytes.create 3 in
         let repeat x =
           let%bind () = Pipe.write w x in
           return (`Repeat ())
         in
-        let b = Bytes.create 1 in
         Deferred.repeat_until_finished () (fun () ->
           match%bind Reader.really_read ~len:1 tty_reader b with
           | `Eof _ -> return (`Finished ())
@@ -182,9 +184,31 @@ let with_rendering f =
             | 3 (* CTRL + C *) ->
               let%bind () = Pipe.write w User_input.Ctrl_c in
               return (`Finished ())
+            | 0O33  -> (* ESC - check if it's an arrow key *)
+              (* Try to read the next two bytes for arrow key sequences *)
+              let%bind read_result =
+                Clock.with_timeout (Time_float.Span.of_ms 50.0)
+                  (Reader.really_read ~len:2 tty_reader b ~pos:1)
+              in
+              (match read_result with
+              | `Result (`Ok) ->
+                (* Check for arrow key escape sequences: ESC[A, ESC[B, ESC[C, ESC[D *)
+                (match (Bytes.get b 1, Bytes.get b 2) with
+                | ('[', 'A') -> repeat Arrow_up
+                | ('[', 'B') -> repeat Arrow_down
+                | ('[', 'C') -> return (`Repeat ())  (* Right arrow - ignore *)
+                | ('[', 'D') -> return (`Repeat ())  (* Left arrow - ignore *)
+                | _ -> repeat Escape  (* Some other escape sequence *)
+                )
+              | `Result (`Eof _) ->
+                (* Timeout or EOF - treat as plain Escape *)
+                repeat Escape
+              | `Timeout ->
+                (* Just ESC key pressed alone *)
+                repeat Escape
+              )
             | 0O177 -> repeat Backspace
             | 0O015 -> repeat Return
-            | 0O33  -> repeat Escape
             | _     -> repeat (Char (Bytes.get b 0))
         )
       )
diff --git tty_text.mli tty_text.mli
index 5cfb4bd..5721fe0 100644
--- tty_text.mli
+++ tty_text.mli
@@ -28,6 +28,8 @@ end
 module User_input : sig
   type t =
     | Ctrl_c
+    | Arrow_up
+    | Arrow_down
     | Escape
     | Backspace
     | Return (* Enter key *)
