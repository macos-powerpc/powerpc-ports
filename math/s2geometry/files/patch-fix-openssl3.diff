Ref https://github.com/google/s2geometry/blob/7c960800b9b4af751ea5e6788f8d04442d7f6af4/src/s2/util/math/exactfloat/exactfloat.cc

--- src/s2/util/math/exactfloat/exactfloat.cc
+++ src/s2/util/math/exactfloat/exactfloat.cc	2025-11-05 13:26:05.000000000 +0800
@@ -90,16 +90,17 @@
 // Return the absolute value of a BIGNUM as a 64-bit unsigned integer.
 // Requires that BIGNUM fits into 64 bits.
 inline static uint64_t BN_ext_get_uint64(const BIGNUM* bn) {
-  ABSL_DCHECK_LE(BN_num_bytes(bn), sizeof(uint64_t));
-#if BN_BITS2 == 64
-  return BN_get_word(bn);
+  uint64_t r;
+#if defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+  ABSL_CHECK_EQ(BN_bn2lebinpad(bn, reinterpret_cast<unsigned char*>(&r),
+                sizeof(r)), sizeof(r));
+#elif defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+  ABSL_CHECK_EQ(BN_bn2binpad(bn, reinterpret_cast<unsigned char*>(&r),
+                sizeof(r)), sizeof(r));
 #else
-  static_assert(BN_BITS2 == 32, "at least 32 bit openssl build needed");
-  if (bn->top == 0) return 0;
-  if (bn->top == 1) return BN_get_word(bn);
-  ABSL_DCHECK_EQ(bn->top, 2);
-  return (static_cast<uint64_t>(bn->d[1]) << 32) + bn->d[0];
+#error Unknown endianness
 #endif
+  return r;
 }
 
 static int BN_ext_count_low_zero_bits(const BIGNUM* bn) {
