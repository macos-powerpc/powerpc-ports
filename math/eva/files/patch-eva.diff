--- eva-0.3.1/src/lex.rs	2022-11-08 09:52:05.000000000 +0800
+++ eva-0.3.1/src/lex.rs	2026-01-05 09:15:35.000000000 +0800
@@ -100,6 +100,35 @@
     m
 });
 
+fn sin_deg(x: f64) -> f64 { x.to_radians().sin() }
+fn cos_deg(x: f64) -> f64 { x.to_radians().cos() }
+fn tan_deg(x: f64) -> f64 { x.to_radians().tan() }
+fn csc_deg(x: f64) -> f64 { 1. / x.to_radians().sin() }
+fn sec_deg(x: f64) -> f64 { 1. / x.to_radians().cos() }
+fn cot_deg(x: f64) -> f64 { 1. / x.to_radians().tan() }
+fn sinh_fn(x: f64) -> f64 { x.sinh() }
+fn cosh_fn(x: f64) -> f64 { x.cosh() }
+fn tanh_fn(x: f64) -> f64 { x.tanh() }
+fn ln_fn(x: f64) -> f64 { x.ln() }
+fn log10_fn(x: f64) -> f64 { x.log10() }
+fn sqrt_fn(x: f64) -> f64 { x.sqrt() }
+fn ceil_fn(x: f64) -> f64 { x.ceil() }
+fn floor_fn(x: f64) -> f64 { x.floor() }
+fn rad_fn(x: f64) -> f64 { x.to_radians() }
+fn deg_fn(x: f64) -> f64 { x.to_degrees() }
+fn abs_fn(x: f64) -> f64 { x.abs() }
+fn asin_fn(x: f64) -> f64 { x.asin() }
+fn acos_fn(x: f64) -> f64 { x.acos() }
+fn atan_fn(x: f64) -> f64 { x.atan() }
+fn acsc_fn(x: f64) -> f64 { (1. / x).asin() }
+fn asec_fn(x: f64) -> f64 { (1. / x).acos() }
+fn acot_fn(x: f64) -> f64 { (1. / x).atan() }
+fn exp_fn(x: f64) -> f64 { x.exp() }
+fn exp2_fn(x: f64) -> f64 { x.exp2() }
+fn round_fn(x: f64) -> f64 { x.round() }
+fn log_fn(x: f64, y: f64) -> f64 { x.log(y) }
+fn nroot_fn(x: f64, y: f64) -> f64 { x.powf(1. / y) }
+
 pub static FUNCTIONS: Lazy<HashMap<&str, Token>> = Lazy::new(|| {
     use Relation::*;
     fn add_fn(map: &mut HashMap<&str, Token>, token: &'static str, relation: Relation) {
@@ -107,37 +136,45 @@
         map.insert(token, func);
     }
     let mut m = HashMap::new();
-    add_fn(&mut m, "sin", N1(|x| rad(x).sin()));
-    add_fn(&mut m, "cos", N1(|x| rad(x).cos()));
-    add_fn(&mut m, "tan", N1(|x| rad(x).tan()));
-    add_fn(&mut m, "csc", N1(|x| rad(x).sin().recip()));
-    add_fn(&mut m, "sec", N1(|x| rad(x).cos().recip()));
-    add_fn(&mut m, "cot", N1(|x| rad(x).tan().recip()));
-    add_fn(&mut m, "sinh", N1(|x| x.sinh()));
-    add_fn(&mut m, "cosh", N1(|x| x.cosh()));
-    add_fn(&mut m, "tanh", N1(|x| x.tanh()));
-    add_fn(&mut m, "ln", N1(|x| x.ln()));
-    add_fn(&mut m, "log10", N1(|x| x.log10()));
-    add_fn(&mut m, "sqrt", N1(|x| x.sqrt()));
-    add_fn(&mut m, "ceil", N1(|x| x.ceil()));
-    add_fn(&mut m, "floor", N1(|x| x.floor()));
-    add_fn(&mut m, "rad", N1(|x| x.to_radians()));
-    add_fn(&mut m, "deg", N1(|x| x.to_degrees()));
-    add_fn(&mut m, "abs", N1(|x| x.abs()));
-    add_fn(&mut m, "asin", N1(|x| x.asin()));
-    add_fn(&mut m, "acos", N1(|x| x.acos()));
-    add_fn(&mut m, "atan", N1(|x| x.atan()));
-    add_fn(&mut m, "acsc", N1(|x| (1. / x).asin()));
-    add_fn(&mut m, "asec", N1(|x| (1. / x).acos()));
-    add_fn(&mut m, "acot", N1(|x| (1. / x).atan()));
-    add_fn(&mut m, "exp", N1(|x| x.exp()));
-    add_fn(&mut m, "exp2", N1(|x| x.exp2()));
-    add_fn(&mut m, "round", N1(|x| x.round()));
-    add_fn(&mut m, "log", N2(|x, y| x.log(y)));
-    add_fn(&mut m, "nroot", N2(|x, y| x.powf(1. / y)));
+    add_fn(&mut m, "sin", N1(sin_deg));
+    add_fn(&mut m, "cos", N1(cos_deg));
+    add_fn(&mut m, "tan", N1(tan_deg));
+    add_fn(&mut m, "csc", N1(csc_deg));
+    add_fn(&mut m, "sec", N1(sec_deg));
+    add_fn(&mut m, "cot", N1(cot_deg));
+    add_fn(&mut m, "sinh", N1(sinh_fn));
+    add_fn(&mut m, "cosh", N1(cosh_fn));
+    add_fn(&mut m, "tanh", N1(tanh_fn));
+    add_fn(&mut m, "ln", N1(ln_fn));
+    add_fn(&mut m, "log10", N1(log10_fn));
+    add_fn(&mut m, "sqrt", N1(sqrt_fn));
+    add_fn(&mut m, "ceil", N1(ceil_fn));
+    add_fn(&mut m, "floor", N1(floor_fn));
+    add_fn(&mut m, "rad", N1(rad_fn));
+    add_fn(&mut m, "deg", N1(deg_fn));
+    add_fn(&mut m, "abs", N1(abs_fn));
+    add_fn(&mut m, "asin", N1(asin_fn));
+    add_fn(&mut m, "acos", N1(acos_fn));
+    add_fn(&mut m, "atan", N1(atan_fn));
+    add_fn(&mut m, "acsc", N1(acsc_fn));
+    add_fn(&mut m, "asec", N1(asec_fn));
+    add_fn(&mut m, "acot", N1(acot_fn));
+    add_fn(&mut m, "exp", N1(exp_fn));
+    add_fn(&mut m, "exp2", N1(exp2_fn));
+    add_fn(&mut m, "round", N1(round_fn));
+    add_fn(&mut m, "log", N2(log_fn));
+    add_fn(&mut m, "nroot", N2(nroot_fn));
     m
 });
 
+fn add_fn(x: f64, y: f64) -> f64 { x + y }
+fn sub_fn(x: f64, y: f64) -> f64 { x - y }
+fn mul_fn(x: f64, y: f64) -> f64 { x * y }
+fn div_fn(x: f64, y: f64) -> f64 { x / y }
+fn rem_fn(x: f64, y: f64) -> f64 { x % y }
+fn pow_fn(x: f64, y: f64) -> f64 { x.powf(y) }
+fn fact_fn(x: f64, _: f64) -> f64 { factorial(x) }
+
 pub static OPERATORS: Lazy<HashMap<char, Token>> = Lazy::new(|| {
     fn add_op(
         map: &mut HashMap<char, Token>,
@@ -150,13 +187,13 @@
         map.insert(token, op);
     }
     let mut m = HashMap::new();
-    add_op(&mut m, '+', |x, y| x + y, 2, true);
-    add_op(&mut m, '-', |x, y| x - y, 2, true);
-    add_op(&mut m, '*', |x, y| x * y, 3, true);
-    add_op(&mut m, '/', |x, y| x / y, 3, true);
-    add_op(&mut m, '%', |x, y| x % y, 3, true);
-    add_op(&mut m, '^', |x, y| x.powf(y), 4, false);
-    add_op(&mut m, '!', |x, _| factorial(x), 4, true);
+    add_op(&mut m, '+', add_fn, 2, true);
+    add_op(&mut m, '-', sub_fn, 2, true);
+    add_op(&mut m, '*', mul_fn, 3, true);
+    add_op(&mut m, '/', div_fn, 3, true);
+    add_op(&mut m, '%', rem_fn, 3, true);
+    add_op(&mut m, '^', pow_fn, 4, false);
+    add_op(&mut m, '!', fact_fn, 4, true);
     m
 });
 

--- eva-0.3.1/src/main.rs	2022-11-08 09:52:05.000000000 +0800
+++ eva-0.3.1/src/main.rs	2026-01-05 09:21:45.000000000 +0800
@@ -31,7 +31,7 @@
 pub struct Configuration {
     radian_mode: bool,
     fix: usize,
-    base: u8,
+    base: usize,
     input: String,
 }
 
@@ -160,7 +160,7 @@
             Arg::new("base")
                 .short('b')
                 .long("base")
-                .value_parser(RangedU64ValueParser::<u8>::new().range(1..=36))
+                .value_parser(RangedU64ValueParser::<usize>::new().range(1..=36))
                 .default_value("10")
                 .value_name("RADIX")
                 .help("Radix of calculation output (1 - 36)"),
@@ -197,10 +197,7 @@
     let lexed = lexer(&input[..], prev_ans)?;
     let postfixed = to_postfix(lexed)?;
     let evaled = eval_postfix(postfixed)?;
-    let evaled_fixed = format!("{:.*}", CONFIGURATION.fix, evaled)
-        .parse::<f64>()
-        .unwrap();
-    Ok(evaled_fixed)
+    Ok(evaled)
 }
 
 #[cfg(test)]
