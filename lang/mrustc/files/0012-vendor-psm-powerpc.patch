--- a/vendor/psm/src/arch/powerpc32.s	2021-07-26 23:20:39.000000000 +0800
+++ b/vendor/psm/src/arch/powerpc32.s	2025-12-16 06:56:45.000000000 +0800
@@ -1,76 +1,46 @@
 #include "psm.h"
-/* FIXME: this probably does not cover all ABIs? Tested with sysv only, possibly works for AIX as
-   well?
-*/
+/* PowerPC 32-bit implementation for Darwin ABI */
 
 .text
-.globl rust_psm_stack_direction
-.p2align 2
-.type rust_psm_stack_direction,@function
-rust_psm_stack_direction:
+.globl _rust_psm_stack_direction
+.align 2
+_rust_psm_stack_direction:
 /* extern "C" fn() -> u8 */
-.cfi_startproc
-    li 3, STACK_DIRECTION_DESCENDING
+    li r3, STACK_DIRECTION_DESCENDING
     blr
-.rust_psm_stack_direction_end:
-.size       rust_psm_stack_direction,.rust_psm_stack_direction_end-rust_psm_stack_direction
-.cfi_endproc
 
 
-.globl rust_psm_stack_pointer
-.p2align 2
-.type rust_psm_stack_pointer,@function
-rust_psm_stack_pointer:
+.globl _rust_psm_stack_pointer
+.align 2
+_rust_psm_stack_pointer:
 /* extern "C" fn() -> *mut u8 */
-.cfi_startproc
-    mr 3, 1
+    mr r3, r1
     blr
-.rust_psm_stack_pointer_end:
-.size       rust_psm_stack_pointer,.rust_psm_stack_pointer_end-rust_psm_stack_pointer
-.cfi_endproc
 
 
-.globl rust_psm_replace_stack
-.p2align 2
-.type rust_psm_replace_stack,@function
-rust_psm_replace_stack:
-/* extern "C" fn(3: usize, 4: extern "C" fn(usize), 5: *mut u8) */
-.cfi_startproc
+.globl _rust_psm_replace_stack
+.align 2
+_rust_psm_replace_stack:
+/* extern "C" fn(r3: usize, r4: extern "C" fn(usize), r5: *mut u8) */
 /* NOTE: perhaps add a debug-assertion for stack alignment? */
-    addi 5, 5, -16
-    mr 1, 5
-    mtctr 4
+    addi r5, r5, -16
+    mr r1, r5
+    mtctr r4
     bctr
-.rust_psm_replace_stack_end:
-.size       rust_psm_replace_stack,.rust_psm_replace_stack_end-rust_psm_replace_stack
-.cfi_endproc
-
-
-.globl rust_psm_on_stack
-.p2align 2
-.type rust_psm_on_stack,@function
-rust_psm_on_stack:
-/* extern "C" fn(3: usize, 4: usize, 5: extern "C" fn(usize, usize), 6: *mut u8) */
-.cfi_startproc
-    mflr 0
-    stw 0, -24(6)
-    sub 6, 6, 1
-    addi 6, 6, -32
-    stwux 1, 1, 6
-    .cfi_def_cfa r1, 32
-    .cfi_offset r1, -32
-    .cfi_offset lr, -24
-    mtctr 5
+
+
+.globl _rust_psm_on_stack
+.align 2
+_rust_psm_on_stack:
+/* extern "C" fn(r3: usize, r4: usize, r5: extern "C" fn(usize, usize), r6: *mut u8) */
+    mflr r0
+    stw r0, -24(r6)
+    sub r6, r6, r1
+    addi r6, r6, -32
+    stwux r1, r1, r6
+    mtctr r5
     bctrl
-    lwz 0, 8(1)
-    mtlr 0
-    .cfi_restore lr
-    /* FIXME: after this instruction backtrace breaks until control returns to the caller
-       That being said compiler-generated code has the same issue, so I guess that is fine for now?
-    */
-    lwz 1, 0(1)
-    .cfi_restore r1
+    lwz r0, 8(r1)
+    mtlr r0
+    lwz r1, 0(r1)
     blr
-.rust_psm_on_stack_end:
-.size       rust_psm_on_stack,.rust_psm_on_stack_end-rust_psm_on_stack
-.cfi_endproc
