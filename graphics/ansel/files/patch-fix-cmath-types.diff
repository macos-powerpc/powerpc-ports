--- src/common/math.h	2023-06-30 14:13:18.000000000 +0800
+++ src/common/math.h	2024-04-30 04:54:50.000000000 +0800
@@ -23,6 +23,10 @@
 #include <stdint.h>
 #include "common/sse.h"		// also includes darktable.h
 
+#ifdef __cplusplus
+#include <cmath>
+#endif
+
 #define NORM_MIN 1.52587890625e-05f // norm can't be < to 2^(-16)
 
 // select speed vs accuracy tradeoff
@@ -87,22 +91,38 @@
 
 static inline gboolean dt_isnan(float val)
 {
+#ifdef __cplusplus
+  return std::isnan(val);
+#else
   return isnan(val);
+#endif
 }
 
 static inline gboolean dt_isinf(float val)
 {
+#ifdef __cplusplus
+  return std::isinf(val);
+#else
   return isinf(val);
+#endif
 }
 
 static inline gboolean dt_isfinite(float val)
 {
+#ifdef __cplusplus
+  return std::isfinite(val);
+#else
   return isfinite(val);
+#endif
 }
 
 static inline gboolean dt_isnormal(float val)
 {
+#ifdef __cplusplus
+  return std::isnormal(val);
+#else
   return isnormal(val);
+#endif
 }
 
 #ifdef __GNUC__

--- src/iop/lens.cc	2023-06-30 14:13:18.000000000 +0800
+++ src/iop/lens.cc	2024-04-30 06:11:37.000000000 +0800
@@ -20,6 +20,11 @@
 // that non-finite numbers are in use in this source file even if we have globally
 // enabled the finite-math-only optimization.  Otherwise, it may optimize away
 // conditionals based on isnan() or isfinite().
+
+#ifdef __cplusplus
+#include <cmath>
+#endif
+
 #ifdef __GNUC__
 #pragma GCC optimize ("no-finite-math-only")
 #endif
@@ -958,9 +963,15 @@
         {
           for(int c = 0; c < 3; c++)
           {
+#ifdef __cplusplus
+            if(d->do_nan_checks
+               && (!std::isfinite(bufptr[c * 2])
+                   || !std::isfinite(bufptr[c * 2 + 1])))
+#else
             if(d->do_nan_checks
                && (!isfinite(bufptr[c * 2])
                    || !isfinite(bufptr[c * 2 + 1])))
+#endif
             {
               out[c] = 0.0f;
               continue;
@@ -979,7 +990,11 @@
 
           if(mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK)
           {
+#ifdef __cplusplus
+            if(d->do_nan_checks && (!std::isfinite(bufptr[2]) || !std::isfinite(bufptr[3])))
+#else
             if(d->do_nan_checks && (!isfinite(bufptr[2]) || !isfinite(bufptr[3])))
+#endif
             {
               out[3] = 0.0f;
               continue;
@@ -1080,9 +1095,15 @@
         {
           for(int c = 0; c < 3; c++)
           {
+#ifdef __cplusplus
+            if(d->do_nan_checks
+               && (!std::isfinite(buf2ptr[c * 2])
+                   || !std::isfinite(buf2ptr[c * 2 + 1])))
+#else
             if(d->do_nan_checks
                && (!isfinite(buf2ptr[c * 2])
                    || !isfinite(buf2ptr[c * 2 + 1])))
+#endif
             {
               out[c] = 0.0f;
               continue;
@@ -1100,7 +1121,11 @@
 
           if(mask_display & DT_DEV_PIXELPIPE_DISPLAY_MASK)
           {
+#ifdef __cplusplus
+            if(d->do_nan_checks && (!std::isfinite(buf2ptr[2]) || !std::isfinite(buf2ptr[3])))
+#else
             if(d->do_nan_checks && (!isfinite(buf2ptr[2]) || !isfinite(buf2ptr[3])))
+#endif
             {
               out[3] = 0.0f;
               continue;
@@ -1550,7 +1575,11 @@
     float *_out = out + (size_t)y * roi_out->width;
     for(int x = 0; x < roi_out->width; x++, bufptr += 6, _out++)
     {
+#ifdef __cplusplus
+      if(d->do_nan_checks && (!std::isfinite(bufptr[2]) || !std::isfinite(bufptr[3])))
+#else
       if(d->do_nan_checks && (!isfinite(bufptr[2]) || !isfinite(bufptr[3])))
+#endif
       {
         *_out = 0.0f;
         continue;
@@ -1655,10 +1684,17 @@
         {
           const float x = buf[6 * k + c];
           const float y = buf[6 * k + c + 1];
+#ifdef __cplusplus
+          xm = std::isnan(x) ? xm : MIN(xm, x);
+          xM = std::isnan(x) ? xM : MAX(xM, x);
+          ym = std::isnan(y) ? ym : MIN(ym, y);
+          yM = std::isnan(y) ? yM : MAX(yM, y);
+#else
           xm = isnan(x) ? xm : MIN(xm, x);
           xM = isnan(x) ? xM : MAX(xM, x);
           ym = isnan(y) ? ym : MIN(ym, y);
           yM = isnan(y) ? yM : MAX(yM, y);
+#endif
         }
       }
     }
@@ -1666,10 +1702,17 @@
     dt_free_align(buf);
 
     // LensFun can return NAN coords, so we need to handle them carefully.
+#ifdef __cplusplus
+    if(!std::isfinite(xm) || !(0 <= xm && xm < orig_w)) xm = 0;
+    if(!std::isfinite(xM) || !(1 <= xM && xM < orig_w)) xM = orig_w;
+    if(!std::isfinite(ym) || !(0 <= ym && ym < orig_h)) ym = 0;
+    if(!std::isfinite(yM) || !(1 <= yM && yM < orig_h)) yM = orig_h;
+#else
     if(!isfinite(xm) || !(0 <= xm && xm < orig_w)) xm = 0;
     if(!isfinite(xM) || !(1 <= xM && xM < orig_w)) xM = orig_w;
     if(!isfinite(ym) || !(0 <= ym && ym < orig_h)) ym = 0;
     if(!isfinite(yM) || !(1 <= yM && yM < orig_h)) yM = orig_h;
+#endif
 
     const struct dt_interpolation *interpolation =
       dt_interpolation_new(DT_INTERPOLATION_USERPREF_WARP);
