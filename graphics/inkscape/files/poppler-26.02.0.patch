diff --git a/src/extension/internal/pdfinput/pdf-parser.cpp b/src/extension/internal/pdfinput/pdf-parser.cpp
index 96e475786ce90a4bfa4d050f4e81a396fb2b3f94..1a7a470c215c6cd18b359f550fab2e9bc9d681c4 100644
--- src/extension/internal/pdfinput/pdf-parser.cpp
+++ src/extension/internal/pdfinput/pdf-parser.cpp
@@ -653,7 +653,11 @@
 void PdfParser::opSetLineJoin(Object args[], int /*numArgs*/)
 {
   builder->beforeStateChange(state);
+#if POPPLER_CHECK_VERSION(26,2,0)
+  state->setLineJoin((GfxState::LineJoinStyle) args[0].getInt());
+#else
   state->setLineJoin(args[0].getInt());
+#endif
   builder->updateStyle(state);
 }
 
@@ -661,7 +665,11 @@
 void PdfParser::opSetLineCap(Object args[], int /*numArgs*/)
 {
   builder->beforeStateChange(state);
+#if POPPLER_CHECK_VERSION(26,2,0)
+  state->setLineCap((GfxState::LineCapStyle) args[0].getInt());
+#else
   state->setLineCap(args[0].getInt());
+#endif
   builder->updateStyle(state);
 }
 
@@ -1565,7 +1573,13 @@
 
   // restore graphics state
   restoreState();
+#if POPPLER_CHECK_VERSION(26, 2, 0)
+  state->clearPath();
+  GfxPath *currPath = const_cast<GfxPath*>(state->getPath());
+  currPath->append(savedPath);
+#else
   state->setPath(savedPath);
+#endif
 }
 
 // TODO not good that numArgs is ignored but args[] is used:
@@ -1626,7 +1640,13 @@
   // restore graphics state
   if (savedState) {
     restoreState();
+#if POPPLER_CHECK_VERSION(26, 2, 0)
+    state->clearPath();
+    GfxPath *currPath = const_cast<GfxPath*>(state->getPath());
+    currPath->append(savedPath);
+#else
     state->setPath(savedPath);
+#endif
   }
 }
 
@@ -2213,7 +2233,7 @@
 {
   Array *a = nullptr;
   Object obj;
-  int wMode = 0; // Writing mode (horizontal/vertical).
+  _POPPLER_WMODE wMode = _POPPLER_WMODE_HORIZONTAL; // Writing mode (horizontal/vertical).
 
   if (!state->getFont()) {
     error(errSyntaxError, getPos(), "No font in show/space");
@@ -2227,7 +2247,7 @@
     if (obj.isNum()) {
       // this uses the absolute value of the font size to match
       // Acrobat's behavior
-      if (wMode) {
+      if (wMode != _POPPLER_WMODE_HORIZONTAL) {
 	state->textShift(0, -obj.getNum() * 0.001 *
 			    fabs(state->getFontSize()));
       } else {
@@ -2254,7 +2274,7 @@
 void PdfParser::doShowText(GooString *s) {
 #endif
     auto font = state->getFont();
-    int wMode = font->getWMode(); // Vertical/Horizontal/Invalid
+    _POPPLER_WMODE wMode = font->getWMode(); // Vertical/Horizontal/Invalid
 
     builder->beginString(state, get_goostring_length(*s));
 
@@ -2289,7 +2309,7 @@
         auto ax = dx;
         auto ay = dy;
 
-        if (wMode != 0) {
+        if (wMode != _POPPLER_WMODE_HORIZONTAL) {
             // Vertical text (or invalid value).
             dy += state->getCharSpace();
             if (n == 1 && *p == ' ') {
@@ -2964,7 +2984,11 @@
   // make stream
 #if defined(POPPLER_NEW_OBJECT_API)
   str = new EmbedStream(parser->getStream(), dict.copy(), gFalse, 0);
+#if POPPLER_CHECK_VERSION(26, 2, 0)
+  str = str->addFilters(std::unique_ptr<Stream>(str), dict.getDict()).release();
+#else
   str = str->addFilters(dict.getDict());
+#endif
 #else
   str = new EmbedStream(parser->getStream(), &dict, gFalse, 0);
   str = str->addFilters(&dict);
@@ -3137,10 +3161,17 @@
             auto visible = true;
             // Normally we'd use poppler optContentIsVisible, but these dict
             // objects don't retain their references so can't be used directly.
+#if POPPLER_CHECK_VERSION(26, 2, 0)
+            for (auto &[ref, ocg] : ocgs->getOCGs()) {
+                if (ocg->getName()->toStr() == label)
+                    visible = ocg->getState() == OptionalContentGroup::On;
+            }
+#else
             for (auto &[ref, ocg] : ocgs->getOCGs()) {
                 if (ocg->getName()->cmp(label) == 0)
                     visible = ocg->getState() == OptionalContentGroup::On;
             }
+#endif
             builder->addOptionalGroup(dict->getKey(j), label, visible);
         }
     }
diff --git a/src/extension/internal/pdfinput/poppler-transition-api.h b/src/extension/internal/pdfinput/poppler-transition-api.h
index 6f2b97c50971b52a71093da10b7d708555248fae..5dfac7594f06b0481a2806fb687b8c23551fd71d 100644
--- src/extension/internal/pdfinput/poppler-transition-api.h
+++ src/extension/internal/pdfinput/poppler-transition-api.h
@@ -15,6 +15,16 @@
 #include <glib/poppler-features.h>
 #include <poppler/UTF.h>
 
+#if POPPLER_CHECK_VERSION(26, 2, 0)
+#define _POPPLER_WMODE GfxFont::WritingMode
+#define _POPPLER_WMODE_HORIZONTAL GfxFont::WritingMode::Horizontal
+#define _POPPLER_WMODE_VERTICAL GfxFont::WritingMode::Vertical
+#else
+#define _POPPLER_WMODE int
+#define _POPPLER_WMODE_HORIZONTAL 0
+#define _POPPLER_WMODE_VERTICAL 1
+#endif
+
 #if POPPLER_CHECK_VERSION(25, 7, 0)
 #define _POPPLER_TEXT_SHIFT_WITH_USER_COORDS(dx, dy) textShiftWithUserCoords(dx, dy)
 #define _POPPLER_FOFI_TRUETYPE_MAKE(font_data, faceIndex) FoFiTrueType::make(std::span(font_data), faceIndex)
diff --git a/src/extension/internal/pdfinput/svg-builder.cpp b/src/extension/internal/pdfinput/svg-builder.cpp
index a8a73b08bb539696562515b4a6d83d787f281bbb..add36d904e564812a06a6ad858237ba1393720d9 100644
--- src/extension/internal/pdfinput/svg-builder.cpp
+++ src/extension/internal/pdfinput/svg-builder.cpp
@@ -1434,7 +1434,7 @@ void SvgBuilder::updateFont(GfxState *state, std::shared_ptr<CairoFont> cairo_fo
     sp_repr_css_set_property(_css_font, "font-variant", "normal");
 
     // Writing mode
-    if ( font->getWMode() == 0 ) {
+    if ( font->getWMode() == _POPPLER_WMODE_HORIZONTAL ) {
         sp_repr_css_set_property(_css_font, "writing-mode", "lr");
     } else {
         sp_repr_css_set_property(_css_font, "writing-mode", "tb");
@@ -1446,7 +1446,7 @@ void SvgBuilder::updateFont(GfxState *state, std::shared_ptr<CairoFont> cairo_fo
  */
 void SvgBuilder::updateTextShift(GfxState *state, double shift) {
     double shift_value = -shift * 0.001 * fabs(state->getFontSize());
-    if (state->getFont()->getWMode()) {
+    if (state->getFont()->getWMode() != _POPPLER_WMODE_HORIZONTAL) {
         _text_position[1] += shift_value;
     } else {
         _text_position[0] += shift_value;
@@ -1500,7 +1500,7 @@ Inkscape::XML::Node* SvgBuilder::_flushTextText(GfxState *state, double text_sca
 
     // Text direction is a property of the <text> element.
     auto font = state->getFont();
-    if (font->getWMode() == 1) {
+    if (font->getWMode() == _POPPLER_WMODE_VERTICAL) {
         // Only set if vertical.
         auto css_text = sp_repr_css_attr_new();
         sp_repr_css_set_property(css_text, "writing-mode", "tb");
@@ -1594,8 +1594,8 @@ Inkscape::XML::Node* SvgBuilder::_flushTextText(GfxState *state, double text_sca
         bool output_tspan =
             next_it == _glyphs.end() ||
             next_it->style_changed   ||
-            (writing_mode == 0 && std::abs(glyph.text_position[1] - next_it->text_position[1]) > 0.1) ||
-            (writing_mode == 1 && std::abs(glyph.text_position[0] - next_it->text_position[0]) > 0.1);
+            (writing_mode == _POPPLER_WMODE_HORIZONTAL && std::abs(glyph.text_position[1] - next_it->text_position[1]) > 0.1) ||
+            (writing_mode == _POPPLER_WMODE_VERTICAL   && std::abs(glyph.text_position[0] - next_it->text_position[0]) > 0.1);
 
         if (output_tspan) {
 
