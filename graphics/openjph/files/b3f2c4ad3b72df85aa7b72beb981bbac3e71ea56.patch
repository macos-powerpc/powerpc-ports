From b3f2c4ad3b72df85aa7b72beb981bbac3e71ea56 Mon Sep 17 00:00:00 2001
From: Aous Naman <aous72@yahoo.com>
Date: Sun, 16 Nov 2025 14:08:37 +0300
Subject: [PATCH] This modifes aligned_alloc code to support a wider range of
 possibilities

---
 src/core/CMakeLists.txt    | 17 +++++++++++++
 src/core/others/ojph_mem.c | 50 ++++++++++++++++++++++++++++++++++++--
 2 files changed, 65 insertions(+), 2 deletions(-)

diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index 3898749..2a2c33f 100644
--- src/core/CMakeLists.txt
+++ src/core/CMakeLists.txt
@@ -139,6 +139,23 @@ set_target_properties(openjph PROPERTIES POSITION_INDEPENDENT_CODE ON)
 target_compile_definitions(openjph PUBLIC _FILE_OFFSET_BITS=64)
 target_include_directories(openjph PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/common> $<INSTALL_INTERFACE:include>)
 
+## Check to see if aligned_alloc or posix_memalign is available
+# We want to the code to compile for C11 and C++11.
+# std::aligned_alloc is only availabe in C++17.
+# So here we try to see what API is available and adapt the code to support it
+if (NOT MSVC)
+  include(CheckSymbolExists)
+  check_symbol_exists(aligned_alloc "stdlib.h" OJPH_ALIGNED_ALLOC_EXISTS)
+  if (OJPH_ALIGNED_ALLOC_EXISTS)
+    target_compile_definitions(openjph PRIVATE OJPH_ALIGNED_ALLOC_EXISTS)
+  else()
+    check_symbol_exists(posix_memalign "stdlib.h" OJPH_POSIX_MEMALIGN_EXISTS)
+    if (OJPH_POSIX_MEMALIGN_EXISTS)
+      target_compile_definitions(openjph PRIVATE OJPH_POSIX_MEMALIGN_EXISTS)
+    endif()
+  endif()
+endif()
+
 if (MSVC)
   set(OJPH_LIB_NAME_STRING "openjph.${OPENJPH_VERSION_MAJOR}.${OPENJPH_VERSION_MINOR}")
   set_target_properties(openjph
diff --git a/src/core/others/ojph_mem.c b/src/core/others/ojph_mem.c
index 7fa1ada..f88dc11 100644
--- src/core/others/ojph_mem.c
+++ src/core/others/ojph_mem.c
@@ -35,7 +35,9 @@
 // Date: 17 October 2025
 //***************************************************************************/
 
+#include <assert.h>
 #include <stdlib.h>
+#include <stdint.h>
 
 ////////////////////////////////////////////////////////////////////////////////
 // OS detection definitions for C only
@@ -59,10 +61,11 @@
 #define OJPH_EXPORT
 #endif
 
-////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////
 #ifdef OJPH_OS_WINDOWS
   OJPH_EXPORT void* ojph_aligned_malloc(size_t alignment, size_t size)
   {
+    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
     return _aligned_malloc(size, alignment);
   }
 
@@ -70,9 +73,10 @@
   {
     _aligned_free(pointer);
   }
-#else
+#elif (defined OJPH_ALIGNED_ALLOC_EXISTS)
   void* ojph_aligned_malloc(size_t alignment, size_t size)
   {
+    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
     return aligned_alloc(alignment, size);
   }
 
@@ -80,4 +84,46 @@
   {
     free(pointer);
   }
+#elif (defined OJPH_POSIX_MEMALIGN_EXISTS)
+  void* ojph_aligned_malloc(size_t alignment, size_t size)
+  {
+    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
+    void *p = NULL;
+    int e = posix_memalign(&p, alignment, size);
+    return (e ? NULL : p);
+  }
+
+  void ojph_aligned_free(void* pointer)
+  {
+    free(pointer);
+  }
+#else
+  void* ojph_aligned_malloc(size_t alignment, size_t size)
+  {
+    assert(alignment != 0 && (alignment & (alignment - 1)) == 0);
+
+    // emulate aligned_alloc
+    void* orig_ptr = malloc(size + alignment + sizeof(void*));
+    if (orig_ptr == NULL)
+      return NULL; // Allocation failed
+
+    uintptr_t start_of_mem = (uintptr_t)orig_ptr + sizeof(void*);
+    uintptr_t aligned_addr = (start_of_mem + alignment - 1) & ~(alignment - 1);
+
+    void** ptr_to_orig_ptr = (void**)aligned_addr;
+    ptr_to_orig_ptr[-1] = orig_ptr;
+
+    return (void*)aligned_addr;
+  }
+
+  void ojph_aligned_free(void* pointer)
+  {
+    if (pointer) {
+      // Retrieve the original pointer stored just before aligned pointer
+      void** ptr_to_orig_ptr = (void**)pointer;
+      void* orig_ptr = ptr_to_orig_ptr[-1];
+
+      free(orig_ptr);
+    }
+  }
 #endif
