--- src/gpu_info_util/SystemInfo_macos.mm.orig	2025-11-04 04:08:14.000000000 +0800
+++ src/gpu_info_util/SystemInfo_macos.mm	2025-11-04 03:46:19.000000000 +0800
@@ -14,17 +14,103 @@
 
 #import <Cocoa/Cocoa.h>
 #import <IOKit/IOKitLib.h>
+#include <AvailabilityMacros.h>
+
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 120000
+#    define kIOMainPortDefault kIOMasterPortDefault
+#endif
+
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 101100
+#    define ANGLE_ENABLE_METAL
+#endif
+
+#if ANGLE_ENABLE_METAL
 #import <Metal/Metal.h>
+#endif
 
 #include "common/apple_platform_utils.h"
 
 #if ANGLE_ENABLE_CGL
 #    include "common/gl/cgl/FunctionsCGL.h"
+// We need these:
+#    ifndef kCGLRPRegistryIDLow
+#        define kCGLRPRegistryIDLow ((CGLRendererProperty)140)
+#    endif
+#    ifndef kCGLRPRegistryIDHigh
+#        define kCGLRPRegistryIDHigh ((CGLRendererProperty)141)
+#    endif
 #endif
 
 namespace angle
 {
 
+#if ANGLE_ENABLE_CGL
+// Code from WebKit to query the GPU ID given an OpenGL display mask.
+// https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/mac/PlatformScreenMac.mm
+// Used with permission.
+uint64_t GetGpuIDFromOpenGLDisplayMask(uint32_t displayMask)
+{
+    GLint numRenderers              = 0;
+    CGLRendererInfoObj rendererInfo = nullptr;
+    CGLError error = CGLQueryRendererInfo(displayMask, &rendererInfo, &numRenderers);
+    if (!numRenderers || !rendererInfo || error != kCGLNoError)
+        return 0;
+
+    // The 0th renderer should not be the software renderer.
+    GLint isAccelerated;
+    error = CGLDescribeRenderer(rendererInfo, 0, kCGLRPAccelerated, &isAccelerated);
+    if (!isAccelerated || error != kCGLNoError)
+    {
+        CGLDestroyRendererInfo(rendererInfo);
+        return 0;
+    }
+
+    GLint gpuIDLow  = 0;
+    GLint gpuIDHigh = 0;
+
+    error = CGLDescribeRenderer(rendererInfo, 0, kCGLRPRegistryIDLow, &gpuIDLow);
+    if (error != kCGLNoError)
+    {
+        CGLDestroyRendererInfo(rendererInfo);
+        return 0;
+    }
+
+    error = CGLDescribeRenderer(rendererInfo, 0, kCGLRPRegistryIDHigh, &gpuIDHigh);
+    if (error != kCGLNoError)
+    {
+        CGLDestroyRendererInfo(rendererInfo);
+        return 0;
+    }
+
+    CGLDestroyRendererInfo(rendererInfo);
+    return (static_cast<uint64_t>(static_cast<uint32_t>(gpuIDHigh)) << 32) |
+           static_cast<uint64_t>(static_cast<uint32_t>(gpuIDLow));
+}
+#endif
+
+// Modified code from WebKit to get the active GPU's ID given a Core Graphics display ID.
+// https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/mac/PlatformScreenMac.mm
+// Used with permission.
+uint64_t GetGpuIDFromDisplayID(uint32_t displayID)
+{
+#if ANGLE_ENABLE_METAL
+    // First attempt to use query the registryID from a Metal device before falling back to CGL.
+    // This avoids loading the OpenGL framework when possible.
+    id<MTLDevice> device = CGDirectDisplayCopyCurrentMetalDevice(displayID);
+    if (device)
+    {
+        uint64_t registryId = [device registryID];
+        [device release];
+        return registryId;
+    }
+#endif
+#if ANGLE_ENABLE_CGL
+    return GetGpuIDFromOpenGLDisplayMask(CGDisplayIDToOpenGLDisplayMask(displayID));
+#else
+    return 0;
+#endif
+}
+
 namespace
 {
 
@@ -191,71 +277,7 @@
 
 }  // anonymous namespace
 
-// Modified code from WebKit to get the active GPU's ID given a Core Graphics display ID.
-// https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/mac/PlatformScreenMac.mm
-// Used with permission.
-uint64_t GetGpuIDFromDisplayID(uint32_t displayID)
-{
-    // First attempt to use query the registryID from a Metal device before falling back to CGL.
-    // This avoids loading the OpenGL framework when possible.
-    id<MTLDevice> device = CGDirectDisplayCopyCurrentMetalDevice(displayID);
-    if (device)
-    {
-        uint64_t registryId = [device registryID];
-        [device release];
-        return registryId;
-    }
-#if ANGLE_ENABLE_CGL
-    return GetGpuIDFromOpenGLDisplayMask(CGDisplayIDToOpenGLDisplayMask(displayID));
-#else
-    return 0;
-#endif
-}
-
-#if ANGLE_ENABLE_CGL
-// Code from WebKit to query the GPU ID given an OpenGL display mask.
-// https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/mac/PlatformScreenMac.mm
-// Used with permission.
-uint64_t GetGpuIDFromOpenGLDisplayMask(uint32_t displayMask)
-{
-    GLint numRenderers              = 0;
-    CGLRendererInfoObj rendererInfo = nullptr;
-    CGLError error = CGLQueryRendererInfo(displayMask, &rendererInfo, &numRenderers);
-    if (!numRenderers || !rendererInfo || error != kCGLNoError)
-        return 0;
-
-    // The 0th renderer should not be the software renderer.
-    GLint isAccelerated;
-    error = CGLDescribeRenderer(rendererInfo, 0, kCGLRPAccelerated, &isAccelerated);
-    if (!isAccelerated || error != kCGLNoError)
-    {
-        CGLDestroyRendererInfo(rendererInfo);
-        return 0;
-    }
-
-    GLint gpuIDLow  = 0;
-    GLint gpuIDHigh = 0;
-
-    error = CGLDescribeRenderer(rendererInfo, 0, kCGLRPRegistryIDLow, &gpuIDLow);
-    if (error != kCGLNoError)
-    {
-        CGLDestroyRendererInfo(rendererInfo);
-        return 0;
-    }
-
-    error = CGLDescribeRenderer(rendererInfo, 0, kCGLRPRegistryIDHigh, &gpuIDHigh);
-    if (error != kCGLNoError)
-    {
-        CGLDestroyRendererInfo(rendererInfo);
-        return 0;
-    }
-
-    CGLDestroyRendererInfo(rendererInfo);
-    return (static_cast<uint64_t>(static_cast<uint32_t>(gpuIDHigh)) << 32) |
-           static_cast<uint64_t>(static_cast<uint32_t>(gpuIDLow));
-}
-#endif
-
+#if ANGLE_ENABLE_METAL
 // Get VendorID from metal device's registry ID
 VendorID GetVendorIDFromMetalDeviceRegistryID(uint64_t registryID)
 {
@@ -297,9 +319,11 @@
 
     return vendorId;
 }
+#endif
 
 bool GetSystemInfo_mac(SystemInfo *info)
 {
+#if defined(ANGLE_PLATFORM_MACOS) || defined(ANGLE_PLATFORM_MACCATALYST)
     {
         std::string fullMachineModel;
         if (GetMacosMachineModel(&fullMachineModel))
@@ -310,6 +334,7 @@
             info->machineModelVersion = std::to_string(major) + "." + std::to_string(minor);
         }
     }
+#endif
 
     GetIORegistryDevices(&info->gpus);
     if (info->gpus.empty())
