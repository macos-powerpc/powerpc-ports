--- testing/test.gni.orig	2025-09-29 14:44:53.000000000 +0800
+++ testing/test.gni	2025-11-03 22:15:07.000000000 +0800
@@ -11,7 +11,6 @@
 import("//build/config/devtools.gni")
 import("//build/config/gclient_args.gni")
 import("//build/config/rts.gni")
-import("//build/rust/rust_static_library.gni")
 import("//build_overrides/build.gni")
 
 declare_args() {

--- build/config/BUILDCONFIG.gn.orig	2025-09-27 12:42:34.000000000 +0800
+++ build/config/BUILDCONFIG.gn	2025-11-03 22:28:25.000000000 +0800
@@ -368,8 +368,6 @@
   "//build/config/compiler:thin_archive",
   "//build/config/compiler:thinlto_optimize_default",
   "//build/config/compiler:tot_warnings",
-  "//build/config/coverage:default_coverage",
-  "//build/config/sanitizers:default_sanitizer_flags",
   "//build/config:feature_flags",
 ]
 
--- build/config/BUILD.gn.orig	2025-09-27 12:42:34.000000000 +0800
+++ build/config/BUILD.gn	2025-11-03 22:27:19.000000000 +0800
@@ -16,8 +16,6 @@
 import("//build/config/mac/mac_sdk_overrides.gni")
 
 import("//build/config/pch.gni")
-import("//build/config/rust.gni")
-import("//build/config/sanitizers/sanitizers.gni")
 import("//build/config/ui.gni")
 if (is_android) {
   import("//build/config/android/abi.gni")

--- build/config/c++/modules.gni.orig	2025-09-27 12:42:34.000000000 +0800
+++ build/config/c++/modules.gni	2025-11-03 22:32:25.000000000 +0800
@@ -24,16 +24,7 @@
   # ChromeOS uses the linux sysroot.
   module_platform = "linux-${current_cpu}"
 } else if (is_fuchsia || is_mac) {
-  # Currently, these generate the same sysroot for all architectures. This is
-  # not inherently the case. If we start getting errors on one architecture
-  # but not the other, we will revert back to one modulemap per cpu.
-  assert(
-         # This *should* work for other cpu architectures. This assertion is
-         # here so that the chrome build team is not caught unaware by a failure
-         # on an architecture we didn't even know we were supporting.
-         current_cpu == "x64" || current_cpu == "arm64",
-         "Please inform the chrome build team that you received this error")
-  module_platform = "${current_os}-x64"
+  module_platform = "${current_os}-${current_cpu}"
 }
 
 if (clang_modules_platform_supported && use_autogenerated_modules) {

--- build/toolchain/apple/toolchain.gni.orig	2025-10-27 10:09:40.000000000 +0800
+++ build/toolchain/apple/toolchain.gni	2025-11-04 02:53:03.000000000 +0800
@@ -10,7 +10,6 @@
 import("//build/config/clang/clang.gni")
 import("//build/config/compiler/compiler.gni")
 import("//build/config/coverage/coverage.gni")
-import("//build/config/rust.gni")
 import("//build/toolchain/cc_wrapper.gni")
 import("//build/toolchain/rbe.gni")
 import("//build/toolchain/toolchain.gni")
@@ -255,151 +254,6 @@
       _unstripped_output = "{{root_out_dir}}/{{target_output_name}}{{output_extension}}.unstripped"
     }
 
-    if (toolchain_has_rust) {
-      if (!defined(rust_compiler_prefix)) {
-        rust_compiler_prefix = ""
-      }
-      rust_sysroot_relative = rebase_path(rust_sysroot, root_build_dir)
-      rustc_bin = "$rust_sysroot_relative/bin/rustc"
-      rustc = "$rust_compiler_prefix${rustc_bin}"
-      rustc_wrapper =
-          rebase_path("//build/rust/gni_impl/rustc_wrapper.py", root_build_dir)
-
-      tool("rust_staticlib") {
-        libname = "{{output_dir}}/{{target_output_name}}{{output_extension}}"
-        rspfile = "$libname.rsp"
-        depfile = "$libname.d"
-
-        default_output_extension = ".a"
-        output_prefix = "lib"
-
-        # Static libraries go in the target out directory by default so we can
-        # generate different targets with the same name and not have them
-        # collide.
-        default_output_dir = "{{target_out_dir}}"
-        description = "RUST(STATICLIB) {{output}}"
-        outputs = [ libname ]
-
-        # TODO(danakj): When `!toolchain_uses_lld` do we need to specify a path
-        # to libtool like the "alink" rule?
-
-        rspfile_content = "{{rustdeps}} {{externs}} SOURCES {{sources}}"
-        command = "\"$python_path\" \"$rustc_wrapper\" --rustc=$rustc --depfile=$depfile --rsp=$rspfile -- -Clinker=\"$_cxx\" $rustc_common_args --emit=dep-info=$depfile,link -o $libname LDFLAGS RUSTENV {{rustenv}}"
-        rust_sysroot = rust_sysroot_relative
-      }
-
-      tool("rust_rlib") {
-        # We must always prefix with `lib` even if the library already starts
-        # with that prefix or else our stdlib is unable to find libc.rlib (or
-        # actually liblibc.rlib).
-        rlibname =
-            "{{output_dir}}/lib{{target_output_name}}{{output_extension}}"
-        rspfile = "$rlibname.rsp"
-        depfile = "$rlibname.d"
-
-        default_output_extension = ".rlib"
-
-        # This is prefixed unconditionally in `rlibname`.
-        # output_prefix = "lib"
-
-        # Static libraries go in the target out directory by default so we can
-        # generate different targets with the same name and not have them
-        # collide.
-        default_output_dir = "{{target_out_dir}}"
-        description = "RUST {{output}}"
-        outputs = [ rlibname ]
-
-        rspfile_content = "{{rustdeps}} {{externs}} SOURCES {{sources}}"
-        command = "\"$python_path\" \"$rustc_wrapper\" --rustc=$rustc --depfile=$depfile --rsp=$rspfile -- -Clinker=\"$_cxx\" $rustc_common_args {{rustdeps}} {{externs}} --emit=dep-info=$depfile,link -o $rlibname LDFLAGS RUSTENV {{rustenv}}"
-        rust_sysroot = rust_sysroot_relative
-      }
-
-      tool("rust_bin") {
-        exename = "{{output_dir}}/{{target_output_name}}{{output_extension}}"
-        rspfile = "$exename.rsp"
-        depfile = "$exename.d"
-        pool = "//build/toolchain:link_pool($default_toolchain)"
-
-        # TODO(danakj): solink can generate TOC files for re-exporting library
-        # symbols, and we should do the same here.
-
-        default_output_dir = "{{root_out_dir}}"
-        description = "RUST(BIN) {{output}}"
-        outputs = [ exename ]
-
-        # TODO(danakj): Support dsym_switch like C++ targets.
-        # link_command += dsym_switch
-        # if (_enable_dsyms) {
-        #   outputs += dsym_output
-        # }
-        # if (_save_unstripped_output) {
-        #   outputs += [ _unstripped_output ]
-        # }
-
-        rspfile_content = "{{rustdeps}} {{externs}} SOURCES {{sources}}"
-        command = "$linker_driver_env \"$python_path\" \"$rustc_wrapper\" --rustc=$rustc --depfile=$depfile --rsp=$rspfile -- -Clinker=\"$linker_driver\" $rustc_common_args --emit=dep-info=$depfile,link -o $exename LDFLAGS $linker_driver_args {{ldflags}} RUSTENV {{rustenv}}"
-        rust_sysroot = rust_sysroot_relative
-      }
-
-      tool("rust_cdylib") {
-        dllname = "{{output_dir}}/{{target_output_name}}{{output_extension}}"
-        rspfile = "$dllname.rsp"
-        depfile = "$dllname.d"
-        pool = "//build/toolchain:link_pool($default_toolchain)"
-
-        # TODO(danakj): solink can generate TOC files for re-exporting library
-        # symbols, and we should do the same here.
-
-        default_output_extension = ".dylib"
-        output_prefix = "lib"
-        default_output_dir = "{{root_out_dir}}"
-        description = "RUST(CDYLIB) {{output}}"
-        outputs = [ dllname ]
-
-        # TODO(danakj): Support dsym_switch like C++ targets.
-        # link_command += dsym_switch
-        # if (_enable_dsyms) {
-        #   outputs += dsym_output
-        # }
-        # if (_save_unstripped_output) {
-        #   outputs += [ _unstripped_output ]
-        # }
-
-        rspfile_content = "{{rustdeps}} {{externs}} SOURCES {{sources}}"
-        command = "$linker_driver_env \"$python_path\" \"$rustc_wrapper\" --rustc=$rustc --depfile=$depfile --rsp=$rspfile -- -Clinker=\"$linker_driver\" $rustc_common_args --emit=dep-info=$depfile,link -o $dllname LDFLAGS $linker_driver_args {{ldflags}} RUSTENV {{rustenv}}"
-        rust_sysroot = rust_sysroot_relative
-      }
-
-      tool("rust_macro") {
-        dllname = "{{output_dir}}/{{target_output_name}}{{output_extension}}"
-        rspfile = "$dllname.rsp"
-        depfile = "$dllname.d"
-        pool = "//build/toolchain:link_pool($default_toolchain)"
-
-        # TODO(danakj): solink can generate TOC files for re-exporting library
-        # symbols, and we should do the same here.
-
-        default_output_extension = ".dylib"
-        output_prefix = "lib"
-        default_output_dir = "{{root_out_dir}}"
-        description = "RUST(MACRO) {{output}}"
-        outputs = [ dllname ]
-
-        # TODO(danakj): Support dsym_switch like C++ targets.
-        # link_command += dsym_switch
-        # if (_enable_dsyms) {
-        #   outputs += dsym_output
-        # }
-        # if (_save_unstripped_output) {
-        #   outputs += [ _unstripped_output ]
-        # }
-
-        rspfile_content = "{{rustdeps}} {{externs}} SOURCES {{sources}}"
-        command = "\"$python_path\" \"$rustc_wrapper\" --rustc=$rustc --depfile=$depfile --rsp=$rspfile -- -Clinker=\"${_cxx}\" $rustc_common_args --emit=dep-info=$depfile,link -o $dllname LDFLAGS {{ldflags}} RUSTENV {{rustenv}}"
-        rust_sysroot = rust_sysroot_relative
-      }
-    }
-
     tool("cc") {
       depfile = "{{output}}.d"
       precompiled_header_type = "gcc"
@@ -467,7 +321,7 @@
 
         # Specify explicit path for libtool.
         libtool = invoker.bin_path + "libtool"
-        command = "rm -f {{output}} && TOOL_VERSION=${tool_versions.filter_libtool} $python_path $script $libtool -static -D {{arflags}} -o {{output}} @$rspfile"
+        command = "rm -f {{output}} && TOOL_VERSION=${tool_versions.filter_libtool} $python_path $script $libtool -static {{arflags}} -o {{output}} @$rspfile"
         description = "LIBTOOL-STATIC {{output}}"
       } else {
         ar = "${prefix}llvm-ar"

--- build/config/compiler/BUILD.gn.orig	2025-10-27 10:09:40.000000000 +0800
+++ build/config/compiler/BUILD.gn	2025-11-04 00:54:53.000000000 +0800
@@ -16,7 +16,6 @@
 import("//build/config/gclient_args.gni")
 import("//build/config/host_byteorder.gni")
 import("//build/config/pch.gni")
-import("//build/config/rust.gni")
 import("//build/config/ui.gni")
 import("//build/config/unwind.gni")
 import("//build/toolchain/rbe.gni")
@@ -121,7 +120,7 @@
   # the space overhead is too great. We should use some mixture of profiles and
   # optimization settings to better tune the size increase.
   thin_lto_enable_optimizations =
-      (is_chromeos || is_android || is_win || is_linux || is_mac ||
+      (is_chromeos || is_android || is_win || is_linux ||
        (is_ios && use_lld)) && is_official_build
 
   # Whether to enable thin lto incremental builds.
@@ -345,7 +344,6 @@
   configs += [
     # See the definitions below.
     ":clang_revision",
-    ":rustc_revision",
     ":compiler_cpu_abi",
     ":compiler_codegen",
     ":compiler_deterministic",
@@ -536,6 +534,10 @@
       cflags += [ "-femit-dwarf-unwind=no-compact-unwind" ]
     }
 
+    if (current_cpu == "ppc" || current_cpu == "ppc64") {
+      cflags_cc += [ "-D_GLIBCXX_USE_CXX11_ABI=0" ]
+    }
+
     # dsymutil is not available in the system, on bots, for rustc to call. Our
     # linker_driver.py script runs dsymutil itself, which is set to be the
     # linker for Rust targets as well.
@@ -1145,9 +1147,6 @@
     # sequences, ignoring the platform, when stderr is not a terminal.
     rustflags += [ "--color=always" ]
   }
-  if (rust_abi_target != "") {
-    rustflags += [ "--target=$rust_abi_target" ]
-  }
   if (!use_thin_lto || !toolchain_supports_rust_thin_lto) {
     # Don't include bitcode if it won't be used.
     rustflags += [ "-Cembed-bitcode=no" ]
@@ -1160,24 +1159,6 @@
   if (is_official_build) {
     rustflags += [ "-Ccodegen-units=1" ]
   }
-  if (!rust_prebuilt_stdlib) {
-    # When building against the Chromium Rust stdlib (which we compile) always
-    # abort instead of unwinding when panic occurs. In official builds, panics
-    # abort immediately (this is configured in the stdlib) to keep binary size
-    # down. So we unconditionally match behaviour in unofficial too.
-    if (is_official_build) {
-      rustflags += [
-        "-Zunstable-options",
-        "-Cpanic=immediate-abort",
-        "-Zpanic_abort_tests",
-      ]
-    } else {
-      rustflags += [
-        "-Cpanic=abort",
-        "-Zpanic_abort_tests",
-      ]
-    }
-  }
 
   # crbug.com/397463803: Set this until CrOS' user enumeration is done; its
   # `lld` will complain otherwise. Should be removable by Q4 2025.
@@ -1794,26 +1775,6 @@
           "clang_revision=\"$_clang_revision\" but clang_version=\"$clang_version\". clang_version in build/toolchain/toolchain.gni is likely outdated.")
     }
 
-    if (toolchain_has_rust && _perform_consistency_checks &&
-        !rust_force_head_revision) {
-      # Ensure that the synced rust version matches what's in git.
-      _rust_revision_lines =
-          filter_include(read_file("//tools/rust/update_rust.py", "list lines"),
-                         [ "RUST_*REVISION = *" ])
-      _py_revision =
-          string_replace(_rust_revision_lines[0], "RUST_REVISION = '", "")
-      _py_revision = string_replace(_py_revision, "'", "")
-      _py_subrevision =
-          string_replace(_rust_revision_lines[1], "RUST_SUB_REVISION = ", "")
-      _expected_rust_revision = "$_py_revision-$_py_subrevision"
-
-      # Ensure the rust version matches the clang version.
-      assert(
-          filter_include([ rustc_revision ],
-                         [ "*-$_expected_rust_revision-*" ]) != [],
-          "rustc_revision=\"$rustc_revision\" but update_rust.py expected \"$_expected_rust_revision\". Run \"gclient sync\"?")
-    }
-
     # This is here so that all files get recompiled after a clang roll and
     # when turning clang on or off. (defines are passed via the command line,
     # and build system rebuild things when their commandline changes). Nothing
@@ -1865,18 +1826,6 @@
   }
 }
 
-config("rustc_revision") {
-  if (rustc_revision != "") {
-    # Similar to the above config, this is here so that all files get recompiled
-    # after a rustc roll. Nothing should ever read this cfg. This will not be
-    # set if a custom toolchain is used.
-    rustflags = [
-      "--cfg",
-      "cr_rustc_revision=\"$rustc_revision\"",
-    ]
-  }
-}
-
 config("compiler_arm_fpu") {
   if (current_cpu == "arm" && !is_ios) {
     cflags = [ "-mfpu=$arm_fpu" ]
@@ -2073,7 +2022,7 @@
       cflags += [ "/wd4244" ]
     }
   } else {
-    if (is_apple || is_android) {
+    if (is_android) {
       # Warns if a method is used whose availability is newer than the
       # deployment target.
       cflags += [ "-Wunguarded-availability" ]
@@ -2342,14 +2291,9 @@
       defines += [ "_FORTIFY_SOURCE=" + fortify_level ]
     }
 
-    if (is_apple) {
-      cflags_objc = [ "-Wimplicit-retain-self" ]
-      cflags_objcc = [ "-Wimplicit-retain-self" ]
-    }
-
-    if (is_mac) {
-      cflags_objc += [ "-Wobjc-missing-property-synthesis" ]
-      cflags_objcc += [ "-Wobjc-missing-property-synthesis" ]
+    if (is_clang) {
+      cflags_objc = [ "-Wimplicit-retain-self", "-Wobjc-missing-property-synthesis" ]
+      cflags_objcc = [ "-Wimplicit-retain-self", "-Wobjc-missing-property-synthesis" ]
     }
 
     if (is_ios) {
--- build/toolchain/mac/BUILD.gn.orig	2025-09-27 12:42:34.000000000 +0800
+++ build/toolchain/mac/BUILD.gn	2025-11-03 22:58:53.000000000 +0800
@@ -76,6 +76,18 @@
   }
 }
 
+mac_toolchain("clang_ppc") {
+  toolchain_args = {
+    current_cpu = "ppc"
+  }
+}
+
+mac_toolchain("clang_ppc64") {
+  toolchain_args = {
+    current_cpu = "ppc64"
+  }
+}
+
 mac_toolchain("clang_x86_v8_arm") {
   toolchain_args = {
     current_cpu = "x86"

--- build/config/mac/BUILD.gn.orig	2025-09-27 12:42:34.000000000 +0800
+++ build/config/mac/BUILD.gn	2025-11-03 23:47:51.000000000 +0800
@@ -22,10 +22,14 @@
     clang_arch = "i386"
   } else if (current_cpu == "arm64") {
     clang_arch = current_cpu
+  } else if (current_cpu == "ppc64") {
+    clang_arch = current_cpu
+  } else if (current_cpu == "ppc") {
+    clang_arch = current_cpu
   } else {
     assert(false, "unknown current_cpu $current_cpu")
   }
-  common_mac_flags += [ "--target=$clang_arch-apple-macos" ]
+  common_mac_flags += [ "-arch", "$clang_arch" ]
 
   # This is here so that all files get recompiled after an Xcode update.
   # (defines are passed via the command line, and build system rebuild things
@@ -41,7 +45,7 @@
   # macOS 13+ when targeting x86_64.
   # ld64.lld currently defaults to it on macOS 13+.
   # Force it on; for Chromium it should work on macOS 12 even on x86_64.
-  ldflags += [ "-Wl,-fixup_chains" ]
+  # ldflags += [ "-Wl,-fixup_chains" ]
 
   if (save_unstripped_output) {
     ldflags += [ "-Wcrl,unstripped," + rebase_path(root_out_dir) ]
@@ -60,7 +64,7 @@
   common_flags = [
     "-isysroot",
     rebase_path(sysroot, root_build_dir),
-    "-mmacos-version-min=$mac_deployment_target",
+    "-mmacosx-version-min=$mac_deployment_target",
   ]
 
   asmflags = common_flags
