From 26897a9840c65356db3feaf66f92dffc00017a34 Mon Sep 17 00:00:00 2001
From: Sergey Fedorov <vital.had@gmail.com>
Date: Wed, 8 Oct 2025 05:31:33 +0800
Subject: [PATCH] Restore GL < 3 support

Do not error out on GL 2.0

Revert breakage from https://github.com/haasn/libplacebo/commit/173afc91cc4de5adfa93d6047338d9f86c73734b

Restore capability checks

Reverts breaking https://github.com/haasn/libplacebo/commit/5a8c9dd9d571d67b2ef7380ca478b57e1650e492

Handle textureLod instances for GL 2.x compat

Revert multiple breakages, restore support for GL 2.x

Deals with breakages from the following commits:
https://github.com/haasn/libplacebo/commit/e2fd6fd2d3c87773c658b1f3da2b778d94520469
https://github.com/haasn/libplacebo/commit/0b79d97488c8923c0b60c0c4af9de68eb135ac46
https://github.com/haasn/libplacebo/commit/a9c6614c2c2326b09ffd5384eb7f74a6be4dd9ac
---
 demos/ui.c                    |   9 ++-
 src/dispatch.c                |  47 ++++++++-----
 src/gpu/utils.c               |   7 +-
 src/opengl/context.c          |   2 +-
 src/opengl/formats.c          |   4 ++
 src/opengl/gpu.c              |  11 +++-
 src/opengl/gpu.h              |   3 +
 src/opengl/gpu_tex.c          |  38 +++++++----
 src/renderer.c                |  47 ++++++-------
 src/shaders.c                 | 105 +++++++++++++++++++++++------
 src/shaders.h                 |  36 ++++++++++
 src/shaders/colorspace.c      | 121 +++++++++++++++++++++-------------
 src/shaders/custom_mpv.c      |  18 +++--
 src/shaders/deinterlacing.c   |   9 ++-
 src/shaders/dithering.c       |  12 +++-
 src/shaders/film_grain_av1.c  |   5 ++
 src/shaders/film_grain_h274.c |   2 +-
 src/shaders/lut.c             |   7 +-
 src/shaders/sampling.c        |  66 ++++++++++---------
 19 files changed, 377 insertions(+), 172 deletions(-)

diff --git a/demos/ui.c b/demos/ui.c
index 6cdc7c6e8..6ea0cdb9b 100644
--- a/demos/ui.c
+++ b/demos/ui.c
@@ -158,9 +158,14 @@ bool ui_draw(struct ui *ui, const struct pl_swapchain_frame *frame)
             continue;
 
         pl_shader sh = pl_dispatch_begin(ui->dp);
+
+        const char *tex_fn = sh_glsl(sh).version >= 130 ? "textureLod" : "texture2DLod";
+        char *shader_body;
+        asprintf(&shader_body, "color = %s(ui_tex, coord, 0.0).r * vcolor;", tex_fn);
+
         pl_shader_custom(sh, &(struct pl_custom_shader) {
             .description = "nuklear UI",
-            .body = "color = textureLod(ui_tex, coord, 0.0).r * vcolor;",
+            .body = shader_body,
             .output = PL_SHADER_SIG_COLOR,
             .num_descriptors = 1,
             .descriptors = &(struct pl_shader_desc) {
@@ -175,6 +180,8 @@ bool ui_draw(struct ui *ui, const struct pl_swapchain_frame *frame)
             },
         });
 
+        free(shader_body);
+
         struct pl_color_repr repr = frame->color_repr;
         pl_shader_color_map_ex(sh, NULL, pl_color_map_args(
             .src = pl_color_space_srgb,
diff --git a/src/dispatch.c b/src/dispatch.c
index a593f256b..35ca491dd 100644
--- a/src/dispatch.c
+++ b/src/dispatch.c
@@ -507,7 +507,7 @@ static void generate_shaders(pl_dispatch dp,
                 } else {
                     ADD(pre, "layout(binding=%d) ", desc->binding);
                 }
-            } else if (format) {
+            } else if (gpu->glsl.version >= 130 && format) {
                 ADD(pre, "layout(%s) ", format);
             }
 
@@ -563,7 +563,7 @@ static void generate_shaders(pl_dispatch dp,
                 } else {
                     ADD(pre, "layout(binding=%d) ", desc->binding);
                 }
-            } else if (format) {
+            } else if (gpu->glsl.version >= 130 && format) {
                 ADD(pre, "layout(%s) ", format);
             }
 
@@ -593,9 +593,14 @@ static void generate_shaders(pl_dispatch dp,
         add_var(pre, var);
     }
 
+    char *vert_in  = gpu->glsl.version >= 130 ? "in" : "attribute";
+    char *vert_out = gpu->glsl.version >= 130 ? "out" : "varying";
+    char *frag_in  = gpu->glsl.version >= 130 ? "in" : "varying";
+
     pl_str_builder glsl = dp->tmp[TMP_MAIN];
     ADD_CAT(glsl, pre);
 
+    const char *out_color = "gl_FragColor";
     switch(pass_params->type) {
     case PL_PASS_RASTER: {
         pl_assert(params->vert_idx >= 0);
@@ -618,10 +623,10 @@ static void generate_shaders(pl_dispatch dp,
             ident_t id = sh_ident_unpack(sva->attr.name);
 
             if (has_loc) {
-                ADD(vert_head, "layout(location=%d) in %s "$";\n",
-                    va->location, type, sh_ident_unpack(va->name));
+                ADD(vert_head, "layout(location=%d) %s %s "$";\n",
+                    va->location, vert_in, type, sh_ident_unpack(va->name));
             } else {
-                ADD(vert_head, "in %s "$";\n", type, sh_ident_unpack(va->name));
+                ADD(vert_head, "%s %s "$";\n", vert_in, type, sh_ident_unpack(va->name));
             }
 
             if (i == params->vert_idx) {
@@ -635,13 +640,13 @@ static void generate_shaders(pl_dispatch dp,
             } else {
                 // Everything else is just blindly passed through
                 if (has_loc) {
-                    ADD(vert_head, "layout(location=%d) out %s "$";\n",
-                        va->location, type, id);
-                    ADD(glsl, "layout(location=%d) in %s "$";\n",
-                        va->location, type, id);
+                    ADD(vert_head, "layout(location=%d) %s %s "$";\n",
+                        va->location, vert_out, type, id);
+                    ADD(glsl, "layout(location=%d) %s %s "$";\n",
+                        va->location, frag_in, type, id);
                 } else {
-                    ADD(vert_head, "out %s "$";\n", type, id);
-                    ADD(glsl, "in %s "$";\n", type, id);
+                    ADD(vert_head, "%s %s "$";\n", vert_out, type, id);
+                    ADD(glsl, "%s %s "$";\n", frag_in, type, id);
                 }
                 ADD(vert_body, $" = "$";\n", id, sh_ident_unpack(va->name));
             }
@@ -652,10 +657,14 @@ static void generate_shaders(pl_dispatch dp,
         pl_hash_merge(&pass->signature, pl_str_builder_hash(vert_head));
         *out_vert_builder = vert_head;
 
-        if (has_loc) {
-            ADD(glsl, "layout(location=0) out vec4 out_color;\n");
-        } else {
-            ADD(glsl, "out vec4 out_color;\n");
+        // GLSL 130+ doesn't use the magic gl_FragColor
+        if (gpu->glsl.version >= 130) {
+            out_color = "out_color";
+            if (has_loc) {
+                ADD(glsl, "layout(location=0) out vec4 out_color;\n");
+            } else {
+                ADD(glsl, "out vec4 out_color;\n");
+            }
         }
         break;
     }
@@ -676,7 +685,11 @@ static void generate_shaders(pl_dispatch dp,
     switch (pass_params->type) {
     case PL_PASS_RASTER:
         pl_assert(sh->output == PL_SHADER_SIG_COLOR);
-        ADD(glsl, "out_color = "$"();\n", sh->name);
+        if (gpu->glsl.version >= 130) {
+            ADD(glsl, "out_color = "$"();\n", sh->name);
+        } else {
+            ADD(glsl, "gl_FragColor = "$"();\n", sh->name);
+        }
         break;
     case PL_PASS_COMPUTE:
         ADD(glsl, $"();\n", sh->name);
@@ -684,7 +697,7 @@ static void generate_shaders(pl_dispatch dp,
     case PL_PASS_INVALID:
     case PL_PASS_TYPE_COUNT:
         pl_unreachable();
-    }
+}
 
     ADD(glsl, "}");
 
diff --git a/src/gpu/utils.c b/src/gpu/utils.c
index c42e04f3d..1a1aedc5b 100644
--- a/src/gpu/utils.c
+++ b/src/gpu/utils.c
@@ -979,8 +979,8 @@ bool pl_tex_blit_compute(pl_gpu gpu, const struct pl_tex_blit_params *params)
                  (float) src_rc.z1 / params->src->params.d);
         }
 
-        GLSL("imageStore("$", dst_pos, textureLod("$", src_pos, 0.0)); \n",
-             dst, src);
+        GLSL("imageStore("$", dst_pos, %s("$", src_pos, 0.0)); \n",
+             dst, sh_tex_lod_fn(sh, params->src->params), src);
 
     } else {
 
@@ -1053,7 +1053,8 @@ void pl_tex_blit_raster(pl_gpu gpu, const struct pl_tex_blit_params *params)
     ident_t pos, src = sh_bind(sh, params->src, PL_TEX_ADDRESS_CLAMP,
         params->sample_mode, "src_tex", &src_rc, &pos, NULL);
 
-    GLSL("vec4 color = textureLod("$", "$", 0.0); \n", src, pos);
+    GLSL("vec4 color = %s("$", "$", 0.0); \n", 
+         sh_tex_lod_fn(sh, params->src->params), src, pos);
 
     pl_dispatch_finish(dp, pl_dispatch_params(
         .shader = &sh,
diff --git a/src/opengl/context.c b/src/opengl/context.c
index 6ca14b8ee..c4fdfd804 100644
--- a/src/opengl/context.c
+++ b/src/opengl/context.c
@@ -196,7 +196,7 @@ pl_opengl pl_opengl_create(pl_log log, const struct pl_opengl_params *params)
         goto error;
     }
 
-    static const int gl_ver_req = 3;
+    static const int gl_ver_req = 2;
     if (pl_gl->major < gl_ver_req) {
         PL_FATAL(p, "OpenGL version too old (%d < %d), please use a newer "
                  "OpenGL implementation or downgrade libplacebo!",
diff --git a/src/opengl/formats.c b/src/opengl/formats.c
index 941544480..e2e6dd22a 100644
--- a/src/opengl/formats.c
+++ b/src/opengl/formats.c
@@ -372,6 +372,10 @@ static void add_format(pl_gpu pgpu, const struct gl_format *gl_fmt)
     if (fmt->caps & PL_FMT_CAP_SAMPLEABLE)
         fmt->gatherable = p->gather_comps >= fmt->num_components;
 
+    // Mask renderable/blittable if no FBOs available
+    if (!p->has_fbos)
+        fmt->caps &= ~(PL_FMT_CAP_RENDERABLE | PL_FMT_CAP_BLITTABLE);
+
     bool host_readable = false;
     if (p->gl_ver && p->has_readback)
         host_readable = true;
diff --git a/src/opengl/gpu.c b/src/opengl/gpu.c
index a515943f4..2fa1e570d 100644
--- a/src/opengl/gpu.c
+++ b/src/opengl/gpu.c
@@ -144,7 +144,7 @@ pl_gpu pl_gpu_create_gl(pl_log log, pl_opengl pl_gl, const struct pl_opengl_para
         }
     }
 
-    static const int glsl_ver_req = 130;
+    static const int glsl_ver_req = 110;
     if (glsl->version < glsl_ver_req) {
         PL_FATAL(gpu, "GLSL version too old (%d < %d), please use a newer "
                  "OpenGL implementation or downgrade libplacebo!",
@@ -241,12 +241,15 @@ pl_gpu pl_gpu_create_gl(pl_log log, pl_opengl pl_gl, const struct pl_opengl_para
     }
 
     // Cache some internal capability checks
+    p->has_stride = gl_test_ext(gpu, "GL_EXT_unpack_subimage", 11, 30);
+    p->has_unpack_image_height = p->gl_ver >= 12 || p->gles_ver >= 30;
     p->has_vao = gl_test_ext(gpu, "GL_ARB_vertex_array_object", 30, 30);
     p->has_invalidate_fb = gl_test_ext(gpu, "GL_ARB_invalidate_subdata", 43, 30);
     p->has_invalidate_tex = gl_test_ext(gpu, "GL_ARB_invalidate_subdata", 43, 0);
     p->has_queries = gl_test_ext(gpu, "GL_ARB_timer_query", 30, 0);
+    p->has_fbos = gl_test_ext(gpu, "GL_ARB_framebuffer_object", 30, 20);
     p->has_storage = gl_test_ext(gpu, "GL_ARB_shader_image_load_store", 42, 31);
-    p->has_readback = true;
+    p->has_readback = p->has_fbos;
 
     if (p->has_readback && p->gles_ver) {
         GLuint fbo = 0, tex = 0;
@@ -277,9 +280,11 @@ pl_gpu pl_gpu_create_gl(pl_log log, pl_opengl pl_gl, const struct pl_opengl_para
 
     // We simply don't know, so make up some values
     limits->align_tex_xfer_offset = 32;
-    limits->align_tex_xfer_pitch = 4;
+    limits->align_tex_xfer_pitch = 1;
     limits->fragment_queues = 1;
     limits->compute_queues = glsl->compute ? 1 : 0;
+    if (gl_test_ext(gpu, "GL_EXT_unpack_subimage", 11, 30))
+        limits->align_tex_xfer_pitch = 4;
 
     if (!gl_check_err(gpu, "pl_gpu_create_gl")) {
         PL_WARN(gpu, "Encountered errors while detecting GPU capabilities... "
diff --git a/src/opengl/gpu.h b/src/opengl/gpu.h
index 3681f30bf..2ac3aac59 100644
--- a/src/opengl/gpu.h
+++ b/src/opengl/gpu.h
@@ -50,7 +50,10 @@ struct pl_gl {
     // Cached capabilities
     int gl_ver;
     int gles_ver;
+    bool has_fbos;
     bool has_storage;
+    bool has_stride;
+    bool has_unpack_image_height;
     bool has_invalidate_fb;
     bool has_invalidate_tex;
     bool has_vao;
diff --git a/src/opengl/gpu_tex.c b/src/opengl/gpu_tex.c
index ca488ee23..07babbefb 100644
--- a/src/opengl/gpu_tex.c
+++ b/src/opengl/gpu_tex.c
@@ -921,15 +921,22 @@ bool gl_tex_upload(pl_gpu gpu, const struct pl_tex_transfer_params *params)
         gl->PixelStorei(GL_UNPACK_ALIGNMENT, get_alignment(params->row_pitch));
 
     int rows = pl_rect_h(params->rc);
-    if (misaligned) {
-        rows = 1;
-    } else if (stride_w != pl_rect_w(params->rc)) {
-        gl->PixelStorei(GL_UNPACK_ROW_LENGTH, stride_w);
+    if (stride_w != pl_rect_w(params->rc) || misaligned) {
+        if (p->has_stride && !misaligned) {
+            gl->PixelStorei(GL_UNPACK_ROW_LENGTH, stride_w);
+        } else {
+            rows = 1;
+        }
     }
 
     int imgs = pl_rect_d(params->rc);
-    if (stride_h != pl_rect_h(params->rc) || rows < stride_h)
-        gl->PixelStorei(GL_UNPACK_IMAGE_HEIGHT, stride_h);
+    if (stride_h != pl_rect_h(params->rc) || rows < stride_h) {
+        if (p->has_unpack_image_height) {
+            gl->PixelStorei(GL_UNPACK_IMAGE_HEIGHT, stride_h);
+        } else {
+            imgs = 1;
+        }
+    }
 
     gl->BindTexture(tex_gl->target, tex_gl->texture);
     gl_timer_begin(gpu, params->timer);
@@ -964,8 +971,10 @@ bool gl_tex_upload(pl_gpu gpu, const struct pl_tex_transfer_params *params)
     gl_timer_end(gpu, params->timer);
     gl->BindTexture(tex_gl->target, 0);
     gl->PixelStorei(GL_UNPACK_ALIGNMENT, 4);
-    gl->PixelStorei(GL_UNPACK_ROW_LENGTH, 0);
-    gl->PixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0);
+    if (p->has_stride)
+        gl->PixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+    if (p->has_unpack_image_height)
+        gl->PixelStorei(GL_UNPACK_IMAGE_HEIGHT, 0);
 
     if (buf) {
         gl->BindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
@@ -1043,10 +1052,12 @@ bool gl_tex_download(pl_gpu gpu, const struct pl_tex_transfer_params *params)
             gl->PixelStorei(GL_PACK_ALIGNMENT, get_alignment(params->row_pitch));
 
         int rows = pl_rect_h(params->rc);
-        if (misaligned) {
-            rows = 1;
-        } else if (stride_w != tex->params.w) {
-            gl->PixelStorei(GL_PACK_ROW_LENGTH, stride_w);
+        if (stride_w != tex->params.w || misaligned) {
+            if (p->has_stride && !misaligned) {
+                gl->PixelStorei(GL_PACK_ROW_LENGTH, stride_w);
+            } else {
+                rows = 1;
+            }
         }
 
         // No 3D framebuffers
@@ -1063,7 +1074,8 @@ bool gl_tex_download(pl_gpu gpu, const struct pl_tex_transfer_params *params)
         }
         gl->BindFramebuffer(target, 0);
         gl->PixelStorei(GL_PACK_ALIGNMENT, 4);
-        gl->PixelStorei(GL_PACK_ROW_LENGTH, 0);
+        if (p->has_stride)
+            gl->PixelStorei(GL_PACK_ROW_LENGTH, 0);
     } else if (is_copy) {
         // We're downloading the entire texture
         gl->BindTexture(tex_gl->target, tex_gl->texture);
diff --git a/src/renderer.c b/src/renderer.c
index f3df0c661..6f86802bd 100644
--- a/src/renderer.c
+++ b/src/renderer.c
@@ -945,7 +945,8 @@ static void draw_overlays(struct pass_state *pass, pl_tex fbo,
 
         switch (ol.mode) {
         case PL_OVERLAY_NORMAL:
-            GLSL("vec4 color = textureLod("$", coord, 0.0); \n", tex);
+            GLSL("vec4 color = %s("$", coord, 0.0); \n",
+                 sh_tex_lod_fn(sh, ol.tex->params), tex);
             break;
         case PL_OVERLAY_MONOCHROME:
             GLSL("vec4 color = osd_color; \n");
@@ -971,8 +972,8 @@ static void draw_overlays(struct pass_state *pass, pl_tex fbo,
         bool premul = repr.alpha == PL_ALPHA_PREMULTIPLIED;
         pl_shader_encode_color(sh, &repr);
         if (ol.mode == PL_OVERLAY_MONOCHROME) {
-            GLSL("color.%s *= textureLod("$", coord, 0.0).r; \n",
-                 premul ? "rgba" : "a", tex);
+            GLSL("color.%s *= %s("$", coord, 0.0).r; \n",
+                 premul ? "rgba" : "a", sh_tex_lod_fn(sh, ol.tex->params), tex);
         }
 
         swizzle_color(sh, comps, comp_map, true);
@@ -2370,16 +2371,15 @@ static pl_tex pass_blur(struct pass_state *pass, pl_tex src_tex, int comps,
         if (!tex)
             goto error;
 
-
     #pragma GLSL /* pass_blur */                                                \
         vec4 color;                                                             \
         {                                                                       \
             vec2 step = vec2(${float: offset / w}, ${float: offset / h});       \
-            color  = textureLod($tex, $pos, 0.0) * 4.0;                         \
-            color += textureLod($tex, $pos - step, 0.0);                        \
-            color += textureLod($tex, $pos + step, 0.0);                        \
-            color += textureLod($tex, $pos - vec2(step.x, -step.y), 0.0);       \
-            color += textureLod($tex, $pos + vec2(step.x, -step.y), 0.0);       \
+            color  = ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos, 0.0) * 4.0;                         \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos - step, 0.0);                        \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + step, 0.0);                        \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos - vec2(step.x, -step.y), 0.0);       \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + vec2(step.x, -step.y), 0.0);       \
             color /= 8.0;                                                       \
         }
 
@@ -2413,14 +2413,14 @@ static pl_tex pass_blur(struct pass_state *pass, pl_tex src_tex, int comps,
         {                                                                       \
             vec2 step = vec2(${float: offset / w}, ${float: offset / h});       \
             vec2 step2 = step + step;                                           \
-            color  = textureLod($tex, $pos - vec2(step2.x, 0.0), 0.0);          \
-            color += textureLod($tex, $pos + vec2(step2.x, 0.0), 0.0);          \
-            color += textureLod($tex, $pos - vec2(0.0, step2.y), 0.0);          \
-            color += textureLod($tex, $pos + vec2(0.0, step2.y), 0.0);          \
-            color += textureLod($tex, $pos + vec2(-step.x, -step.y), 0.0) * 2.0;\
-            color += textureLod($tex, $pos + vec2( step.x, -step.y), 0.0) * 2.0;\
-            color += textureLod($tex, $pos + vec2(-step.x,  step.y), 0.0) * 2.0;\
-            color += textureLod($tex, $pos + vec2( step.x,  step.y), 0.0) * 2.0;\
+            color  = ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos - vec2(step2.x, 0.0), 0.0);          \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + vec2(step2.x, 0.0), 0.0);          \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos - vec2(0.0, step2.y), 0.0);          \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + vec2(0.0, step2.y), 0.0);          \
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + vec2(-step.x, -step.y), 0.0) * 2.0;\
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + vec2( step.x, -step.y), 0.0) * 2.0;\
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + vec2(-step.x,  step.y), 0.0) * 2.0;\
+            color += ${sh_tex_lod_fn(sh, prev->params)}($tex, $pos + vec2( step.x,  step.y), 0.0) * 2.0;\
             color /= 12.0;                                                      \
         }
 
@@ -2564,9 +2564,9 @@ static void clear_target(pl_renderer rr, const struct pl_frame *target,
                 },
             });
 
-            GLSL("vec4 color = textureLod("$", coord, 0.0); \n"
+            GLSL("vec4 color = %s("$", coord, 0.0); \n"
                  "color.%s *= vec%d(1.0 / "$"); \n",
-                 tex,
+                 sh_tex_lod_fn(sh, background->params), tex,
                  params->blend_params ? "rgb" : "rgba",
                  params->blend_params ? 3 : 4,
                  SH_FLOAT(bg_scale));
@@ -2752,12 +2752,13 @@ static bool pass_output_target(struct pass_state *pass)
             }
 
             GLSL("vec2 outcoord = gl_FragCoord.xy * "$";                    \n"
-                 "bvec2 tile = lessThan(fract(outcoord), vec2(0.5));        \n"
+                 "%s tile = lessThan(fract(outcoord), vec2(0.5));           \n"
                  "vec3 tile_color = tile.x == tile.y ? vec3("$", "$", "$")  \n"
                  "                                   : vec3("$", "$", "$"); \n"
                  "color.rgb += (1.0 - color.a) * tile_color;                \n"
                  "color.a = 1.0;                                            \n",
                  SH_FLOAT(1.0 / PL_DEF(params->tile_size, pl_render_default_params.tile_size)),
+                 sh_bvec(sh, 2),
                  SH_FLOAT(color[0][0]), SH_FLOAT(color[0][1]), SH_FLOAT(color[0][2]),
                  SH_FLOAT(color[1][0]), SH_FLOAT(color[1][1]), SH_FLOAT(color[1][2]));
             img->repr.alpha = PL_ALPHA_NONE;
@@ -3978,7 +3979,8 @@ bool pl_render_image_mix(pl_renderer rr, const struct pl_frame_mix *images,
         ident_t pos, tex = sh_bind(sh, frames[i].tex, PL_TEX_ADDRESS_CLAMP,
                                    sample_mode, "frame", NULL, &pos, NULL);
 
-        GLSL("color = textureLod("$", "$", 0.0); \n", tex, pos);
+        GLSL("color = %s("$", "$", 0.0); \n", 
+             sh_tex_lod_fn(sh, frames[i].tex->params), tex, pos);
 
         // Note: This ignores differences in ICC profile, which we decide to
         // just simply not care about. Doing that properly would require
@@ -4162,11 +4164,12 @@ void pl_frame_clear_tiles(pl_gpu gpu, const struct pl_frame *frame,
         GLSL("// pl_frame_clear_tiles (plane %d)                    \n"
              "vec4 color;                                           \n"
              "vec2 outcoord = gl_FragCoord.xy * vec2("$", "$");     \n"
-             "bvec2 tile = lessThan(fract(outcoord), vec2(0.5));    \n"
+             "%s tile = lessThan(fract(outcoord), vec2(0.5));       \n"
              "color.rgb = tile.x == tile.y ? vec3("$", "$", "$")    \n"
              "                             : vec3("$", "$", "$");   \n"
              "color.a = 1.0;                                        \n",
              p, SH_FLOAT(1.0 / size_x), SH_FLOAT(1.0 / size_y),
+             sh_bvec(sh, 2),
              SH_FLOAT(tiles[0][0]), SH_FLOAT(tiles[0][1]), SH_FLOAT(tiles[0][2]),
              SH_FLOAT(tiles[1][0]), SH_FLOAT(tiles[1][1]), SH_FLOAT(tiles[1][2]));
 
diff --git a/src/shaders.c b/src/shaders.c
index 73e03ec83..6cbeade41 100644
--- a/src/shaders.c
+++ b/src/shaders.c
@@ -92,8 +92,8 @@ static void init_shader(pl_shader sh, const struct pl_shader_params *params)
 
 pl_shader pl_shader_alloc(pl_log log, const struct pl_shader_params *params)
 {
-    static const int glsl_ver_req = 130;
-    if (params && params->glsl.version && params->glsl.version < 130) {
+    static const int glsl_ver_req = 110;
+    if (params && params->glsl.version && params->glsl.version < glsl_ver_req) {
         pl_err(log, "Requested GLSL version %d too low (required: %d)",
                params->glsl.version, glsl_ver_req);
         return NULL;
@@ -959,26 +959,69 @@ ident_t sh_prng(pl_shader sh, bool temporal, ident_t *p_state)
     ident_t randfun = sh_fresh(sh, "rand"),
             state = sh_fresh(sh, "state");
 
-    // Based on pcg3d (http://jcgt.org/published/0009/03/02/)
-    GLSLP("#define prng_t uvec3\n");
-    GLSLH("vec3 "$"(inout uvec3 s) {                    \n"
-          "    s = 1664525u * s + uvec3(1013904223u);   \n"
-          "    s.x += s.y * s.z;                        \n"
-          "    s.y += s.z * s.x;                        \n"
-          "    s.z += s.x * s.y;                        \n"
-          "    s ^= s >> 16u;                           \n"
-          "    s.x += s.y * s.z;                        \n"
-          "    s.y += s.z * s.x;                        \n"
-          "    s.z += s.x * s.y;                        \n"
-          "    return vec3(s) * 1.0/float(0xFFFFFFFFu); \n"
-          "}                                            \n",
-          randfun);
-
-    if (temporal) {
-        GLSL("uvec3 "$" = uvec3(gl_FragCoord.xy, "$"); \n",
-             state, SH_UINT_DYN(SH_PARAMS(sh).index));
+    if (sh_glsl(sh).version >= 130) {
+
+        // Based on pcg3d (http://jcgt.org/published/0009/03/02/)
+        GLSLP("#define prng_t uvec3\n");
+        GLSLH("vec3 %s(inout uvec3 s) {                     \n"
+              "    s = 1664525u * s + uvec3(1013904223u);   \n"
+              "    s.x += s.y * s.z;                        \n"
+              "    s.y += s.z * s.x;                        \n"
+              "    s.z += s.x * s.y;                        \n"
+              "    s ^= s >> 16u;                           \n"
+              "    s.x += s.y * s.z;                        \n"
+              "    s.y += s.z * s.x;                        \n"
+              "    s.z += s.x * s.y;                        \n"
+              "    return vec3(s) * 1.0/float(0xFFFFFFFFu); \n"
+              "}                                            \n",
+              randfun);
+
+        const char *seed = "0u";
+        if (temporal) {
+            seed = sh_var(sh, (struct pl_shader_var) {
+                .var  = pl_var_uint("seed"),
+                .data = &(unsigned int){ SH_PARAMS(sh).index },
+                .dynamic = true,
+            });
+        };
+
+        GLSL("uvec3 %s = uvec3(gl_FragCoord.xy, %s); \n", state, seed);
+
     } else {
-        GLSL("uvec3 "$" = uvec3(gl_FragCoord.xy, 0.0); \n", state);
+
+        // Based on SGGP (https://briansharpe.wordpress.com/2011/10/01/gpu-texture-free-noise/)
+        ident_t permute = sh_fresh(sh, "permute");
+        GLSLP("#define prng_t float\n");
+        GLSLH("float %s(float x) {                          \n"
+              "    x = (34.0 * x + 1.0) * x;                \n"
+              "    return fract(x * 1.0/289.0) * 289.0;     \n"
+              "}                                            \n"
+              "vec3 %s(inout float s) {                     \n"
+              "    vec3 ret;                                \n"
+              "    ret.x = %s(s);                           \n"
+              "    ret.y = %s(ret.x);                       \n"
+              "    ret.z = %s(ret.y);                       \n"
+              "    s = ret.z;                               \n"
+              "    return fract(ret * 1.0/41.0);            \n"
+              "}                                            \n",
+              permute, randfun, permute, permute, permute);
+
+        static const double phi = 1.618033988749895;
+        const char *seed = "0.0";
+        if (temporal) {
+            seed = sh_var(sh, (struct pl_shader_var) {
+                .var  = pl_var_float("seed"),
+                .data = &(float){ modff(phi * SH_PARAMS(sh).index, &(float){0}) },
+                .dynamic = true,
+            });
+        };
+
+        GLSL("vec3 %s_m = vec3(fract(gl_FragCoord.xy * vec2(%f)), %s);  \n"
+             "%s_m += vec3(1.0);                                        \n"
+             "float %s = %s(%s(%s(%s_m.x) + %s_m.y) + %s_m.z);          \n",
+             state, phi, seed,
+             state,
+             state, permute, permute, permute, state, state, state);
     }
 
     if (p_state)
@@ -988,3 +1031,23 @@ ident_t sh_prng(pl_shader sh, bool temporal, ident_t *p_state)
     GLSLH("#define "$" ("$"("$"))\n", res, randfun, state);
     return res;
 }
+
+const char *sh_bvec(const pl_shader sh, int dims)
+{
+    static const char *bvecs[] = {
+        [1] = "bool",
+        [2] = "bvec2",
+        [3] = "bvec3",
+        [4] = "bvec4",
+    };
+
+    static const char *vecs[] = {
+        [1] = "float",
+        [2] = "vec2",
+        [3] = "vec3",
+        [4] = "vec4",
+    };
+
+    pl_assert(dims > 0 && dims < PL_ARRAY_SIZE(bvecs));
+    return sh_glsl(sh).version >= 130 ? bvecs[dims] : vecs[dims];
+}
diff --git a/src/shaders.h b/src/shaders.h
index bfa96d120..71f07537d 100644
--- a/src/shaders.h
+++ b/src/shaders.h
@@ -357,6 +357,42 @@ struct sh_lut_params {
 // gets interpolated and clamped as needed. Returns NULL on error.
 ident_t sh_lut(pl_shader sh, const struct sh_lut_params *params);
 
+// Returns a GLSL-version appropriate "bvec"-like type. For GLSL 130+, this
+// returns bvecN. For GLSL 120, this returns vecN instead. The intended use of
+// this function is with mix(), which only accepts bvec in GLSL 130+.
+const char *sh_bvec(const pl_shader sh, int dims);
+
+// Returns the appropriate `textureLod`-equivalent function for the shader and
+// given texture.
+static inline const char *sh_tex_lod_fn(const pl_shader sh,
+                                        const struct pl_tex_params params)
+{
+    static const char *suffixed[] = {
+        [1] = "texture1DLod",
+        [2] = "texture2DLod", 
+        [3] = "texture3DLod",
+    };
+
+    int dims = pl_tex_params_dimension(params);
+    return sh_glsl(sh).version >= 130 ? "textureLod" : suffixed[dims];
+}
+
+// Not used at the moment, but retained for compat.
+// Returns the appropriate `texture`-equivalent function for the shader and
+// given texture.
+static inline const char *sh_tex_fn(const pl_shader sh,
+                                    const struct pl_tex_params params)
+{
+    static const char *suffixed[] = {
+        [1] = "texture1D",
+        [2] = "texture2D",
+        [3] = "texture3D",
+    };
+
+    int dims = pl_tex_params_dimension(params);
+    return sh_glsl(sh).version >= 130 ? "texture" : suffixed[dims];
+}
+
 static inline uint8_t sh_num_comps(uint8_t mask)
 {
     pl_assert((mask & 0xF) == mask);
diff --git a/src/shaders/colorspace.c b/src/shaders/colorspace.c
index 16e8ad744..ac314c18f 100644
--- a/src/shaders/colorspace.c
+++ b/src/shaders/colorspace.c
@@ -52,6 +52,11 @@ void pl_shader_set_alpha(pl_shader sh, struct pl_color_repr *repr,
 static inline void reshape_mmr(pl_shader sh, ident_t mmr, bool single,
                                int min_order, int max_order)
 {
+    if (sh_glsl(sh).version < 130) {
+        SH_FAIL(sh, "MMR reshaping requires GLSL 130+");
+        return;
+    }
+
     if (single) {
         GLSL("const int mmr_idx = 0; \n");
     } else {
@@ -320,11 +325,12 @@ void pl_shader_decode_color(pl_shader sh, struct pl_color_repr *repr,
         // as per the BT.2020 specification, table 4. This is a non-linear
         // transformation because (constant) luminance receives non-equal
         // contributions from the three different channels.
-        GLSL("// constant luminance conversion                              \n"
-             "color.br = color.br * mix(vec2(1.5816, 0.9936),               \n"
-             "                          vec2(1.9404, 1.7184),               \n"
-             "                          lessThanEqual(color.br, vec2(0.0))) \n"
-             "           + color.gg;                                        \n");
+        GLSL("// constant luminance conversion                                  \n"
+             "color.br = color.br * mix(vec2(1.5816, 0.9936),                   \n"
+             "                          vec2(1.9404, 1.7184),                   \n"
+             "                          %s(lessThanEqual(color.br, vec2(0.0)))) \n"
+             "           + color.gg;                                            \n",
+             sh_bvec(sh, 2));
         // Expand channels to camera-linear light. This shader currently just
         // assumes everything uses the BT.2020 12-bit gamma function, since the
         // difference between 10 and 12-bit is negligible for anything other
@@ -332,13 +338,15 @@ void pl_shader_decode_color(pl_shader sh, struct pl_color_repr *repr,
         GLSL("vec3 lin = mix(color.rgb * vec3(1.0/4.5),                        \n"
              "                pow((color.rgb + vec3(0.0993))*vec3(1.0/1.0993), \n"
              "                    vec3(1.0/0.45)),                             \n"
-             "                lessThanEqual(vec3(0.08145), color.rgb));        \n");
+             "                %s(lessThanEqual(vec3(0.08145), color.rgb)));    \n",
+             sh_bvec(sh, 3));
         // Calculate the green channel from the expanded RYcB, and recompress to G'
         // The BT.2020 specification says Yc = 0.2627*R + 0.6780*G + 0.0593*B
         GLSL("color.g = (lin.g - 0.2627*lin.r - 0.0593*lin.b)*1.0/0.6780;   \n"
              "color.g = mix(color.g * 4.5,                                  \n"
              "              1.0993 * pow(color.g, 0.45) - 0.0993,           \n"
-             "              0.0181 <= color.g);                             \n");
+             "              %s(0.0181 <= color.g));                         \n",
+             sh_bvec(sh, 1));
         break;
 
     case PL_COLOR_SYSTEM_BT_2100_PQ:;
@@ -376,7 +384,7 @@ void pl_shader_decode_color(pl_shader sh, struct pl_color_repr *repr,
              "color.rgb = mix(vec3(4.0) * color.rgb * color.rgb,                \n"
              "                exp((color.rgb - vec3(%f)) * vec3(1.0/%f))        \n"
              "                    + vec3(%f),                                   \n"
-             "                lessThan(vec3(0.5), color.rgb));                  \n"
+             "                %s(lessThan(vec3(0.5), color.rgb)));              \n"
              // LMS matrix
              "color.rgb = mat3( 3.43661, -0.79133, -0.0259499,                  \n"
              "                 -2.50645,  1.98360, -0.0989137,                  \n"
@@ -384,9 +392,9 @@ void pl_shader_decode_color(pl_shader sh, struct pl_color_repr *repr,
             // HLG OETF
              "color.rgb = mix(vec3(0.5) * sqrt(color.rgb),                      \n"
              "                vec3(%f) * log(color.rgb - vec3(%f)) + vec3(%f),  \n"
-             "                lessThan(vec3(1.0), color.rgb));                  \n",
-             HLG_C, HLG_A, HLG_B,
-             HLG_A, HLG_B, HLG_C);
+             "                %s(lessThan(vec3(1.0), color.rgb)));              \n",
+             HLG_C, HLG_A, HLG_B, sh_bvec(sh, 3),
+             HLG_A, HLG_B, HLG_C, sh_bvec(sh, 3));
         break;
 
     case PL_COLOR_SYSTEM_DOLBYVISION:;
@@ -475,19 +483,22 @@ void pl_shader_encode_color(pl_shader sh, const struct pl_color_repr *repr)
         GLSL("vec3 lin = mix(color.rgb * vec3(1.0/4.5),                        \n"
              "                pow((color.rgb + vec3(0.0993))*vec3(1.0/1.0993), \n"
              "                    vec3(1.0/0.45)),                             \n"
-             "                lessThanEqual(vec3(0.08145), color.rgb));        \n");
+             "                %s(lessThanEqual(vec3(0.08145), color.rgb)));    \n",
+             sh_bvec(sh, 3));
 
         // Compute Yc from RGB and compress to R'Y'cB'
         GLSL("color.g = dot(vec3(0.2627, 0.6780, 0.0593), lin);     \n"
              "color.g = mix(color.g * 4.5,                          \n"
              "              1.0993 * pow(color.g, 0.45) - 0.0993,   \n"
-             "              0.0181 <= color.g);                     \n");
+             "              %s(0.0181 <= color.g));                 \n",
+             sh_bvec(sh, 1));
 
         // Compute C'bc and C'rc into color.br
         GLSL("color.br = color.br - color.gg;                       \n"
              "color.br *= mix(vec2(1.0/1.5816, 1.0/0.9936),         \n"
              "                vec2(1.0/1.9404, 1.0/1.7184),         \n"
-             "                lessThanEqual(color.br, vec2(0.0)));  \n");
+             "                %s(lessThanEqual(color.br, vec2(0.0))));  \n",
+             sh_bvec(sh, 2));
         break;
 
     case PL_COLOR_SYSTEM_BT_2100_PQ:;
@@ -507,18 +518,20 @@ void pl_shader_encode_color(pl_shader sh, const struct pl_color_repr *repr)
         break;
 
     case PL_COLOR_SYSTEM_BT_2100_HLG:
-        GLSL("color.rgb = mix(vec3(4.0) * color.rgb * color.rgb,                \n"
-             "                exp((color.rgb - vec3(%f)) * vec3(1.0/%f))        \n"
-             "                    + vec3(%f),                                   \n"
-             "                lessThan(vec3(0.5), color.rgb));                  \n"
-             "color.rgb = mat3(0.412109, 0.166748, 0.024170,                    \n"
-             "                 0.523925, 0.720459, 0.075440,                    \n"
-             "                 0.063965, 0.112793, 0.900394) * color.rgb;       \n"
-             "color.rgb = mix(vec3(0.5) * sqrt(color.rgb),                      \n"
-             "                vec3(%f) * log(color.rgb - vec3(%f)) + vec3(%f),  \n"
-             "                lessThan(vec3(1.0), color.rgb));                  \n",
-             HLG_C, HLG_A, HLG_B,
-             HLG_A, HLG_B, HLG_C);
+        GLSL("color.rgb = mix(vec3(4.0) * color.rgb * color.rgb,         \n"
+             "                exp((color.rgb - vec3(%f)) * vec3(1.0/%f)) \n"
+             "                    + vec3(%f),                            \n"
+             "                %s(lessThan(vec3(0.5), color.rgb)));       \n",
+             HLG_C, HLG_A, HLG_B, sh_bvec(sh, 3));
+        // LMS matrix
+        GLSL("color.rgb = mat3( 3.43661, -0.79133, -0.0259499,           \n"
+             "                 -2.50645,  1.98360, -0.0989137,           \n"
+             "                  0.06984, -0.192271, 1.12486) * color.rgb;\n");
+        // HLG OETF
+        GLSL("color.rgb = mix(vec3(0.5) * sqrt(color.rgb),                     \n"
+             "                vec3(%f) * log(color.rgb - vec3(%f)) + vec3(%f), \n"
+             "                %s(lessThan(vec3(1.0), color.rgb)));             \n",
+             HLG_A, HLG_B, HLG_C, sh_bvec(sh, 3));
         break;
 
     case PL_COLOR_SYSTEM_DOLBYVISION:
@@ -612,7 +625,8 @@ void pl_shader_linearize(pl_shader sh, const struct pl_color_space *csp)
         GLSL("color.rgb = mix(color.rgb * vec3(1.0/12.92),               \n"
              "                pow((color.rgb + vec3(0.055))/vec3(1.055), \n"
              "                    vec3(2.4)),                            \n"
-             "                lessThan(vec3(0.04045), color.rgb));       \n");
+             "                %s(lessThan(vec3(0.04045), color.rgb)));   \n",
+             sh_bvec(sh, 3));
         goto scale_out;
     case PL_COLOR_TRC_BT_1886: {
         const float lb = powf(csp_min, 1/2.4f);
@@ -645,7 +659,8 @@ void pl_shader_linearize(pl_shader sh, const struct pl_color_space *csp)
     case PL_COLOR_TRC_PRO_PHOTO:
         GLSL("color.rgb = mix(color.rgb * vec3(1.0/16.0),              \n"
              "                pow(color.rgb, vec3(1.8)),               \n"
-             "                lessThan(vec3(0.03125), color.rgb));     \n");
+             "                %s(lessThan(vec3(0.03125), color.rgb))); \n",
+             sh_bvec(sh, 3));
         goto scale_out;
     case PL_COLOR_TRC_ST428:
         GLSL("color.rgb = vec3(52.37/48.0) * pow(color.rgb, vec3(2.6));\n");
@@ -668,9 +683,9 @@ void pl_shader_linearize(pl_shader sh, const struct pl_color_space *csp)
              "color.rgb = mix(vec3(4.0) * color.rgb * color.rgb,        \n"
              "                exp((color.rgb - vec3(%f)) * vec3(1.0/%f))\n"
              "                    + vec3(%f),                           \n"
-             "                lessThan(vec3(0.5), color.rgb));          \n",
+             "                %s(lessThan(vec3(0.5), color.rgb)));      \n",
              SH_FLOAT(1 - b), SH_FLOAT(b),
-             HLG_C, HLG_A, HLG_B);
+             HLG_C, HLG_A, HLG_B, sh_bvec(sh, 3));
         // OOTF
         GLSL("color.rgb *= 1.0 / 12.0;                                      \n"
              "color.rgb *= "$" * pow(max(dot("$", color.rgb), 0.0), "$");   \n",
@@ -681,8 +696,8 @@ void pl_shader_linearize(pl_shader sh, const struct pl_color_space *csp)
         GLSL("color.rgb = mix((color.rgb - vec3(0.125)) * vec3(1.0/5.6), \n"
              "    pow(vec3(10.0), (color.rgb - vec3(%f)) * vec3(1.0/%f)) \n"
              "              - vec3(%f),                                  \n"
-             "    lessThanEqual(vec3(0.181), color.rgb));                \n",
-             VLOG_D, VLOG_C, VLOG_B);
+             "    %s(lessThanEqual(vec3(0.181), color.rgb)));            \n",
+             VLOG_D, VLOG_C, VLOG_B, sh_bvec(sh, 3));
         return;
     case PL_COLOR_TRC_S_LOG1:
         GLSL("color.rgb = pow(vec3(10.0), (color.rgb - vec3(%f)) * vec3(1.0/%f)) \n"
@@ -693,8 +708,9 @@ void pl_shader_linearize(pl_shader sh, const struct pl_color_space *csp)
         GLSL("color.rgb = mix((color.rgb - vec3(%f)) * vec3(1.0/%f),      \n"
              "    (pow(vec3(10.0), (color.rgb - vec3(%f)) * vec3(1.0/%f)) \n"
              "              - vec3(%f)) * vec3(1.0/%f),                   \n"
-             "    lessThanEqual(vec3(%f), color.rgb));                    \n",
-             SLOG_Q, SLOG_P, SLOG_C, SLOG_A, SLOG_B, SLOG_K2, SLOG_Q);
+             "    %s(lessThanEqual(vec3(%f), color.rgb)));                \n",
+             SLOG_Q, SLOG_P, SLOG_C, SLOG_A, SLOG_B, SLOG_K2, sh_bvec(sh, 3),
+             SLOG_Q);
         return;
     case PL_COLOR_TRC_LINEAR:
     case PL_COLOR_TRC_COUNT:
@@ -744,7 +760,8 @@ void pl_shader_delinearize(pl_shader sh, const struct pl_color_space *csp)
         GLSL("color.rgb = mix(color.rgb * vec3(12.92),                        \n"
              "                vec3(1.055) * pow(color.rgb, vec3(1.0/2.4))     \n"
              "                    - vec3(0.055),                              \n"
-             "                lessThanEqual(vec3(0.0031308), color.rgb));     \n");
+             "                %s(lessThanEqual(vec3(0.0031308), color.rgb))); \n",
+             sh_bvec(sh, 3));
         return;
     case PL_COLOR_TRC_BT_1886: {
         const float lb = powf(csp_min, 1/2.4f);
@@ -780,7 +797,8 @@ void pl_shader_delinearize(pl_shader sh, const struct pl_color_space *csp)
     case PL_COLOR_TRC_PRO_PHOTO:
         GLSL("color.rgb = mix(color.rgb * vec3(16.0),                        \n"
              "                pow(color.rgb, vec3(1.0/1.8)),                 \n"
-             "                lessThanEqual(vec3(0.001953), color.rgb));     \n");
+             "                %s(lessThanEqual(vec3(0.001953), color.rgb))); \n",
+             sh_bvec(sh, 3));
         return;
     case PL_COLOR_TRC_PQ:
         GLSL("color.rgb *= vec3(1.0/%f);                         \n"
@@ -800,9 +818,9 @@ void pl_shader_delinearize(pl_shader sh, const struct pl_color_space *csp)
         // OETF
         GLSL("color.rgb = mix(vec3(0.5) * sqrt(color.rgb),                      \n"
              "                vec3(%f) * log(color.rgb - vec3(%f)) + vec3(%f),  \n"
-             "                lessThan(vec3(1.0), color.rgb));                  \n"
+             "                %s(lessThan(vec3(1.0), color.rgb)));              \n"
              "color.rgb = "$" * color.rgb + vec3("$");                          \n",
-             HLG_A, HLG_B, HLG_C,
+             HLG_A, HLG_B, HLG_C, sh_bvec(sh, 3),
              SH_FLOAT(1 / (1 - b)), SH_FLOAT(-b / (1 - b)));
         return;
     }
@@ -810,8 +828,8 @@ void pl_shader_delinearize(pl_shader sh, const struct pl_color_space *csp)
         GLSL("color.rgb = mix(vec3(5.6) * color.rgb + vec3(0.125),       \n"
              "                vec3(%f) * log(color.rgb + vec3(%f))       \n"
              "                    + vec3(%f),                            \n"
-             "                lessThanEqual(vec3(0.01), color.rgb));     \n",
-             VLOG_C / M_LN10, VLOG_B, VLOG_D);
+             "                %s(lessThanEqual(vec3(0.01), color.rgb))); \n",
+             VLOG_C / M_LN10, VLOG_B, VLOG_D, sh_bvec(sh, 3));
         return;
     case PL_COLOR_TRC_S_LOG1:
         GLSL("color.rgb = vec3(%f) * log(color.rgb + vec3(%f)) + vec3(%f);\n",
@@ -821,8 +839,9 @@ void pl_shader_delinearize(pl_shader sh, const struct pl_color_space *csp)
         GLSL("color.rgb = mix(vec3(%f) * color.rgb + vec3(%f),                \n"
              "                vec3(%f) * log(vec3(%f) * color.rgb + vec3(%f)) \n"
              "                    + vec3(%f),                                 \n"
-             "                lessThanEqual(vec3(0.0), color.rgb));           \n",
-             SLOG_P, SLOG_Q, SLOG_A / M_LN10, SLOG_K2, SLOG_B, SLOG_C);
+             "                %s(lessThanEqual(vec3(0.0), color.rgb)));       \n",
+             SLOG_P, SLOG_Q, SLOG_A / M_LN10, SLOG_K2, SLOG_B, SLOG_C,
+             sh_bvec(sh, 3));
         return;
     case PL_COLOR_TRC_LINEAR:
     case PL_COLOR_TRC_COUNT:
@@ -1146,6 +1165,11 @@ bool pl_shader_detect_peak(pl_shader sh, struct pl_color_space csp,
     if (!sh_require(sh, PL_SHADER_SIG_COLOR, 0, 0))
         return false;
 
+    if (sh_glsl(sh).version < 130) { // uint support
+        PL_ERR(sh, "HDR peak detection requires GLSL >= 130!");
+        return false;
+    }
+
     pl_gpu gpu = SH_GPU(sh);
     if (!gpu || gpu->limits.max_ssbo_size < sizeof(struct peak_buf_data)) {
         PL_ERR(sh, "HDR peak detection requires a GPU with support for at "
@@ -1884,11 +1908,11 @@ void pl_shader_color_map_ex(pl_shader sh, const struct pl_color_map_params *para
                  "vec4 h = vec4(w1, w3) / g + inv.xyxy;             \n"
                  "h.xy -= vec2(2.0);                                \n"
                  "vec4 p = lpos.xyxy + lpt.xyxy * h;                \n"
-                 "float l00 = textureLod("$", p.xy, 0.0).r;         \n"
-                 "float l01 = textureLod("$", p.xw, 0.0).r;         \n"
+                 "float l00 = %s("$", p.xy, 0.0).r;                 \n"
+                 "float l01 = %s("$", p.xw, 0.0).r;                 \n"
                  "float l0 = mix(l01, l00, g.y);                    \n"
-                 "float l10 = textureLod("$", p.zy, 0.0).r;         \n"
-                 "float l11 = textureLod("$", p.zw, 0.0).r;         \n"
+                 "float l10 = %s("$", p.zy, 0.0).r;                 \n"
+                 "float l11 = %s("$", p.zw, 0.0).r;                 \n"
                  "float l1 = mix(l11, l10, g.y);                    \n"
                  "float luma = mix(l1, l0, g.x);                    \n"
                  // Mix low-resolution tone mapped image with high-resolution
@@ -1900,7 +1924,10 @@ void pl_shader_color_map_ex(pl_shader sh, const struct pl_color_map_params *para
                  "float sharp = tone_map(lowres) + detail;          \n"
                  "ipt.x = clamp(mix(base, sharp, "$"), "$", "$");   \n",
                  pos, pt, lowres,
-                 lowres, lowres, lowres, lowres,
+                 sh_tex_lod_fn(sh, args->feature_map->params), lowres,
+                 sh_tex_lod_fn(sh, args->feature_map->params), lowres,
+                 sh_tex_lod_fn(sh, args->feature_map->params), lowres,
+                 sh_tex_lod_fn(sh, args->feature_map->params), lowres,
                  SH_FLOAT(params->contrast_recovery),
                  SH_FLOAT(tone.output_min), SH_FLOAT_DYN(tone.output_max));
 
diff --git a/src/shaders/custom_mpv.c b/src/shaders/custom_mpv.c
index 4ef08178b..344a5dac4 100644
--- a/src/shaders/custom_mpv.c
+++ b/src/shaders/custom_mpv.c
@@ -1171,8 +1171,13 @@ static bool bind_pass_tex(pl_shader sh, pl_str name,
     GLSLH("#define %.*s_rot mat2(1.0, 0.0, 0.0, 1.0) \n", PL_STR_FMT(name));
 
     // Sampling function boilerplate
-    GLSLH("#define %.*s_tex(pos) ("$" * vec4(textureLod("$", pos, 0.0))) \n",
-          PL_STR_FMT(name), scale, id);
+    if (sh_glsl(sh).version >= 130) {
+        GLSLH("#define %.*s_tex(pos) (textureLod("$", pos, 0.0)) \n",
+              PL_STR_FMT(name), id);
+        } else {
+        GLSLH("#define %.*s_tex(pos) (texture2DLod("$", pos, 0.0)) \n",
+              PL_STR_FMT(name), id);
+    }
     GLSLH("#define %.*s_texOff(off) (%.*s_tex("$" + "$" * vec2(off))) \n",
           PL_STR_FMT(name), PL_STR_FMT(name), pos, pt);
 
@@ -1313,8 +1318,13 @@ static struct pl_hook_res hook_hook(void *priv, const struct pl_hook_params *par
                     GLSLH("#define %.*s "$" \n", PL_STR_FMT(texname), id);
 
                     if (p->descriptors.elem[j].desc.type == PL_DESC_SAMPLED_TEX) {
-                        GLSLH("#define %.*s_tex(pos) (textureLod("$", pos, 0.0)) \n",
-                              PL_STR_FMT(texname), id);
+                        if (sh_glsl(sh).version >= 130) {
+                            GLSLH("#define %.*s_tex(pos) (textureLod("$", pos, 0.0)) \n",
+                                  PL_STR_FMT(texname), id);
+                        } else {
+                            GLSLH("#define %.*s_tex(pos) (texture2DLod("$", pos, 0.0)) \n",
+                                  PL_STR_FMT(texname), id);
+                        }
                     }
                     goto next_bind;
                 }
diff --git a/src/shaders/deinterlacing.c b/src/shaders/deinterlacing.c
index a2820741a..fa7796959 100644
--- a/src/shaders/deinterlacing.c
+++ b/src/shaders/deinterlacing.c
@@ -27,6 +27,11 @@ void pl_shader_deinterlace(pl_shader sh, const struct pl_deinterlace_source *src
 {
     params = PL_DEF(params, &pl_deinterlace_default_params);
 
+    if (sh_glsl(sh).version < 130) {
+        SH_FAIL(sh, "Deinterlacing requires GLSL >= 130!");
+        return;
+    }
+
     const struct pl_tex_params *texparams = &src->cur.top->params;
     if (!sh_require(sh, PL_SHADER_SIG_NONE, texparams->w, texparams->h))
         return;
@@ -54,11 +59,11 @@ void pl_shader_deinterlace(pl_shader sh, const struct pl_deinterlace_source *src
         return;
 
     GLSL("#define GET(TEX, X, Y)                              \\\n"
-         "    (textureLod(TEX, pos + pt * vec2(X, Y), 0.0).%s)  \n"
+         "    (%s(TEX, pos + pt * vec2(X, Y), 0.0).%s)  \n"
          "vec2 pos = "$";                                       \n"
          "vec2 pt  = "$";                                       \n"
          "T res;                                                \n",
-         swiz, pos, pt);
+         sh_tex_lod_fn(sh, *texparams), swiz, pos, pt);
 
     if (src->field == PL_FIELD_NONE) {
         GLSL("res = GET("$", 0, 0); \n", cur);
diff --git a/src/shaders/dithering.c b/src/shaders/dithering.c
index 4485d1107..c4771f3c5 100644
--- a/src/shaders/dithering.c
+++ b/src/shaders/dithering.c
@@ -129,9 +129,16 @@ void pl_shader_dither(pl_shader sh, int new_depth,
     }
 
     enum pl_dither_method method = params->method;
+    bool can_fixed = sh_glsl(sh).version >= 130;
     ident_t lut = NULL_IDENT;
     int lut_size = 0;
 
+    if (method == PL_DITHER_ORDERED_FIXED && !can_fixed) {
+        PL_WARN(sh, "PL_DITHER_ORDERED_FIXED requires glsl version >= 130."
+                " falling back.");
+        goto fallback;
+    }
+
     if (dither_method_is_lut(method)) {
         if (!dither_state) {
             PL_WARN(sh, "LUT-based dither method specified but no dither state "
@@ -165,7 +172,7 @@ void pl_shader_dither(pl_shader sh, int new_depth,
     goto done;
 
 fallback:
-    method = PL_DITHER_ORDERED_FIXED;
+    method = can_fixed ? PL_DITHER_ORDERED_FIXED : PL_DITHER_WHITE_NOISE;
     // fall through
 
 done: ;
@@ -261,7 +268,8 @@ done: ;
         }
 
         // Mix in the correct ratio corresponding to the offset and bias
-        GLSL("color = mix(low, high, greaterThan(offset, vec4(bias))); \n");
+        GLSL("color = mix(low, high, %s(greaterThan(offset, vec4(bias)))); \n",
+             sh_bvec(sh, 4));
     } else {
         // Approximate each gamma segment as a straight line, this simplifies
         // the process of dithering down to a single scale and (biased) round.
diff --git a/src/shaders/film_grain_av1.c b/src/shaders/film_grain_av1.c
index 3b11ea3ac..da70f84d2 100644
--- a/src/shaders/film_grain_av1.c
+++ b/src/shaders/film_grain_av1.c
@@ -633,6 +633,11 @@ bool pl_shader_fg_av1(pl_shader sh, pl_shader_obj *grain_state,
         return false;
     }
 
+    if (sh_glsl(sh).version < 130) {
+        PL_ERR(sh, "AV1 film grain synthesis requires GLSL >= 130!");
+        return false;
+    }
+
     // Disable generation for unneeded component types
     fg_has_y &= tex_is_y;
     fg_has_u &= tex_is_cb;
diff --git a/src/shaders/film_grain_h274.c b/src/shaders/film_grain_h274.c
index 6d524da4e..3e6b68444 100644
--- a/src/shaders/film_grain_h274.c
+++ b/src/shaders/film_grain_h274.c
@@ -159,7 +159,7 @@ bool pl_shader_fg_h274(pl_shader sh, pl_shader_obj *grain_state,
         GLSL($" = 0; barrier(); \n", group_sum);
     }
 
-    if (!sh_try_compute(sh, 8, 8, false, shmem_req)) {
+    if (!sh_try_compute(sh, 8, 8, false, shmem_req) || glsl.version < 130) {
         SH_FAIL(sh, "H.274 film grain synthesis requires compute shaders!");
         return false;
     }
diff --git a/src/shaders/lut.c b/src/shaders/lut.c
index b0124fccb..d45eba5f2 100644
--- a/src/shaders/lut.c
+++ b/src/shaders/lut.c
@@ -626,13 +626,14 @@ next_dim: ; // `continue` out of the inner loop
             }
         });
 
-        if (is_linear) {
+        bool can_fetch = sh_glsl(sh).version >= 130;
+        if (is_linear || !can_fetch) {
             ident_t pos_macros[PL_ARRAY_SIZE(sizes)] = {0};
             for (int i = 0; i < dims; i++)
                 pos_macros[i] = texel_scale(sh, sizes[i], true);
 
-            GLSLH("#define "$"(pos) (textureLod("$", %s(\\\n",
-                  name, tex, vartypes[PL_VAR_FLOAT][texdim - 1]);
+            GLSLH("#define "$"(pos) (%s("$", %s(\\\n",
+                  name, sh_tex_lod_fn(sh, lut->tex->params), tex, vartypes[PL_VAR_FLOAT][texdim - 1]);
 
             for (int i = 0; i < texdim; i++) {
                 char sep = i == 0 ? ' ' : ',';
diff --git a/src/shaders/sampling.c b/src/shaders/sampling.c
index 1a81d0e37..3efe64e97 100644
--- a/src/shaders/sampling.c
+++ b/src/shaders/sampling.c
@@ -195,8 +195,8 @@ void pl_shader_deband(pl_shader sh, const struct pl_sample_src *src,
          "// pl_shader_deband               \n"
          "{                                 \n"
          "vec2 pos = "$", pt = "$";         \n"
-         "color = textureLod("$", pos, 0.0);\n",
-         pos, pt, tex);
+         "color = %s("$", pos, 0.0);        \n",
+         pos, pt, sh_tex_lod_fn(sh, src_params(src)), tex);
 
     mask &= ~0x8u; // ignore alpha channel
     uint8_t num_comps = sh_num_comps(mask);
@@ -210,10 +210,11 @@ void pl_shader_deband(pl_shader sh, const struct pl_sample_src *src,
     }
 
     GLSL("#define GET(X, Y)                                   \\\n"
-         "    (textureLod("$", pos + pt * vec2(X, Y), 0.0).%s)  \n"
+         "    (%s("$", pos + pt * vec2(X, Y), 0.0).%s)  \n"
          "#define T %s                                          \n",
-         tex, swiz, sh_float_type(mask));
+         sh_tex_lod_fn(sh, src_params(src)), tex, swiz, sh_float_type(mask));
 
+    const char *bvec = sh_bvec(sh, num_comps);
     ident_t prng = sh_prng(sh, true, NULL);
     GLSL("T avg, diff, bound;   \n"
          "T res = color.%s;     \n"
@@ -245,9 +246,9 @@ void pl_shader_deband(pl_shader sh, const struct pl_sample_src *src,
                  threshold, i);
 
             if (num_comps > 1) {
-                GLSL("res = mix(avg, res, greaterThan(diff, bound)); \n");
+                GLSL("res = mix(avg, res, %s(greaterThan(diff, bound))); \n", bvec);
             } else {
-                GLSL("res = mix(avg, res, diff > bound); \n");
+                GLSL("res = mix(avg, res, %s(diff > bound)); \n", bvec);
             }
         }
     }
@@ -282,8 +283,8 @@ bool pl_shader_sample_direct(pl_shader sh, const struct pl_sample_src *src)
         return false;
 
     GLSL("// pl_shader_sample_direct                                  \n"
-         "vec4 color = vec4("$") * vec4(textureLod("$", "$", 0.0));   \n",
-         SH_FLOAT(scale), tex, pos);
+         "vec4 color = vec4("$") * vec4(%s("$", "$", 0.0));           \n",
+         SH_FLOAT(scale), sh_tex_lod_fn(sh, src_params(src)), tex, pos);
     return true;
 }
 
@@ -296,8 +297,8 @@ bool pl_shader_sample_nearest(pl_shader sh, const struct pl_sample_src *src)
 
     sh_describe(sh, "nearest");
     GLSL("// pl_shader_sample_nearest                           \n"
-         "vec4 color = vec4("$") * textureLod("$", "$", 0.0);   \n",
-         SH_FLOAT(scale), tex, pos);
+         "vec4 color = vec4("$") * %s("$", "$", 0.0);           \n",
+         SH_FLOAT(scale), sh_tex_lod_fn(sh, src_params(src)), tex, pos);
     return true;
 }
 
@@ -310,8 +311,8 @@ bool pl_shader_sample_bilinear(pl_shader sh, const struct pl_sample_src *src)
 
     sh_describe(sh, "bilinear");
     GLSL("// pl_shader_sample_bilinear                          \n"
-         "vec4 color = vec4("$") * textureLod("$", "$", 0.0);   \n",
-         SH_FLOAT(scale), tex, pos);
+         "vec4 color = vec4("$") * %s("$", "$", 0.0);           \n",
+         SH_FLOAT(scale), sh_tex_lod_fn(sh, src_params(src)), tex, pos);
     return true;
 }
 
@@ -351,11 +352,11 @@ bool pl_shader_sample_bicubic(pl_shader sh, const struct pl_sample_src *src)
     h.xy -= vec2(2.0);                              \
     /* sample four corners, then interpolate */     \
     vec4 p = pos.xyxy + $pt.xyxy * h;               \
-    vec4 c00 = textureLod($tex, p.xy, 0.0);         \
-    vec4 c01 = textureLod($tex, p.xw, 0.0);         \
+    vec4 c00 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.xy, 0.0);         \
+    vec4 c01 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.xw, 0.0);         \
     vec4 c0 = mix(c01, c00, g.y);                   \
-    vec4 c10 = textureLod($tex, p.zy, 0.0);         \
-    vec4 c11 = textureLod($tex, p.zw, 0.0);         \
+    vec4 c10 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.zy, 0.0);         \
+    vec4 c11 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.zw, 0.0);         \
     vec4 c1 = mix(c11, c10, g.y);                   \
     color = ${float:scale} * mix(c1, c0, g.x);      \
     }
@@ -383,7 +384,7 @@ bool pl_shader_sample_hermite(pl_shader sh, const struct pl_sample_src *src)
     vec2 size = vec2(textureSize($tex, 0));              \
     vec2 frac = fract(pos * size + vec2(0.5));           \
     pos += $pt * (smoothstep(0.0, 1.0, frac) - frac);    \
-    color = ${float:scale} * textureLod($tex, pos, 0.0); \
+    color = ${float:scale} * ${sh_tex_lod_fn(sh, src_params(src))}($tex, pos, 0.0); \
     }
 
     return true;
@@ -421,11 +422,11 @@ bool pl_shader_sample_gaussian(pl_shader sh, const struct pl_sample_src *src)
     g.xy /= g.xy + g.zw; /* explicitly normalize */ \
     /* sample four corners, then interpolate */     \
     vec4 p = pos.xyxy + $pt.xyxy * (h + off.xyxy);  \
-    vec4 c00 = textureLod($tex, p.xy, 0.0);         \
-    vec4 c01 = textureLod($tex, p.xw, 0.0);         \
+    vec4 c00 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.xy, 0.0);         \
+    vec4 c01 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.xw, 0.0);         \
     vec4 c0 = mix(c01, c00, g.y);                   \
-    vec4 c10 = textureLod($tex, p.zy, 0.0);         \
-    vec4 c11 = textureLod($tex, p.zw, 0.0);         \
+    vec4 c10 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.zy, 0.0);         \
+    vec4 c11 = ${sh_tex_lod_fn(sh, src_params(src))}($tex, p.zw, 0.0);         \
     vec4 c1 = mix(c11, c10, g.y);                   \
     color = ${float:scale} * mix(c1, c0, g.x);      \
     }
@@ -464,7 +465,7 @@ bool pl_shader_sample_oversample(pl_shader sh, const struct pl_sample_src *src,
                                                          \
     /* Compute the right output blend of colors */       \
     pos += (coeff - fcoord) * $pt;                       \
-    color = ${float:scale} * textureLod($tex, pos, 0.0); \
+    color = ${float:scale} * ${sh_tex_lod_fn(sh, src_params(src))}($tex, pos, 0.0); \
     }
 
     return true;
@@ -532,7 +533,7 @@ static void polar_sample(pl_shader sh, pl_filter filter,
         @for (c : comp_mask)                                    \
             c[@c] = ${in}_@c[idx];                              \
     @} else {                                                   \
-        c = textureLod($tex, base + pt * vec2(offset), 0.0);    \
+        c = ${sh_tex_lod_fn(sh, (struct pl_tex_params){ .w = 1, .h = 1, .d = 0 })}($tex, base + pt * vec2(offset), 0.0);    \
     @}                                                          \
     @for (c : comp_mask)                                        \
         color[@c] += w * c[@c];                                 \
@@ -670,7 +671,9 @@ bool pl_shader_sample_polar(pl_shader sh, const struct pl_sample_src *src,
 
     // Disable compute shaders after a (hard-coded) radius of 6, since the
     // gather kernel generally pulls ahead here.
-    bool is_compute = !params->no_compute && sh_glsl(sh).compute;
+    bool is_compute = !params->no_compute && 
+                      sh_glsl(sh).compute &&
+                      sh_glsl(sh).version >= 130; // needed for round()
     is_compute &= obj->filter->radius < 6.0;
 
     while (is_compute) {
@@ -759,8 +762,8 @@ bool pl_shader_sample_polar(pl_shader sh, const struct pl_sample_src *src,
         // Load all relevant texels into shmem
         GLSL("for (int y = int(gl_LocalInvocationID.y); y < "$"; y += %d) {     \n"
              "for (int x = int(gl_LocalInvocationID.x); x < "$"; x += %d) {     \n"
-             "c = textureLod("$", "$"_base + pt * vec2(x - %d, y - %d), 0.0);   \n",
-             ih_c, bh, iw_c, bw, src_tex, in, offset, offset);
+             "c = %s("$", "$"_base + pt * vec2(x - %d, y - %d), 0.0);           \n",
+             ih_c, bh, iw_c, bw, sh_tex_lod_fn(sh, src_params(src)), src_tex, in, offset, offset);
 
         for (uint8_t comps = cmask; comps;) {
             uint8_t c = __builtin_ctz(comps);
@@ -1086,7 +1089,7 @@ bool pl_shader_sample_ortho2(pl_shader sh, const struct pl_sample_src *src,
         off = float(n);                                                         \
         @if (use_linear)                                                        \
             off += ws[n % 4u + 1u];                                             \
-        c = textureLod($src_tex, base + pt * off, 0.0).${swizzle: comps};       \
+        c = ${sh_tex_lod_fn(sh, src_params(src))}($src_tex, base + pt * off, 0.0).${swizzle: comps};       \
         @if (use_ar) {                                                          \
             if (n == ${uint: N} / 2u - 1u || n == ${uint: N} / 2u) {            \
                 lo = min(lo, c);                                                \
@@ -1195,11 +1198,11 @@ void pl_shader_distort(pl_shader sh, pl_tex src_tex, int out_w, int out_h,
         vec4 h = vec4(w1, w3) / g + inv.xyxy;               \
         h.xy -= vec2(2.0);                                  \
         vec4 p = pos.xyxy + pt.xyxy * h;                    \
-        vec4 c00 = textureLod($tex, p.xy, 0.0);             \
-        vec4 c01 = textureLod($tex, p.xw, 0.0);             \
+        vec4 c00 = ${sh_tex_lod_fn(sh, src_tex->params)}($tex, p.xy, 0.0);             \
+        vec4 c01 = ${sh_tex_lod_fn(sh, src_tex->params)}($tex, p.xw, 0.0);             \
         vec4 c0 = mix(c01, c00, g.y);                       \
-        vec4 c10 = textureLod($tex, p.zy, 0.0);             \
-        vec4 c11 = textureLod($tex, p.zw, 0.0);             \
+        vec4 c10 = ${sh_tex_lod_fn(sh, src_tex->params)}($tex, p.zy, 0.0);             \
+        vec4 c11 = ${sh_tex_lod_fn(sh, src_tex->params)}($tex, p.zw, 0.0);             \
         vec4 c1 = mix(c11, c10, g.y);                       \
         color = mix(c1, c0, g.x);                           \
     @} else {                                               \
@@ -1214,5 +1217,4 @@ void pl_shader_distort(pl_shader sh, pl_tex src_tex, int out_w, int out_h,
             color.a *= border.x * border.y;                 \
     @}                                                      \
     }
-
 }
