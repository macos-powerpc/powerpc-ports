https://github.com/alex-free/leopard-sdl2/blob/2bc0b5ac007ba63c8208b4fcc8113de221f1ed6b/SDL2-2.0.6_OSX_104.patch

diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaclipboard.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaclipboard.m
--- src/video/cocoa/SDL_cocoaclipboard.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoaclipboard.m	2018-05-24 21:19:36.000000000 +0200
@@ -25,27 +25,64 @@
 #include "SDL_cocoavideo.h"
 #include "../../events/SDL_clipboardevents_c.h"
 
+static NSString *
+GetTextFormat(_THIS)
+{
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+    if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_5) {
+        return NSPasteboardTypeString;
+    } else {
+#endif
+        return NSStringPboardType;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+    }
+#endif
+}
+
 int
 Cocoa_SetClipboardText(_THIS, const char *text)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
     NSPasteboard *pasteboard;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     NSString *format = NSPasteboardTypeString;
+#else
+    NSString *format = GetTextFormat(_this);
+#endif
 
     pasteboard = [NSPasteboard generalPasteboard];
     data->clipboard_count = [pasteboard declareTypes:[NSArray arrayWithObject:format] owner:nil];
     [pasteboard setString:[NSString stringWithUTF8String:text] forType:format];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 char *
 Cocoa_GetClipboardText(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSPasteboard *pasteboard;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     NSString *format = NSPasteboardTypeString;
+#else
+    NSString *format = GetTextFormat(_this);
+#endif
     NSString *available;
     char *text;
 
@@ -66,8 +103,15 @@
         text = SDL_strdup("");
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return text;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 SDL_bool
 Cocoa_HasClipboardText(_THIS)
@@ -83,8 +127,12 @@
 
 void
 Cocoa_CheckClipboardUpdate(struct SDL_VideoData * data)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{   NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSPasteboard *pasteboard;
     NSInteger count;
 
@@ -96,7 +144,12 @@
         }
         data->clipboard_count = count;
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaevents.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaevents.m
--- src/video/cocoa/SDL_cocoaevents.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoaevents.m	2018-05-25 22:24:46.000000000 +0200
@@ -55,6 +55,19 @@
     SDL_VideoDevice *_this = SDL_GetVideoDevice();
 
     switch ([theEvent type]) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        case NSLeftMouseDown:
+        case NSOtherMouseDown:
+        case NSRightMouseDown:
+        case NSLeftMouseUp:
+        case NSOtherMouseUp:
+        case NSRightMouseUp:
+        case NSLeftMouseDragged:
+        case NSRightMouseDragged:
+        case NSOtherMouseDragged: /* usually middle mouse dragged */
+        case NSMouseMoved:
+        case NSScrollWheel:
+#else
         case NSEventTypeLeftMouseDown:
         case NSEventTypeOtherMouseDown:
         case NSEventTypeRightMouseDown:
@@ -66,11 +79,18 @@
         case NSEventTypeOtherMouseDragged: /* usually middle mouse dragged */
         case NSEventTypeMouseMoved:
         case NSEventTypeScrollWheel:
+#endif
             Cocoa_HandleMouseEvent(_this, theEvent);
             break;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        case NSKeyDown:
+        case NSKeyUp:
+        case NSFlagsChanged:
+#else
         case NSEventTypeKeyDown:
         case NSEventTypeKeyUp:
         case NSEventTypeFlagsChanged:
+#endif
             Cocoa_HandleKeyEvent(_this, theEvent);
             break;
         default:
@@ -97,7 +117,11 @@
 - (void)setAppleMenu:(NSMenu *)menu;
 @end
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 @interface SDLAppDelegate : NSObject <NSApplicationDelegate> {
+#else
+@interface SDLAppDelegate : NSObject {
+#endif
 @public
     BOOL seenFirstActivate;
 }
@@ -141,6 +165,9 @@
 - (void)windowWillClose:(NSNotification *)notification;
 {
     NSWindow *win = (NSWindow*)[notification object];
+#if !defined(MAC_OS_X_VERSION_10_5)
+    int i;
+#endif
 
     if (![win isKeyWindow]) {
         return;
@@ -155,10 +182,18 @@
      * want to try its list first since the behavior in other apps is to only
      * make the 'About' window key if no other windows are on-screen.
      */
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSWindow *window in [NSApp orderedWindows]) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [[NSApp orderedWindows] count]; i++) {
+        NSWindow *window = [[NSApp orderedWindows] objectAtIndex:i];
+#endif
         if (window != win && [window canBecomeKeyWindow]) {
-            if (![window isOnActiveSpace]) {
-                continue;
+            if ([window respondsToSelector:@selector(isOnActiveSpace)]) {
+                if (![window isOnActiveSpace]) {
+                    continue;
+                }
             }
             [window makeKeyAndOrderFront:self];
             return;
@@ -169,17 +204,29 @@
      * the active Space in z-order (including the 'About' window, if it's shown)
      * and make the first one key.
      */
+    if ([NSWindow respondsToSelector:@selector(windowNumbersWithOptions:)]) {
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSNumber *num in [NSWindow windowNumbersWithOptions:0]) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [[NSWindow windowNumbersWithOptions:0] count]; i++) {
+        NSNumber *num = [[NSWindow windowNumbersWithOptions:0] objectAtIndex:i];
+#endif
+        if([num respondsToSelector:@selector(integerValue)]) {
         NSWindow *window = [NSApp windowWithWindowNumber:[num integerValue]];
         if (window && window != win && [window canBecomeKeyWindow]) {
             [window makeKeyAndOrderFront:self];
             return;
         }
+        }
+    }
     }
 }
 
 - (void)focusSomeWindow:(NSNotification *)aNotification
 {
+    SDL_VideoDevice *device;
+
     /* HACK: Ignore the first call. The application gets a
      * applicationDidBecomeActive: a little bit after the first window is
      * created, and if we don't ignore it, a window that has been created with
@@ -190,7 +237,7 @@
         return;
     }
 
-    SDL_VideoDevice *device = SDL_GetVideoDevice();
+    device = SDL_GetVideoDevice();
     if (device && device->windows) {
         SDL_Window *window = device->windows;
         int i;
@@ -328,6 +375,7 @@
     [windowMenu release];
 
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     /* Add the fullscreen view toggle menu option, if supported */
     if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6) {
         /* Create the view menu */
@@ -345,22 +393,39 @@
 
         [viewMenu release];
     }
+#endif
 }
 
 void
 Cocoa_RegisterApp(void)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* This can get called more than once! Be careful what you initialize! */
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1060
+    ProcessSerialNumber psn;
+
+    if (!GetCurrentProcess(&psn)) {
+        TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+        SetFrontProcess(&psn);
+    }
+#endif
 
     if (NSApp == nil) {
+        NSDictionary *appDefaults;
         [SDLApplication sharedApplication];
         SDL_assert(NSApp != nil);
 
         s_bShouldHandleEventsInSDLApplication = SDL_TRUE;
 
         if (!SDL_GetHintBoolean(SDL_HINT_MAC_BACKGROUND_APP, SDL_FALSE)) {
+#if defined(MAC_OS_X_VERSION_10_6)
             [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
+#endif
             [NSApp activateIgnoringOtherApps:YES];
 		}
 		
@@ -368,7 +433,7 @@
             CreateApplicationMenus();
         }
         [NSApp finishLaunching];
-        NSDictionary *appDefaults = [[NSDictionary alloc] initWithObjectsAndKeys:
+        appDefaults = [[NSDictionary alloc] initWithObjectsAndKeys:
             [NSNumber numberWithBool:NO], @"AppleMomentumScrollSupported",
             [NSNumber numberWithBool:NO], @"ApplePressAndHoldEnabled",
             [NSNumber numberWithBool:YES], @"ApplePersistenceIgnoreState",
@@ -388,12 +453,22 @@
             appDelegate->seenFirstActivate = YES;
         }
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_PumpEvents(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
 #if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
     /* Update activity every 30 seconds to prevent screensaver */
     SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
@@ -407,8 +482,15 @@
     }
 #endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
     for ( ; ; ) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        NSEvent *event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES ];
+#else
         NSEvent *event = [NSApp nextEventMatchingMask:NSEventMaskAny untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES ];
+#endif
         if ( event == nil ) {
             break;
         }
@@ -420,10 +502,16 @@
         // Pass events down to SDLApplication to be handled in sendEvent:
         [NSApp sendEvent:event];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SuspendScreenSaver(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
     SDL_VideoData *data = (SDL_VideoData *)_this->driverdata;
@@ -450,6 +538,10 @@
                                            &data->screensaver_assertion);
     }
 }}
+#else
+{
+}
+#endif
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoakeyboard.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoakeyboard.m
--- src/video/cocoa/SDL_cocoakeyboard.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoakeyboard.m	2018-05-24 22:24:10.000000000 +0200
@@ -34,7 +34,11 @@
 /*#define DEBUG_IME NSLog */
 #define DEBUG_IME(...)
 
+#if defined(MAC_OS_X_VERSION_10_5)
 @interface SDLTranslatorResponder : NSView <NSTextInputClient> {
+#else
+@interface SDLTranslatorResponder : NSView {
+#endif
     NSString *_markedText;
     NSRange   _markedRange;
     NSRange   _selectedRange;
@@ -93,6 +97,14 @@
     return _selectedRange;
 }
 
+- (void)unmarkText
+{
+    [_markedText release];
+    _markedText = nil;
+
+    SDL_SendEditingText("", 0, 0);
+}
+
 - (void)setMarkedText:(id)aString selectedRange:(NSRange)selectedRange replacementRange:(NSRange)replacementRange;
 {
     if ([aString isKindOfClass:[NSAttributedString class]]) {
@@ -119,14 +131,6 @@
           selRange.location, selRange.length);
 }
 
-- (void)unmarkText
-{
-    [_markedText release];
-    _markedText = nil;
-
-    SDL_SendEditingText("", 0, 0);
-}
-
 - (NSRect)firstRectForCharacterRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange;
 {
     NSWindow *window = [self window];
@@ -144,12 +148,18 @@
             NSStringFromRect(rect));
 
 #if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+#if defined(MAC_OS_X_VERSION_10_7)
     if (![window respondsToSelector:@selector(convertRectToScreen:)]) {
+#endif
         rect.origin = [window convertBaseToScreen:rect.origin];
+#if defined(MAC_OS_X_VERSION_10_7)
     } else
 #endif
+#endif
     {
+#if defined(MAC_OS_X_VERSION_10_7)
         rect = [window convertRectToScreen:rect];
+#endif
     }
 
     return rect;
@@ -193,6 +203,7 @@
 http://stackoverflow.com/questions/7190852/using-iohidmanager-to-get-modifier-key-events
 */
 
+#if defined(MAC_OS_X_VERSION_10_5)
 static IOHIDManagerRef s_hidManager = NULL;
 
 static void
@@ -296,6 +307,7 @@
         CFRelease(keyboard);
     }
 }
+#endif
 
 /* This is a helper function for HandleModifierSide. This
  * function reverts back to behavior before the distinction between
@@ -504,6 +516,7 @@
 static void
 UpdateKeymap(SDL_VideoData *data, SDL_bool send_event)
 {
+#if defined(MAC_OS_X_VERSION_10_5)
     TISInputSourceRef key_layout;
     const void *chr_data;
     int i;
@@ -566,6 +579,7 @@
 
 cleanup:
     CFRelease(key_layout);
+#endif
 }
 
 void
@@ -583,24 +597,36 @@
     SDL_SetScancodeName(SDL_SCANCODE_RALT, "Right Option");
     SDL_SetScancodeName(SDL_SCANCODE_RGUI, "Right Command");
 
+    if([NSEvent respondsToSelector:@selector(modifierFlags)]) {
     data->modifierFlags = [NSEvent modifierFlags];
+    } else {
+    data->modifierFlags = 0;
+    }
     SDL_ToggleModState(KMOD_CAPS, (data->modifierFlags & NSEventModifierFlagCapsLock) != 0);
 
+#if defined(MAC_OS_X_VERSION_10_5)
     InitHIDCallback();
+#endif
 }
 
 void
 Cocoa_StartTextInput(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
     SDL_Window *window = SDL_GetKeyboardFocus();
     NSWindow *nswindow = nil;
+    NSView *parentView;
     if (window) {
         nswindow = ((SDL_WindowData*)window->driverdata)->nswindow;
     }
 
-    NSView *parentView = [nswindow contentView];
+    parentView = [nswindow contentView];
 
     /* We only keep one field editor per process, since only the front most
      * window can receive text input events, so it make no sense to keep more
@@ -618,20 +644,37 @@
         [parentView addSubview: data->fieldEdit];
         [nswindow makeFirstResponder: data->fieldEdit];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_StopTextInput(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
+#endif
 {
     SDL_VideoData *data = (SDL_VideoData *) _this->driverdata;
 
     if (data && data->fieldEdit) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
         [data->fieldEdit removeFromSuperview];
         [data->fieldEdit release];
         data->fieldEdit = nil;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 void
 Cocoa_SetTextInputRect(_THIS, SDL_Rect *rect)
@@ -649,16 +692,17 @@
 void
 Cocoa_HandleKeyEvent(_THIS, NSEvent *event)
 {
+    unsigned short scancode;
+    SDL_Scancode code;
+#if 0
+    const char *text;
+#endif
     SDL_VideoData *data = _this ? ((SDL_VideoData *) _this->driverdata) : NULL;
     if (!data) {
         return;  /* can happen when returning from fullscreen Space on shutdown */
     }
 
-    unsigned short scancode = [event keyCode];
-    SDL_Scancode code;
-#if 0
-    const char *text;
-#endif
+    scancode = [event keyCode];
 
     if ((scancode == 10 || scancode == 50) && KBGetLayoutType(LMGetKbdType()) == kKeyboardISO) {
         /* see comments in SDL_cocoakeys.h */
@@ -673,7 +717,11 @@
     }
 
     switch ([event type]) {
+#if !defined(MAC_OS_X_VERSION_10_12)
+    case NSKeyDown:
+#else
     case NSEventTypeKeyDown:
+#endif
         if (![event isARepeat]) {
             /* See if we need to rebuild the keyboard layout */
             UpdateKeymap(data, SDL_TRUE);
@@ -697,10 +745,18 @@
 #endif
         }
         break;
+#if !defined(MAC_OS_X_VERSION_10_12)
+    case NSKeyUp:
+#else
     case NSEventTypeKeyUp:
+#endif
         SDL_SendKeyboardKey(SDL_RELEASED, code);
         break;
+#if !defined(MAC_OS_X_VERSION_10_12)
+    case NSFlagsChanged:
+#else
     case NSEventTypeFlagsChanged:
+#endif
         /* FIXME CW 2007-08-14: check if this whole mess that takes up half of this file is really necessary */
         HandleModifiers(_this, scancode, [event modifierFlags]);
         break;
@@ -712,7 +768,9 @@
 void
 Cocoa_QuitKeyboard(_THIS)
 {
+#if defined(MAC_OS_X_VERSION_10_5)
     QuitHIDCallback();
+#endif
 }
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamessagebox.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamessagebox.m
--- src/video/cocoa/SDL_cocoamessagebox.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoamessagebox.m	2018-05-24 21:19:36.000000000 +0200
@@ -92,10 +92,15 @@
 /* Display a Cocoa message box */
 int
 Cocoa_ShowMessageBox(const SDL_MessageBoxData *messageboxdata, int *buttonid)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
+#endif
 {
     Cocoa_RegisterApp();
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSAlert* alert = [[[NSAlert alloc] init] autorelease];
 
     if (messageboxdata->flags & SDL_MESSAGEBOX_ERROR) {
@@ -137,8 +142,15 @@
         returnValue = SDL_SetError("Did not get a valid `clicked button' id: %ld", (long)clicked);
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return returnValue;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 #endif /* SDL_VIDEO_DRIVER_COCOA */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoametalview.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoametalview.h
--- src/video/cocoa/SDL_cocoametalview.h	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoametalview.h	2018-05-24 22:26:45.000000000 +0200
@@ -29,8 +29,8 @@
 #ifndef SDL_cocoametalview_h_
 #define SDL_cocoametalview_h_
 
-#import "../SDL_sysvideo.h"
-#import "SDL_cocoawindow.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_cocoawindow.h"
 
 #if SDL_VIDEO_VULKAN && SDL_VIDEO_DRIVER_COCOA
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoametalview.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoametalview.m
--- src/video/cocoa/SDL_cocoametalview.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoametalview.m	2018-05-24 22:25:57.000000000 +0200
@@ -26,7 +26,7 @@
  * how to add a CAMetalLayer backed view.
  */
 
-#import "SDL_cocoametalview.h"
+#include "SDL_cocoametalview.h"
 
 #if SDL_VIDEO_VULKAN && SDL_VIDEO_DRIVER_COCOA
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamodes.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamodes.h
--- src/video/cocoa/SDL_cocoamodes.h	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoamodes.h	2018-05-24 21:19:36.000000000 +0200
@@ -30,7 +30,11 @@
 
 typedef struct
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     CGDisplayModeRef moderef;
+#else
+    const void *moderef;
+#endif
 } SDL_DisplayModeData;
 
 extern void Cocoa_InitModes(_THIS);
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamodes.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamodes.m
--- src/video/cocoa/SDL_cocoamodes.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoamodes.m	2018-05-24 22:37:32.000000000 +0200
@@ -100,14 +100,25 @@
 }
 
 static SDL_bool
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 GetDisplayMode(_THIS, CGDisplayModeRef vidmode, CFArrayRef modelist, CVDisplayLinkRef link, SDL_DisplayMode *mode)
+#else
+GetDisplayMode(_THIS, const void *moderef, CFArrayRef modelist, CVDisplayLinkRef link, SDL_DisplayMode *mode)
+#endif
 {
     SDL_DisplayModeData *data;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     int width = (int) CGDisplayModeGetWidth(vidmode);
     int height = (int) CGDisplayModeGetHeight(vidmode);
     int bpp = 0;
     int refreshRate = 0;
     CFStringRef fmt;
+#else
+    long width = 0;
+    long height = 0;
+    long bpp = 0;
+    long refreshRate = 0;
+#endif
 
     /* Ignore this mode if it's low-dpi (@1x) and we have a high-dpi mode in the
      * list with the same size in points.
@@ -145,8 +156,13 @@
     if (!data) {
         return SDL_FALSE;
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     data->moderef = vidmode;
+#else
+    data->moderef = moderef;
+#endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     fmt = CGDisplayModeCopyPixelEncoding(vidmode);
     refreshRate = (int) (CGDisplayModeGetRefreshRate(vidmode) + 0.5);
 
@@ -164,6 +180,22 @@
     }
 
     CFRelease(fmt);
+#else
+    {
+        CFNumberRef number;
+        double refresh;
+        CFDictionaryRef vidmode = (CFDictionaryRef) moderef;
+        number = CFDictionaryGetValue(vidmode, kCGDisplayWidth);
+        CFNumberGetValue(number, kCFNumberLongType, &width);
+        number = CFDictionaryGetValue(vidmode, kCGDisplayHeight);
+        CFNumberGetValue(number, kCFNumberLongType, &height);
+        number = CFDictionaryGetValue(vidmode, kCGDisplayBitsPerPixel);
+        CFNumberGetValue(number, kCFNumberLongType, &bpp);
+        number = CFDictionaryGetValue(vidmode, kCGDisplayRefreshRate);
+        CFNumberGetValue(number, kCFNumberDoubleType, &refresh);
+        refreshRate = (long) (refresh + 0.5);
+    }
+#endif
 
     /* CGDisplayModeGetRefreshRate returns 0 for many non-CRT displays. */
     if (refreshRate == 0 && link != NULL) {
@@ -212,8 +244,13 @@
 
 void
 Cocoa_InitModes(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     CGDisplayErr result;
     CGDirectDisplayID *displays;
     CGDisplayCount numDisplays;
@@ -222,6 +259,9 @@
     result = CGGetOnlineDisplayList(0, NULL, &numDisplays);
     if (result != kCGErrorSuccess) {
         CG_SetError("CGGetOnlineDisplayList()", result);
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return;
     }
     displays = SDL_stack_alloc(CGDirectDisplayID, numDisplays);
@@ -229,6 +269,9 @@
     if (result != kCGErrorSuccess) {
         CG_SetError("CGGetOnlineDisplayList()", result);
         SDL_stack_free(displays);
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return;
     }
 
@@ -238,7 +281,11 @@
             SDL_VideoDisplay display;
             SDL_DisplayData *displaydata;
             SDL_DisplayMode mode;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             CGDisplayModeRef moderef = NULL;
+#else
+            const void *moderef = NULL;
+#endif
             CVDisplayLinkRef link = NULL;
 
             if (pass == 0) {
@@ -255,7 +302,11 @@
                 continue;
             }
 
+            #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             moderef = CGDisplayCopyDisplayMode(displays[i]);
+            #else
+            moderef = CGDisplayCurrentMode(displays[i]);
+            #endif
 
             if (!moderef) {
                 continue;
@@ -263,7 +314,9 @@
 
             displaydata = (SDL_DisplayData *) SDL_malloc(sizeof(*displaydata));
             if (!displaydata) {
+            #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
                 CGDisplayModeRelease(moderef);
+            #endif
                 continue;
             }
             displaydata->display = displays[i];
@@ -275,7 +328,9 @@
             display.name = (char *)Cocoa_GetDisplayName(displays[i]);
             if (!GetDisplayMode(_this, moderef, NULL, link, &mode)) {
                 CVDisplayLinkRelease(link);
+            #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
                 CGDisplayModeRelease(moderef);
+            #endif
                 SDL_free(display.name);
                 SDL_free(displaydata);
                 continue;
@@ -291,7 +346,12 @@
         }
     }
     SDL_stack_free(displays);
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+}
+#else
 }}
+#endif
 
 int
 Cocoa_GetDisplayBounds(_THIS, SDL_VideoDisplay * display, SDL_Rect * rect)
@@ -316,7 +376,14 @@
     NSScreen *screen = nil;
 
     /* !!! FIXME: maybe track the NSScreen in SDL_DisplayData? */
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSScreen *i in screens) {
+#else
+    /* old way to iterate */
+    int j;
+    for (j = 0; j < [screens count]; j++) {
+        NSScreen *i = [screens objectAtIndex:j];
+#endif
         const CGDirectDisplayID thisDisplay = (CGDirectDisplayID) [[[i deviceDescription] objectForKey:@"NSScreenNumber"] unsignedIntValue];
         if (thisDisplay == cgdisplay) {
             screen = i;
@@ -329,6 +396,7 @@
         return -1;
     }
 
+    {
     const CGRect cgrect = CGDisplayBounds(cgdisplay);
     const NSRect frame = [screen visibleFrame];
 
@@ -338,6 +406,7 @@
     rect->y = (int)(cgrect.origin.y + frame.origin.y);
     rect->w = (int)frame.size.width;
     rect->h = (int)frame.size.height;
+    }
 
     return 0;
 }
@@ -391,7 +460,11 @@
     }
 #endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     modes = CGDisplayCopyAllDisplayModes(data->display, dict);
+#else
+    modes = CGDisplayAvailableModes(data->display);
+#endif
 
     if (dict != NULL) {
         CFRelease(dict);
@@ -405,10 +478,16 @@
         CVDisplayLinkCreateWithCGDisplay(data->display, &link);
 
         for (i = 0; i < count; i++) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             CGDisplayModeRef moderef = (CGDisplayModeRef) CFArrayGetValueAtIndex(modes, i);
+#else
+            const void *moderef = CFArrayGetValueAtIndex(modes, i);
+#endif
             SDL_DisplayMode mode;
             if (GetDisplayMode(_this, moderef, modes, link, &mode)) {
+                #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
                 CGDisplayModeRetain(moderef);
+                #endif
                 SDL_AddDisplayMode(display, &mode);
             }
         }
@@ -433,7 +512,11 @@
 
     if (data == display->desktop_mode.driverdata) {
         /* Restoring desktop mode */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         CGDisplaySetDisplayMode(displaydata->display, data->moderef, NULL);
+#else
+        CGDisplaySwitchToMode(displaydata->display, data->moderef);
+#endif
 
         if (CGDisplayIsMain(displaydata->display)) {
             CGReleaseAllDisplays();
@@ -458,7 +541,11 @@
         }
 
         /* Do the physical switch */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         result = CGDisplaySetDisplayMode(displaydata->display, data->moderef, NULL);
+#else
+        result = CGDisplaySwitchToMode(displaydata->display, data->moderef);
+#endif
         if (result != kCGErrorSuccess) {
             CG_SetError("CGDisplaySwitchToMode()", result);
             goto ERR_NO_SWITCH;
@@ -503,11 +590,15 @@
         }
 
         mode = (SDL_DisplayModeData *) display->desktop_mode.driverdata;
+        #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         CGDisplayModeRelease(mode->moderef);
+        #endif
 
         for (j = 0; j < display->num_display_modes; j++) {
             mode = (SDL_DisplayModeData*) display->display_modes[j].driverdata;
+        #if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
             CGDisplayModeRelease(mode->moderef);
+        #endif
         }
 
     }
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamouse.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamouse.h
--- src/video/cocoa/SDL_cocoamouse.h	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoamouse.h	2018-05-24 21:41:29.000000000 +0200
@@ -25,6 +25,10 @@
 
 #include "SDL_cocoavideo.h"
 
+#if !defined(MAC_OS_X_VERSION_10_5)
+typedef float CGFloat;
+#endif
+
 extern void Cocoa_InitMouse(_THIS);
 extern void Cocoa_HandleMouseEvent(_THIS, NSEvent * event);
 extern void Cocoa_HandleMouseWheel(SDL_Window *window, NSEvent * event);
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoamouse.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoamouse.m
--- src/video/cocoa/SDL_cocoamouse.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoamouse.m	2018-05-24 22:52:21.000000000 +0200
@@ -67,8 +67,13 @@
 
 static SDL_Cursor *
 Cocoa_CreateDefaultCursor()
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSCursor *nscursor;
     SDL_Cursor *cursor = NULL;
 
@@ -82,13 +87,25 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return cursor;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static SDL_Cursor *
 Cocoa_CreateCursor(SDL_Surface * surface, int hot_x, int hot_y)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSImage *nsimage;
     NSCursor *nscursor = NULL;
     SDL_Cursor *cursor = NULL;
@@ -107,13 +124,25 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return cursor;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static SDL_Cursor *
 Cocoa_CreateSystemCursor(SDL_SystemCursor id)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSCursor *nscursor = NULL;
     SDL_Cursor *cursor = NULL;
 
@@ -147,7 +176,9 @@
         nscursor = [NSCursor closedHandCursor];
         break;
     case SDL_SYSTEM_CURSOR_NO:
+        if ([NSCursor respondsToSelector:@selector(operationNotAllowedCursor)]) {
         nscursor = [NSCursor operationNotAllowedCursor];
+        }
         break;
     case SDL_SYSTEM_CURSOR_HAND:
         nscursor = [NSCursor pointingHandCursor];
@@ -166,23 +197,45 @@
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return cursor;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static void
 Cocoa_FreeCursor(SDL_Cursor * cursor)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSCursor *nscursor = (NSCursor *)cursor->driverdata;
 
     [nscursor release];
     SDL_free(cursor);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 static int
 Cocoa_ShowCursor(SDL_Cursor * cursor)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoDevice *device = SDL_GetVideoDevice();
     SDL_Window *window = (device ? device->windows : NULL);
     for (; window != NULL; window = window->next) {
@@ -193,8 +246,15 @@
                                                 waitUntilDone:NO];
         }
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 static SDL_Window *
 SDL_FindWindowAtPoint(const int x, const int y)
@@ -214,6 +274,7 @@
 static int
 Cocoa_WarpMouseGlobal(int x, int y)
 {
+    const CGPoint point = CGPointMake((float)x, (float)y);
     SDL_Mouse *mouse = SDL_GetMouse();
     if (mouse->focus) {
         SDL_WindowData *data = (SDL_WindowData *) mouse->focus->driverdata;
@@ -223,7 +284,6 @@
             return 0;
         }
     }
-    const CGPoint point = CGPointMake((float)x, (float)y);
 
     Cocoa_HandleMouseWarp(point.x, point.y);
 
@@ -261,6 +321,8 @@
 static int
 Cocoa_SetRelativeMouseMode(SDL_bool enabled)
 {
+    CGError result;
+    SDL_WindowData *data;
     /* We will re-apply the relative mode when the window gets focus, if it
      * doesn't have focus right now.
      */
@@ -272,12 +334,11 @@
     /* We will re-apply the relative mode when the window finishes being moved,
      * if it is being moved right now.
      */
-    SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
+    data = (SDL_WindowData *) window->driverdata;
     if ([data->listener isMoving]) {
         return 0;
     }
 
-    CGError result;
     if (enabled) {
         DLog("Turning on.");
         result = CGAssociateMouseAndMouseCursorPosition(NO);
@@ -311,11 +372,24 @@
 static Uint32
 Cocoa_GetGlobalMouseState(int *x, int *y)
 {
-    const NSUInteger cocoaButtons = [NSEvent pressedMouseButtons];
+    NSUInteger cocoaButtons = 0;
     const NSPoint cocoaLocation = [NSEvent mouseLocation];
     Uint32 retval = 0;
+#if !defined(MAC_OS_X_VERSION_10_5)
+    int i;
+#endif
 
+    if ([NSEvent respondsToSelector:@selector(pressedMouseButtons)]) {
+        cocoaButtons = [NSEvent pressedMouseButtons];
+    }
+
+#if defined(MAC_OS_X_VERSION_10_5)
     for (NSScreen *screen in [NSScreen screens]) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [[NSScreen screens] count]; i++) {
+        NSScreen *screen = [[NSScreen screens] objectAtIndex:i];
+#endif
         NSRect frame = [screen frame];
         if (NSMouseInRect(cocoaLocation, frame, NO)) {
             *x = (int) cocoaLocation.x;
@@ -336,6 +410,8 @@
 void
 Cocoa_InitMouse(_THIS)
 {
+    SDL_MouseData *driverdata;
+    NSPoint location;
     SDL_Mouse *mouse = SDL_GetMouse();
 
     mouse->driverdata = SDL_calloc(1, sizeof(SDL_MouseData));
@@ -354,8 +430,8 @@
 
     Cocoa_InitMouseEventTap(mouse->driverdata);
 
-    SDL_MouseData *driverdata = (SDL_MouseData*)mouse->driverdata;
-    const NSPoint location =  [NSEvent mouseLocation];
+    driverdata = (SDL_MouseData*)mouse->driverdata;
+    location =  [NSEvent mouseLocation];
     driverdata->lastMoveX = location.x;
     driverdata->lastMoveY = location.y;
 }
@@ -363,11 +439,21 @@
 void
 Cocoa_HandleMouseEvent(_THIS, NSEvent *event)
 {
+    SDL_Mouse *mouse;
+    SDL_MouseData *driverdata;
+    SDL_bool seenWarp;
     switch ([event type]) {
+#if !defined(MAC_OS_X_VERSION_10_12)
+        case NSMouseMoved:
+        case NSLeftMouseDragged:
+        case NSRightMouseDragged:
+        case NSOtherMouseDragged:
+#else
         case NSEventTypeMouseMoved:
         case NSEventTypeLeftMouseDragged:
         case NSEventTypeRightMouseDragged:
         case NSEventTypeOtherMouseDragged:
+#endif
             break;
 
         default:
@@ -375,15 +461,18 @@
             return;
     }
 
-    SDL_Mouse *mouse = SDL_GetMouse();
-    SDL_MouseData *driverdata = (SDL_MouseData*)mouse->driverdata;
+    mouse = SDL_GetMouse();
+    driverdata = (SDL_MouseData*)mouse->driverdata;
     if (!driverdata) {
         return;  /* can happen when returning from fullscreen Space on shutdown */
     }
 
-    const SDL_bool seenWarp = driverdata->seenWarp;
+    seenWarp = driverdata->seenWarp;
     driverdata->seenWarp = NO;
 
+    {
+    float deltaX;
+    float deltaY;
     const NSPoint location =  [NSEvent mouseLocation];
     const CGFloat lastMoveX = driverdata->lastMoveX;
     const CGFloat lastMoveY = driverdata->lastMoveY;
@@ -404,8 +493,8 @@
         }
     }
 
-    float deltaX = [event deltaX];
-    float deltaY = [event deltaY];
+    deltaX = [event deltaX];
+    deltaY = [event deltaY];
 
     if (seenWarp) {
         deltaX += (lastMoveX - driverdata->lastWarpX);
@@ -415,6 +504,7 @@
     }
 
     SDL_SendMouseMotion(mouse->focus, mouse->mouseID, 1, (int)deltaX, (int)deltaY);
+    }
 }
 
 void
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoaopengl.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoaopengl.m
--- src/video/cocoa/SDL_cocoaopengl.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoaopengl.m	2018-05-24 22:53:55.000000000 +0200
@@ -150,11 +150,20 @@
 
 SDL_GLContext
 Cocoa_GL_CreateContext(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
     SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
     SDL_DisplayData *displaydata = (SDL_DisplayData *)display->driverdata;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1670
     SDL_bool lion_or_later = floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6;
+#else
+    SDL_bool lion_or_later = SDL_FALSE;
+#endif
     NSOpenGLPixelFormatAttribute attr[32];
     NSOpenGLPixelFormat *fmt;
     SDLOpenGLContext *context;
@@ -173,9 +182,15 @@
         return NULL;
     }
 
+#if defined(MAC_OS_X_VERSION_10_5)
     attr[i++] = NSOpenGLPFAAllowOfflineRenderers;
+#endif
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* specify a profile if we're on Lion (10.7) or later. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     if (lion_or_later) {
         NSOpenGLPixelFormatAttribute profile = NSOpenGLProfileVersionLegacy;
         if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_CORE) {
@@ -184,6 +199,7 @@
         attr[i++] = NSOpenGLPFAOpenGLProfile;
         attr[i++] = profile;
     }
+#endif
 
     attr[i++] = NSOpenGLPFAColorSize;
     attr[i++] = SDL_BYTESPERPIXEL(display->current_mode.format)*8;
@@ -239,6 +255,9 @@
     fmt = [[NSOpenGLPixelFormat alloc] initWithAttributes:attr];
     if (fmt == nil) {
         SDL_SetError("Failed creating OpenGL pixel format");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return NULL;
     }
 
@@ -252,12 +271,18 @@
 
     if (context == nil) {
         SDL_SetError("Failed creating OpenGL context");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return NULL;
     }
 
     if ( Cocoa_GL_MakeCurrent(_this, window, context) < 0 ) {
         Cocoa_GL_DeleteContext(_this, context);
         SDL_SetError("Failed making OpenGL context current");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+        [pool release];
+#endif
         return NULL;
     }
 
@@ -272,6 +297,9 @@
         if (!glGetStringFunc) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed getting OpenGL glGetString entry point");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
@@ -279,12 +307,18 @@
         if (glversion == NULL) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed getting OpenGL context version");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
         if (SDL_sscanf(glversion, "%d.%d", &glversion_major, &glversion_minor) != 2) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed parsing OpenGL context version");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
@@ -292,6 +326,9 @@
            ((glversion_major == _this->gl_config.major_version) && (glversion_minor < _this->gl_config.minor_version))) {
             Cocoa_GL_DeleteContext(_this, context);
             SDL_SetError ("Failed creating OpenGL context at version requested");
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NULL;
         }
 
@@ -301,13 +338,25 @@
         /*_this->gl_config.major_version = glversion_major;*/
         /*_this->gl_config.minor_version = glversion_minor;*/
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return context;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+}
+#else
 }}
+#endif
 
 int
 Cocoa_GL_MakeCurrent(_THIS, SDL_Window * window, SDL_GLContext context)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     if (context) {
         SDLOpenGLContext *nscontext = (SDLOpenGLContext *)context;
         [nscontext setWindow:window];
@@ -317,8 +366,15 @@
         [NSOpenGLContext clearCurrentContext];
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 void
 Cocoa_GL_GetDrawableSize(_THIS, SDL_Window * window, int * w, int * h)
@@ -329,9 +385,11 @@
 
     /* This gives us the correct viewport for a Retina-enabled view, only
      * supported on 10.7+. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     if ([contentView respondsToSelector:@selector(convertRectToBacking:)]) {
         viewport = [contentView convertRectToBacking:viewport];
     }
+#endif
 
     if (w) {
         *w = viewport.size.width;
@@ -344,7 +402,9 @@
 
 int
 Cocoa_GL_SetSwapInterval(_THIS, int interval)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
+#endif
 {
     NSOpenGLContext *nscontext;
     GLint value;
@@ -353,6 +413,9 @@
     if (interval < 0) {  /* no extension for this on Mac OS X at the moment. */
         return SDL_SetError("Late swap tearing currently unsupported");
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
 
     nscontext = (NSOpenGLContext*)SDL_GL_GetCurrentContext();
     if (nscontext != nil) {
@@ -363,13 +426,25 @@
         status = SDL_SetError("No current OpenGL context");
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return status;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_GL_GetSwapInterval(_THIS)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSOpenGLContext *nscontext;
     GLint value;
     int status = 0;
@@ -380,28 +455,57 @@
         status = (int)value;
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return status;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_GL_SwapWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDLOpenGLContext* nscontext = (SDLOpenGLContext*)SDL_GL_GetCurrentContext();
     [nscontext flushBuffer];
     [nscontext updateIfNeeded];
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 void
 Cocoa_GL_DeleteContext(_THIS, SDL_GLContext context)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDLOpenGLContext *nscontext = (SDLOpenGLContext *)context;
 
     [nscontext setWindow:NULL];
     [nscontext release];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 #endif /* SDL_VIDEO_OPENGL_CGL */
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoashape.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoashape.m
--- src/video/cocoa/SDL_cocoashape.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoashape.m	2018-05-24 22:55:27.000000000 +0200
@@ -35,7 +35,9 @@
     SDL_WindowData* windata = (SDL_WindowData*)window->driverdata;
     [windata->nswindow setOpaque:NO];
 
+    if ([windata->nswindow respondsToSelector:@selector(setStyleMask:)]) {
     [windata->nswindow setStyleMask:NSWindowStyleMaskBorderless];
+    }
 
     SDL_WindowShaper* result = result = malloc(sizeof(SDL_WindowShaper));
     result->window = window;
@@ -73,8 +75,13 @@
 
 int
 Cocoa_SetWindowShape(SDL_WindowShaper *shaper, SDL_Surface *shape, SDL_WindowShapeMode *shape_mode)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_ShapeData* data = (SDL_ShapeData*)shaper->driverdata;
     SDL_WindowData* windata = (SDL_WindowData*)shaper->window->driverdata;
     SDL_CocoaClosure closure;
@@ -97,8 +104,15 @@
     SDL_TraverseShapeTree(data->shape,&ConvertRects,&closure);
     [closure.path addClip];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_ResizeWindowShape(SDL_Window *window)
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoavideo.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoavideo.h
--- src/video/cocoa/SDL_cocoavideo.h	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoavideo.h	2018-05-24 21:50:12.000000000 +0200
@@ -25,6 +25,12 @@
 
 #include "SDL_opengl.h"
 
+#if defined(__ALTIVEC__) && !defined(MAC_OS_X_VERSION_10_5)
+/* to cricumvent a bug in Mac OS X 10.4 SDK */
+#define vector __vector
+#include <CoreServices/CoreServices.h>
+#undef vector
+#endif
 #include <ApplicationServices/ApplicationServices.h>
 #include <IOKit/pwr_mgt/IOPMLib.h>
 #include <Cocoa/Cocoa.h>
@@ -40,6 +46,11 @@
 #include "SDL_cocoaopengl.h"
 #include "SDL_cocoawindow.h"
 
+#if !defined(MAC_OS_X_VERSION_10_5)
+typedef long int NSInteger;
+typedef unsigned int NSUInteger;
+#endif
+
 #ifndef MAC_OS_X_VERSION_10_12
 #define DECLARE_EVENT(name) static const NSEventType NSEventType##name = NS##name
 DECLARE_EVENT(LeftMouseDown);
@@ -58,7 +69,9 @@
 DECLARE_EVENT(FlagsChanged);
 #undef DECLARE_EVENT
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 static const NSEventMask NSEventMaskAny = NSAnyEventMask;
+#endif
 
 #define DECLARE_MODIFIER_FLAG(name) static const NSUInteger NSEventModifierFlag##name = NS##name##KeyMask
 DECLARE_MODIFIER_FLAG(Shift);
@@ -79,11 +92,15 @@
 DECLARE_WINDOW_MASK(Resizable);
 DECLARE_WINDOW_MASK(TexturedBackground);
 DECLARE_WINDOW_MASK(UnifiedTitleAndToolbar);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 DECLARE_WINDOW_MASK(FullScreen);
+#endif
 /*DECLARE_WINDOW_MASK(FullSizeContentView);*/ /* Not used, fails compile on older SDKs */
 static const unsigned int NSWindowStyleMaskUtilityWindow = NSUtilityWindowMask;
 static const unsigned int NSWindowStyleMaskDocModalWindow = NSDocModalWindowMask;
+#if defined(MAC_OS_X_VERSION_10_5)
 static const unsigned int NSWindowStyleMaskHUDWindow = NSHUDWindowMask;
+#endif
 #undef DECLARE_WINDOW_MASK
 
 #define DECLARE_ALERT_STYLE(name) static const NSUInteger NSAlertStyle##name = NS##name##AlertStyle
@@ -106,7 +123,9 @@
     NSInteger clipboard_count;
     Uint32 screensaver_activity;
     BOOL screensaver_use_iopm;
+#if defined(MAC_OS_X_VERSION_10_5)
     IOPMAssertionID screensaver_assertion;
+#endif
 
 } SDL_VideoData;
 
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoavideo.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoavideo.m
--- src/video/cocoa/SDL_cocoavideo.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoavideo.m	2018-05-24 21:19:36.000000000 +0200
@@ -22,6 +22,13 @@
 
 #if SDL_VIDEO_DRIVER_COCOA
 
+#if defined(__APPLE__) && defined(__POWERPC__) && !defined(__APPLE_ALTIVEC__)
+#include <altivec.h>
+#undef bool
+#undef vector
+#undef pixel
+#endif
+
 #include "SDL.h"
 #include "SDL_endian.h"
 #include "SDL_cocoavideo.h"
@@ -159,10 +166,15 @@
     Cocoa_InitKeyboard(_this);
     Cocoa_InitMouse(_this);
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     data->allow_spaces = ((floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6) && SDL_GetHintBoolean(SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES, SDL_TRUE));
 
     /* The IOPM assertion API can disable the screensaver as of 10.7. */
     data->screensaver_use_iopm = floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6;
+#else
+    data->allow_spaces = 0;
+    data->screensaver_use_iopm = 0;
+#endif
 
     return 0;
 }
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoawindow.h SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoawindow.h
--- src/video/cocoa/SDL_cocoawindow.h	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoawindow.h	2018-05-24 22:32:27.000000000 +0200
@@ -23,6 +23,13 @@
 #ifndef SDL_cocoawindow_h_
 #define SDL_cocoawindow_h_
 
+#if defined(__ALTIVEC__) && !defined(MAC_OS_X_VERSION_10_5)
+/* to cricumvent a bug in Mac OS X 10.4 SDK */
+#define vector __vector
+#include <CoreServices/CoreServices.h>
+#undef vector
+#endif
+
 #import <Cocoa/Cocoa.h>
 
 typedef struct SDL_WindowData SDL_WindowData;
@@ -35,7 +42,11 @@
     PENDING_OPERATION_MINIMIZE
 } PendingWindowOperation;
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
 @interface Cocoa_WindowListener : NSResponder <NSWindowDelegate> {
+#else
+@interface Cocoa_WindowListener : NSResponder {
+#endif
     SDL_WindowData *_data;
     BOOL observingVisible;
     BOOL wasCtrlLeft;
@@ -75,7 +86,9 @@
 -(void) windowDidEnterFullScreen:(NSNotification *) aNotification;
 -(void) windowWillExitFullScreen:(NSNotification *) aNotification;
 -(void) windowDidExitFullScreen:(NSNotification *) aNotification;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 -(NSApplicationPresentationOptions)window:(NSWindow *)window willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions;
+#endif
 
 /* See if event is in a drag area, toggle on window dragging. */
 -(BOOL) processHitTest:(NSEvent *)theEvent;
@@ -98,7 +111,17 @@
 -(void) touchesCancelledWithEvent:(NSEvent *) theEvent;
 
 /* Touch event handling */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 -(void) handleTouches:(NSTouchPhase) phase withEvent:(NSEvent*) theEvent;
+#else
+typedef enum {
+    COCOA_TOUCH_DOWN,
+    COCOA_TOUCH_UP,
+    COCOA_TOUCH_MOVE,
+    COCOA_TOUCH_CANCELLED
+} cocoaTouchType;
+-(void) handleTouches:(cocoaTouchType)type withEvent:(NSEvent*) event;
+#endif
 
 @end
 /* *INDENT-ON* */
diff -ru SDL2-2.0.6-orig/src/video/cocoa/SDL_cocoawindow.m SDL2-2.0.6-tiger/src/video/cocoa/SDL_cocoawindow.m
--- src/video/cocoa/SDL_cocoawindow.m	2017-09-22 20:51:01.000000000 +0200
+++ src/video/cocoa/SDL_cocoawindow.m	2018-05-25 10:01:02.000000000 +0200
@@ -23,7 +23,9 @@
 #if SDL_VIDEO_DRIVER_COCOA
 
 #if MAC_OS_X_VERSION_MAX_ALLOWED < 1070
+#if 0
 # error SDL for Mac OS X must be built with a 10.7 SDK or above.
+#endif
 #endif /* MAC_OS_X_VERSION_MAX_ALLOWED < 1070 */
 
 #include "SDL_syswm.h"
@@ -54,7 +56,11 @@
 #define FULLSCREEN_MASK (SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN)
 
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+@interface SDLWindow : NSWindow
+#else
 @interface SDLWindow : NSWindow <NSDraggingDestination>
+#endif
 /* These are needed for borderless/fullscreen windows */
 - (BOOL)canBecomeKeyWindow;
 - (BOOL)canBecomeMainWindow;
@@ -136,27 +142,49 @@
 }
 
 - (BOOL)performDragOperation:(id <NSDraggingInfo>)sender
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
     NSPasteboard *pasteboard = [sender draggingPasteboard];
     NSArray *types = [NSArray arrayWithObject:NSFilenamesPboardType];
     NSString *desiredType = [pasteboard availableTypeFromArray:types];
     SDL_Window *sdlwindow = [self findSDLWindow];
+    NSData *data;
+#if !defined(MAC_OS_X_VERSION_10_5)
+    NSArray *array;
+    int i;
+#endif
 
     if (desiredType == nil) {
         return NO;  /* can't accept anything that's being dropped here. */
     }
 
-    NSData *data = [pasteboard dataForType:desiredType];
+    data = [pasteboard dataForType:desiredType];
     if (data == nil) {
         return NO;
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
+
     SDL_assert([desiredType isEqualToString:NSFilenamesPboardType]);
+#if defined(MAC_OS_X_VERSION_10_5)
     NSArray *array = [pasteboard propertyListForType:@"NSFilenamesPboardType"];
 
     for (NSString *path in array) {
+#else
+    array = [pasteboard propertyListForType:@"NSFilenamesPboardType"];
+    /* old way to iterate */
+    for (i = 0; i < [array count]; i++) {
+        NSString *path = [array objectAtIndex:i];
+#endif
         NSURL *fileURL = [NSURL fileURLWithPath:path];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         NSNumber *isAlias = nil;
 
         [fileURL getResourceValue:&isAlias forKey:NSURLIsAliasFileKey error:nil];
@@ -177,15 +205,26 @@
                 }
             }
         }
+#endif
 
         if (!SDL_SendDropFile(sdlwindow, [[fileURL path] UTF8String])) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+            [pool release];
+#endif
             return NO;
         }
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     SDL_SendDropComplete(sdlwindow);
     return YES;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+}
+#else
 }}
+#endif
 
 - (BOOL)wantsPeriodicDraggingUpdates
 {
@@ -226,7 +265,14 @@
     NSOpenGLContext *currentContext = [NSOpenGLContext currentContext];
     NSMutableArray *contexts = data->nscontexts;
     @synchronized (contexts) {
+#if defined(MAC_OS_X_VERSION_10_5)
         for (SDLOpenGLContext *context in contexts) {
+#else
+        /* old way to iterate */
+        int i;
+        for (i = 0; i < [contexts count]; i++) {
+            SDLOpenGLContext *context = [contexts objectAtIndex:i];
+#endif
             if (context == currentContext) {
                 [context update];
             } else {
@@ -274,7 +320,9 @@
         [[nswindow contentView] setNextResponder:nil];
     }
 
+    if ([nswindow respondsToSelector:@selector(setStyleMask:)]) {
     [nswindow setStyleMask:style];
+    }
 
     /* The view responder chain gets messed with during setStyleMask */
     if ([[nswindow contentView] nextResponder] != data->listener) {
@@ -313,11 +361,13 @@
         [center addObserver:self selector:@selector(windowDidDeminiaturize:) name:NSWindowDidDeminiaturizeNotification object:window];
         [center addObserver:self selector:@selector(windowDidBecomeKey:) name:NSWindowDidBecomeKeyNotification object:window];
         [center addObserver:self selector:@selector(windowDidResignKey:) name:NSWindowDidResignKeyNotification object:window];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
         [center addObserver:self selector:@selector(windowDidChangeBackingProperties:) name:NSWindowDidChangeBackingPropertiesNotification object:window];
         [center addObserver:self selector:@selector(windowWillEnterFullScreen:) name:NSWindowWillEnterFullScreenNotification object:window];
         [center addObserver:self selector:@selector(windowDidEnterFullScreen:) name:NSWindowDidEnterFullScreenNotification object:window];
         [center addObserver:self selector:@selector(windowWillExitFullScreen:) name:NSWindowWillExitFullScreenNotification object:window];
         [center addObserver:self selector:@selector(windowDidExitFullScreen:) name:NSWindowDidExitFullScreenNotification object:window];
+#endif
         [center addObserver:self selector:@selector(windowDidFailToEnterFullScreen:) name:@"NSWindowDidFailToEnterFullScreenNotification" object:window];
         [center addObserver:self selector:@selector(windowDidFailToExitFullScreen:) name:@"NSWindowDidFailToExitFullScreenNotification" object:window];
     } else {
@@ -338,7 +388,9 @@
 
     [view setNextResponder:self];
 
+    if ([view respondsToSelector:@selector(setAcceptsTouchEvents:)]) {
     [view setAcceptsTouchEvents:YES];
+    }
 }
 
 - (void)observeValueForKeyPath:(NSString *)keyPath
@@ -408,7 +460,9 @@
     inFullscreenTransition = YES;
 
     /* you need to be FullScreenPrimary, or toggleFullScreen doesn't work. Unset it again in windowDidExitFullScreen. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [nswindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+#endif
     [nswindow performSelectorOnMainThread: @selector(toggleFullScreen:) withObject:nswindow waitUntilDone:NO];
     return YES;
 }
@@ -444,11 +498,13 @@
         [center removeObserver:self name:NSWindowDidDeminiaturizeNotification object:window];
         [center removeObserver:self name:NSWindowDidBecomeKeyNotification object:window];
         [center removeObserver:self name:NSWindowDidResignKeyNotification object:window];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
         [center removeObserver:self name:NSWindowDidChangeBackingPropertiesNotification object:window];
         [center removeObserver:self name:NSWindowWillEnterFullScreenNotification object:window];
         [center removeObserver:self name:NSWindowDidEnterFullScreenNotification object:window];
         [center removeObserver:self name:NSWindowWillExitFullScreenNotification object:window];
         [center removeObserver:self name:NSWindowDidExitFullScreenNotification object:window];
+#endif
         [center removeObserver:self name:@"NSWindowDidFailToEnterFullScreenNotification" object:window];
         [center removeObserver:self name:@"NSWindowDidFailToExitFullScreenNotification" object:window];
     } else {
@@ -628,9 +684,11 @@
         [NSMenu setMenuBarVisible:NO];
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
     const unsigned int newflags = [NSEvent modifierFlags] & NSEventModifierFlagCapsLock;
     _data->videodata->modifierFlags = (_data->videodata->modifierFlags & ~NSEventModifierFlagCapsLock) | newflags;
     SDL_ToggleModState(KMOD_CAPS, newflags != 0);
+#endif
 }
 
 - (void)windowDidResignKey:(NSNotification *)aNotification
@@ -657,6 +715,7 @@
 
 - (void)windowDidChangeBackingProperties:(NSNotification *)aNotification
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     NSNumber *oldscale = [[aNotification userInfo] objectForKey:NSBackingPropertyOldScaleFactorKey];
 
     if (inFullscreenTransition) {
@@ -669,6 +728,7 @@
         _data->window->h = 0;
         [self windowDidResize:aNotification];
     }
+#endif
 }
 
 - (void)windowWillEnterFullScreen:(NSNotification *)aNotification
@@ -777,12 +837,14 @@
         [nswindow miniaturize:nil];
     } else {
         /* Adjust the fullscreen toggle button and readd menu now that we're here. */
+#if MAC_OS_X_VERSION_MIN_REQUIRED > 1070
         if (window->flags & SDL_WINDOW_RESIZABLE) {
             /* resizable windows are Spaces-friendly: they get the "go fullscreen" toggle button on their titlebar. */
             [nswindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
         } else {
             [nswindow setCollectionBehavior:NSWindowCollectionBehaviorManaged];
         }
+#endif
         [NSMenu setMenuBarVisible:YES];
 
         pendingWindowOperation = PENDING_OPERATION_NONE;
@@ -825,6 +887,7 @@
     }
 }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 -(NSApplicationPresentationOptions)window:(NSWindow *)window willUseFullScreenPresentationOptions:(NSApplicationPresentationOptions)proposedOptions
 {
     if ((_data->window->flags & SDL_WINDOW_FULLSCREEN_DESKTOP) == SDL_WINDOW_FULLSCREEN_DESKTOP) {
@@ -833,6 +896,7 @@
         return proposedOptions;
     }
 }
+#endif
 
 
 /* We'll respond to key events by doing nothing so we don't beep.
@@ -1059,6 +1123,7 @@
 
 - (void)touchesBeganWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     NSSet *touches = [theEvent touchesMatchingPhase:NSTouchPhaseAny inView:nil];
     int existingTouchCount = 0;
 
@@ -1079,25 +1144,89 @@
 
     DLog("Began Fingers: %lu .. existing: %d", (unsigned long)[touches count], existingTouchCount);
     [self handleTouches:NSTouchPhaseBegan withEvent:theEvent];
+#endif
 }
 
 - (void)touchesMovedWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [self handleTouches:NSTouchPhaseMoved withEvent:theEvent];
+#endif
 }
 
 - (void)touchesEndedWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [self handleTouches:NSTouchPhaseEnded withEvent:theEvent];
+#endif
 }
 
 - (void)touchesCancelledWithEvent:(NSEvent *) theEvent
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
     [self handleTouches:NSTouchPhaseCancelled withEvent:theEvent];
+#endif
 }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
 - (void)handleTouches:(NSTouchPhase) phase withEvent:(NSEvent *) theEvent
+#else
+- (void)handleTouches:(cocoaTouchType)type withEvent:(NSEvent *)event
+#endif
 {
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    NSSet *touches = 0;
+    NSEnumerator *enumerator;
+    NSTouch *touch;
+
+    switch (type) {
+        case COCOA_TOUCH_DOWN:
+            touches = [event touchesMatchingPhase:NSTouchPhaseBegan inView:nil];
+            break;
+        case COCOA_TOUCH_UP:
+            touches = [event touchesMatchingPhase:NSTouchPhaseEnded inView:nil];
+            break;
+        case COCOA_TOUCH_CANCELLED:
+            touches = [event touchesMatchingPhase:NSTouchPhaseCancelled inView:nil];
+            break;
+        case COCOA_TOUCH_MOVE:
+            touches = [event touchesMatchingPhase:NSTouchPhaseMoved inView:nil];
+            break;
+    }
+
+    enumerator = [touches objectEnumerator];
+    touch = (NSTouch*)[enumerator nextObject];
+    while (touch) {
+        const SDL_TouchID touchId = (SDL_TouchID)(intptr_t)[touch device];
+        if (!SDL_GetTouch(touchId)) {
+            if (SDL_AddTouch(touchId, "") < 0) {
+                return;
+            }
+        }
+
+        const SDL_FingerID fingerId = (SDL_FingerID)(intptr_t)[touch identity];
+        float x = [touch normalizedPosition].x;
+        float y = [touch normalizedPosition].y;
+        /* Make the origin the upper left instead of the lower left */
+        y = 1.0f - y;
+
+        switch (type) {
+        case COCOA_TOUCH_DOWN:
+            SDL_SendTouch(touchId, fingerId, SDL_TRUE, x, y, 1.0f);
+            break;
+        case COCOA_TOUCH_UP:
+        case COCOA_TOUCH_CANCELLED:
+            SDL_SendTouch(touchId, fingerId, SDL_FALSE, x, y, 1.0f);
+            break;
+        case COCOA_TOUCH_MOVE:
+            SDL_SendTouchMotion(touchId, fingerId, x, y, 1.0f);
+            break;
+        }
+
+        touch = (NSTouch*)[enumerator nextObject];
+     }
+#else
     NSSet *touches = [theEvent touchesMatchingPhase:phase inView:nil];
 
     for (NSTouch *touch in touches) {
@@ -1127,7 +1256,9 @@
             break;
         }
     }
+#endif
 }
+#endif
 
 @end
 
@@ -1194,8 +1325,13 @@
 
 static int
 SetupWindowData(_THIS, SDL_Window * window, NSWindow *nswindow, SDL_bool created)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool;
+#endif
     SDL_VideoData *videodata = (SDL_VideoData *) _this->driverdata;
     SDL_WindowData *data;
 
@@ -1210,6 +1346,9 @@
     data->videodata = videodata;
     data->nscontexts = [[NSMutableArray alloc] init];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* Create an event listener for the window */
     data->listener = [[Cocoa_WindowListener alloc] init];
 
@@ -1270,15 +1409,27 @@
      */
     [nswindow setOneShot:NO];
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     /* All done! */
     window->driverdata = data;
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+}
+#else
 }}
+#endif
 
 int
 Cocoa_CreateWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_VideoData *videodata = (SDL_VideoData *) _this->driverdata;
     NSWindow *nswindow;
     SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
@@ -1286,6 +1437,10 @@
     SDL_Rect bounds;
     NSUInteger style;
     NSArray *screens = [NSScreen screens];
+#if !defined(MAC_OS_X_VERSION_10_5)
+    NSScreen *screen = nil;
+    int i;
+#endif
 
     Cocoa_GetDisplayBounds(_this, display, &bounds);
     rect.origin.x = window->x;
@@ -1297,8 +1452,14 @@
     style = GetWindowStyle(window);
 
     /* Figure out which screen to place this window */
+#if defined(MAC_OS_X_VERSION_10_5)
     NSScreen *screen = nil;
     for (NSScreen *candidate in screens) {
+#else
+    /* old way to iterate */
+    for (i = 0; i < [screens count]; i++) {
+        NSScreen *candidate = [screens objectAtIndex:i];
+#endif
         NSRect screenRect = [candidate frame];
         if (rect.origin.x >= screenRect.origin.x &&
             rect.origin.x < screenRect.origin.x + screenRect.size.width &&
@@ -1319,6 +1480,7 @@
     [nswindow setBackgroundColor:[NSColor blackColor]];
 
     if (videodata->allow_spaces) {
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
         SDL_assert(floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6);
         SDL_assert([nswindow respondsToSelector:@selector(toggleFullScreen:)]);
         /* we put FULLSCREEN_DESKTOP windows in their own Space, without a toggle button or menubar, later */
@@ -1326,6 +1488,7 @@
             /* resizable windows are Spaces-friendly: they get the "go fullscreen" toggle button on their titlebar. */
             [nswindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
         }
+#endif
     }
 
     /* Create a default view for this window */
@@ -1344,18 +1507,30 @@
 
     /* Allow files and folders to be dragged onto the window by users */
     [nswindow registerForDraggedTypes:[NSArray arrayWithObject:(NSString *)kUTTypeFileURL]];
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
 
     if (SetupWindowData(_this, window, nswindow, SDL_TRUE) < 0) {
         [nswindow release];
         return -1;
     }
     return 0;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_CreateWindowFrom(_THIS, SDL_Window * window, const void *data)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSWindow *nswindow = (NSWindow *) data;
     NSString *title;
 
@@ -1366,34 +1541,64 @@
     }
 
     return SetupWindowData(_this, window, nswindow, SDL_FALSE);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowTitle(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     const char *title = window->title ? window->title : "";
     NSWindow *nswindow = ((SDL_WindowData *) window->driverdata)->nswindow;
     NSString *string = [[NSString alloc] initWithUTF8String:title];
     [nswindow setTitle:string];
     [string release];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowIcon(_THIS, SDL_Window * window, SDL_Surface * icon)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSImage *nsimage = Cocoa_CreateImage(icon);
 
     if (nsimage) {
         [NSApp setApplicationIconImage:nsimage];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowPosition(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = windata->nswindow;
     NSRect rect;
@@ -1411,12 +1616,22 @@
     s_moveHack = moveHack;
 
     ScheduleContextUpdates(windata);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowSize(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = windata->nswindow;
     NSRect rect;
@@ -1438,12 +1653,22 @@
     s_moveHack = moveHack;
 
     ScheduleContextUpdates(windata);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowMinimumSize(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
 
     NSSize minSize;
@@ -1451,12 +1676,22 @@
     minSize.height = window->min_h;
 
     [windata->nswindow setContentMinSize:minSize];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowMaximumSize(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
 
     NSSize maxSize;
@@ -1464,12 +1699,22 @@
     maxSize.height = window->max_h;
 
     [windata->nswindow setContentMaxSize:maxSize];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_ShowWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windowData = ((SDL_WindowData *) window->driverdata);
     NSWindow *nswindow = windowData->nswindow;
 
@@ -1478,21 +1723,41 @@
         [nswindow makeKeyAndOrderFront:nil];
         [windowData->listener resumeVisibleObservation];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_HideWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSWindow *nswindow = ((SDL_WindowData *) window->driverdata)->nswindow;
 
     [nswindow orderOut:nil];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_RaiseWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windowData = ((SDL_WindowData *) window->driverdata);
     NSWindow *nswindow = windowData->nswindow;
 
@@ -1505,24 +1770,44 @@
         [nswindow makeKeyAndOrderFront:nil];
     }
     [windowData->listener resumeVisibleObservation];
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_MaximizeWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *windata = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = windata->nswindow;
 
     [nswindow zoom:nil];
 
     ScheduleContextUpdates(windata);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_MinimizeWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = data->nswindow;
 
@@ -1531,12 +1816,22 @@
     } else {
         [nswindow miniaturize:nil];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_RestoreWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     NSWindow *nswindow = ((SDL_WindowData *) window->driverdata)->nswindow;
 
     if ([nswindow isMiniaturized]) {
@@ -1544,23 +1839,44 @@
     } else if ((window->flags & SDL_WINDOW_RESIZABLE) && [nswindow isZoomed]) {
         [nswindow zoom:nil];
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 void
 Cocoa_SetWindowBordered(_THIS, SDL_Window * window, SDL_bool bordered)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     if (SetWindowStyle(window, GetWindowStyle(window))) {
         if (bordered) {
             Cocoa_SetWindowTitle(_this, window);  /* this got blanked out. */
         }
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
+
 
 void
 Cocoa_SetWindowResizable(_THIS, SDL_Window * window, SDL_bool resizable)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     /* Don't set this if we're in a space!
      * The window will get permanently stuck if resizable is false.
      * -flibit
@@ -1570,12 +1886,23 @@
     if (![listener isInFullscreenSpace]) {
         SetWindowStyle(window, GetWindowStyle(window));
     }
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
+
 
 void
 Cocoa_SetWindowFullscreen(_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
     NSWindow *nswindow = data->nswindow;
     NSRect rect;
@@ -1587,6 +1914,7 @@
 
     if (fullscreen) {
         SDL_Rect bounds;
+        NSRect screenRect;
 
         Cocoa_GetDisplayBounds(_this, display, &bounds);
         rect.origin.x = bounds.x;
@@ -1596,12 +1924,14 @@
         ConvertNSRect([nswindow screen], fullscreen, &rect);
 
         /* Hack to fix origin on Mac OS X 10.4 */
-        NSRect screenRect = [[nswindow screen] frame];
+        screenRect = [[nswindow screen] frame];
         if (screenRect.size.height >= 1.0f) {
             rect.origin.y += (screenRect.size.height - rect.size.height);
         }
 
+        if ([nswindow respondsToSelector:@selector(setStyleMask:)]) {
         [nswindow setStyleMask:NSWindowStyleMaskBorderless];
+        }
     } else {
         rect.origin.x = window->windowed.x;
         rect.origin.y = window->windowed.y;
@@ -1609,7 +1939,9 @@
         rect.size.height = window->windowed.h;
         ConvertNSRect([nswindow screen], fullscreen, &rect);
 
+        if ([nswindow respondsToSelector:@selector(setStyleMask:)]) {
         [nswindow setStyleMask:GetWindowStyle(window)];
+        }
 
         /* Hack to restore window decorations on Mac OS X 10.10 */
         NSRect frameRect = [nswindow frame];
@@ -1646,7 +1978,12 @@
     }
 
     ScheduleContextUpdates(data);
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 int
 Cocoa_SetWindowGammaRamp(_THIS, SDL_Window * window, const Uint16 * ramp)
@@ -1736,11 +2073,20 @@
 
 void
 Cocoa_DestroyWindow(_THIS, SDL_Window * window)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
 
     if (data) {
+#if !defined(MAC_OS_X_VERSION_10_5)
+        int i;
+        NSArray *contexts;
+#endif
         if ([data->listener isInFullscreenSpace]) {
             [NSMenu setMenuBarVisible:YES];
         }
@@ -1750,8 +2096,15 @@
             [data->nswindow close];
         }
 
+#if defined(MAC_OS_X_VERSION_10_5)
         NSArray *contexts = [[data->nscontexts copy] autorelease];
         for (SDLOpenGLContext *context in contexts) {
+#else
+        contexts = [[data->nscontexts copy] autorelease];
+        /* old way to iterate */
+        for (i = 0; i < [contexts count]; i++) {
+            SDLOpenGLContext *context = [contexts objectAtIndex:i];
+#endif
             /* Calling setWindow:NULL causes the context to remove itself from the context list. */            
             [context setWindow:NULL];
         }
@@ -1760,7 +2113,12 @@
         SDL_free(data);
     }
     window->driverdata = NULL;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+    [pool release];
+}
+#endif
 
 SDL_bool
 Cocoa_GetWindowWMInfo(_THIS, SDL_Window * window, SDL_SysWMinfo * info)
@@ -1792,8 +2150,13 @@
 
 SDL_bool
 Cocoa_SetWindowFullscreenSpace(SDL_Window * window, SDL_bool state)
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 { @autoreleasepool
 {
+#else
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+#endif
     SDL_bool succeeded = SDL_FALSE;
     SDL_WindowData *data = (SDL_WindowData *) window->driverdata;
 
@@ -1824,8 +2187,15 @@
         succeeded = SDL_TRUE;
     }
 
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 1070
+    [pool release];
+#endif
     return succeeded;
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1070
 }}
+#else
+}
+#endif
 
 int
 Cocoa_SetWindowHitTest(SDL_Window * window, SDL_bool enabled)
