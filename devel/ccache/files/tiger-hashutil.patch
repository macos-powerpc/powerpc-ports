Index: src/ccache/hashutil.cpp
===================================================================
--- src/ccache/hashutil.cpp.orig 2025-05-31 16:26:58.000000000 +0000
+++ src/ccache/hashutil.cpp 2025-05-31 16:29:41.000000000 +0000
@@ -448,6 +448,7 @@
   }
   return bool(compiler_check_result);
 #else
+# ifdef HAVE_SPAWN_H
   int pipefd[2];
   if (pipe(pipefd) == -1) {
     throw core::Fatal(FMT("pipe failed: {}", strerror(errno)));
@@ -493,6 +494,51 @@
     return false;
   }
   return bool(hash_result);
+# else  // !HAVE_SPAWN_H
+  int pipefd[2];
+  if (pipe(pipefd) == -1) {
+    throw core::Fatal(FMT("pipe failed: {}", strerror(errno)));
+  }
+
+  pid_t pid = fork();
+  if (pid == -1) {
+    throw core::Fatal(FMT("fork failed: {}", strerror(errno)));
+  }
+
+  if (pid == 0) {
+    // Child.
+    close(pipefd[0]);
+    close(0);
+    dup2(pipefd[1], 1);
+    dup2(pipefd[1], 2);
+    _exit(execvp(argv[0], const_cast<char* const*>(argv)));
+    // Never reached.
+  } else {
+    // Parent.
+    close(pipefd[1]);
+    const auto hash_result = hash.hash_fd(pipefd[0]);
+    if (!hash_result) {
+      LOG("Error hashing compiler check command output: {}",
+          hash_result.error());
+    }
+    close(pipefd[0]);
+
+    int status;
+    int result;
+    while ((result = waitpid(pid, &status, 0)) != pid) {
+      if (result == -1 && errno == EINTR) {
+        continue;
+      }
+      LOG("waitpid failed: {}", strerror(errno));
+      return false;
+    }
+    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
+      LOG("Compiler check command returned {}", WEXITSTATUS(status));
+      return false;
+    }
+    return bool(hash_result);
+  }
+# endif // !HAVE_SPAWN_H
 #endif
 }
