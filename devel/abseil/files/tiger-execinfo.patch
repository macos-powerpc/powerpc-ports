--- absl/debugging/internal/stacktrace_generic-inl.inc
+++ absl/debugging/internal/stacktrace_generic-inl.inc
@@ -18,11 +18,15 @@
 // This can cause a deadlock in HeapProfiler.
 
 #ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_GENERIC_INL_H_
 #define ABSL_DEBUGGING_INTERNAL_STACKTRACE_GENERIC_INL_H_
 
+#if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+
+#else
 #include <execinfo.h>
+#endif
 #include <atomic>
 #include <cstring>
 
 #include "absl/debugging/stacktrace.h"
 #include "absl/base/attributes.h"
@@ -50,7 +54,11 @@
   // Force the first backtrace to happen early to get the one-time shared lib
   // loading (allocation) out of the way. After the first call it is much safer
   // to use backtrace from a signal handler if we crash somewhere later.
+  #if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+
+  #else
   backtrace(unused_stack, 1);
+  #endif
   disable_stacktraces.store(false, std::memory_order_relaxed);
   return 0;
 }();
@@ -69,7 +77,11 @@
   void * stack[kStackLength];
   int size;
 
+  #if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+
+  #else
   size = backtrace(stack, kStackLength);
+  #endif
   skip_count++;  // we want to skip the current frame as well
   int result_count = size - skip_count;
   if (result_count < 0)
--- absl/debugging/symbolize_darwin.inc
+++ absl/debugging/symbolize_darwin.inc
@@ -13,7 +13,12 @@
 // limitations under the License.
 
 #include <cxxabi.h>
+#include <AvailabilityMacros.h>
+#if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+
+#else
 #include <execinfo.h>
+#endif
 
 #include <algorithm>
 #include <cstring>
@@ -68,23 +73,27 @@
   }
 
+#if defined(__APPLE__) && MAC_OS_X_VERSION_MIN_REQUIRED < 1050
+
+#else
   // This allocates a char* array.
   char** frame_strings = backtrace_symbols(const_cast<void**>(&pc), 1);
 
   if (frame_strings == nullptr) return false;
 
   std::string symbol = debugging_internal::GetSymbolString(frame_strings[0]);
   free(frame_strings);
 
   char tmp_buf[1024];
   if (debugging_internal::Demangle(symbol.c_str(), tmp_buf, sizeof(tmp_buf))) {
     size_t len = strlen(tmp_buf);
     if (len + 1 <= static_cast<size_t>(out_size)) {  // +1 for '\0'
       assert(len < sizeof(tmp_buf));
       memmove(out, tmp_buf, len + 1);
     }
   } else {
     strncpy(out, symbol.c_str(), static_cast<size_t>(out_size));
   }
+#endif
 
   if (out[out_size - 1] != '\0') {
     // strncpy() does not '\0' terminate when it truncates.