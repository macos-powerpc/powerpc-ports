From 4a8da43b3eb0cd07ab12179b58ad129395744972 Mon Sep 17 00:00:00 2001
From: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
Date: Fri, 27 Jan 2023 14:52:05 -0800
Subject: [PATCH 02/18] os: Use fallback implementations when *_CLOEXEC are
 unavailable at build time

On platforms without F_DUPFD_CLOEXEC, MSG_CMSG_CLOEXEC, or SOCK_CLOEXEC, we
should skip past their usage and just use the fcntl() fallback.

Signed-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>
---
 src/wayland-os.c         | 6 +++++-
 tests/os-wrappers-test.c | 7 +++++--
 2 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/src/wayland-os.c b/src/wayland-os.c
index e134c3a..87ab6d3 100644
--- a/src/wayland-os.c
+++ b/src/wayland-os.c
@@ -75,11 +75,13 @@ wl_os_socket_cloexec(int domain, int type, int protocol)
 {
 	int fd;
 
+#ifdef SOCK_CLOEXEC
 	fd = wl_socket(domain, type | SOCK_CLOEXEC, protocol);
 	if (fd >= 0)
 		return fd;
 	if (errno != EINVAL)
 		return -1;
+#endif
 
 	fd = wl_socket(domain, type, protocol);
 	return set_cloexec_or_close(fd);
@@ -150,11 +152,13 @@ wl_os_dupfd_cloexec(int fd, int minfd)
 {
 	int newfd;
 
+#ifdef F_DUPFD_CLOEXEC
 	newfd = wl_fcntl(fd, F_DUPFD_CLOEXEC, minfd);
 	if (newfd >= 0)
 		return newfd;
 	if (errno != EINVAL)
 		return -1;
+#endif
 
 	newfd = wl_fcntl(fd, F_DUPFD, minfd);
 	return set_cloexec_or_close(newfd);
@@ -202,7 +206,7 @@ wl_os_recvmsg_cloexec(int sockfd, struct msghdr *msg, int flags)
 	 * fix (https://cgit.freebsd.org/src/commit/?id=6ceacebdf52211).
 	 */
 #pragma message("Using fallback directly since MSG_CMSG_CLOEXEC is broken.")
-#else
+#elif defined(MSG_CMSG_CLOEXEC)
 	ssize_t len;
 
 	len = wl_recvmsg(sockfd, msg, flags | MSG_CMSG_CLOEXEC);
diff --git a/tests/os-wrappers-test.c b/tests/os-wrappers-test.c
index 061d29e..56ef4af 100644
--- a/tests/os-wrappers-test.c
+++ b/tests/os-wrappers-test.c
@@ -110,10 +110,12 @@ recvmsg_wrapper(int sockfd, struct msghdr *msg, int flags)
 {
 	wrapped_calls_recvmsg++;
 
+#ifdef MSG_CMSG_CLOEXEC
 	if (fall_back && (flags & MSG_CMSG_CLOEXEC)) {
 		errno = EINVAL;
 		return -1;
 	}
+#endif
 
 	return recvmsg(sockfd, msg, flags);
 }
@@ -323,9 +325,10 @@ do_os_wrappers_recvmsg_cloexec(int n)
 	struct marshal_data data;
 
 	data.nr_fds_begin = count_open_fds();
-#if HAVE_BROKEN_MSG_CMSG_CLOEXEC
+#if HAVE_BROKEN_MSG_CMSG_CLOEXEC || !defined(MSG_CMSG_CLOEXEC)
 	/* We call the fallback directly on FreeBSD versions with a broken
-	 * MSG_CMSG_CLOEXEC, so we don't call the local recvmsg() wrapper. */
+	 * MSG_CMSG_CLOEXEC or platforms without MSG_CMSG_CLOEXEC, so we
+         * don't call the local recvmsg() wrapper. */
 	data.wrapped_calls = 0;
 #else
 	data.wrapped_calls = n;
-- 
2.24.3 (Apple Git-128)

